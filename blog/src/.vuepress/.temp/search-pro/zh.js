export default "{\"documentCount\":309,\"nextId\":309,\"documentIds\":{\"0\":\"11\",\"1\":\"11#📋-个人信息\",\"2\":\"11#📝-简介\",\"3\":\"11#🚀-技能\",\"4\":\"11#🖥️-编程语言\",\"5\":\"11#🌐-前端技术\",\"6\":\"11#🛠️-后端技术\",\"7\":\"11#🗄️-数据库\",\"8\":\"11#🔧-工具\",\"9\":\"11#📚-项目经验\",\"10\":\"11#📦-项目名称1\",\"11\":\"11#📝-项目名称2\",\"12\":\"11#🎓-教育背景\",\"13\":\"11#🎖️-证书\",\"14\":\"11#🎨-兴趣爱好\",\"15\":\"11#💬-个人格言\",\"16\":\"21\",\"17\":\"21@0\",\"18\":\"22\",\"19\":\"22@0\",\"20\":\"23\",\"21\":\"23#_1-tcp和udp的区别\",\"22\":\"23#_2-tcp是如何做链接管理的\",\"23\":\"23#_3-tcp是如何保证可靠的\",\"24\":\"23#_4-重传机制有哪些\",\"25\":\"23#_5-tcp是如何保证有序的\",\"26\":\"23#_6-粘包问题\",\"27\":\"23#_7-滑动窗口\",\"28\":\"23#_8-拥塞控制\",\"29\":\"23#_9-tcp的三次握手和四次挥手\",\"30\":\"23#三次握手\",\"31\":\"23#_1-第一次握手\",\"32\":\"23#_2-第二次握手\",\"33\":\"23#_3-第三次握手\",\"34\":\"23#四次挥手\",\"35\":\"23#_1-第一次挥手\",\"36\":\"23#_2-第二次挥手\",\"37\":\"23#_3-第三次挥手\",\"38\":\"23#_4-第四次挥手\",\"39\":\"23#_10-time-wait状态的意义\",\"40\":\"23#_11-为什么需要三次握手而不是四次-两次\",\"41\":\"23#什么是restful风格\",\"42\":\"23#用户登录\",\"43\":\"23#_1-什么是oauth2-0\",\"44\":\"23#a-oauth-2-0-授权模式\",\"45\":\"23#_2-用户扫码是如何实现的\",\"46\":\"23#_3-如果要实现不同域名下的cookie正常使用-应该怎么处理\",\"47\":\"23#_4-假如1亿用户体量-如何设计一个登录验签服务\",\"48\":\"24\",\"49\":\"24#cup-cache\",\"50\":\"24#如何写出让-cpu-跑得更快的代码\",\"51\":\"24#数据缓存\",\"52\":\"24#指令缓存\",\"53\":\"24#多核-cpu-的缓存命中率\",\"54\":\"25\",\"55\":\"25#cpu如何执行任务的\",\"56\":\"25#cache-伪共享是什么\",\"57\":\"25#避免伪共享的方法\",\"58\":\"25#cpu-是根据什么来选择当前要执行的线程。\",\"59\":\"25#调度类\",\"60\":\"25#完全公平调度\",\"61\":\"25#cpu-运行队列\",\"62\":\"25#调整优先级\",\"63\":\"26\",\"64\":\"26#cpu-cache-的数据写入\",\"65\":\"26#写直达\",\"66\":\"26#写回\",\"67\":\"26#缓存一致性问题\",\"68\":\"26#总线嗅探\",\"69\":\"26#mesi-协议\",\"70\":\"27\",\"71\":\"27#中断\",\"72\":\"27#软中断\",\"73\":\"28\",\"74\":\"28#内存\",\"75\":\"28#中央处理器\",\"76\":\"28#总线\",\"77\":\"28#输入、输出设备\",\"78\":\"28#存储器的层次结构\",\"79\":\"29\",\"80\":\"29#用补码的形式保存负数\",\"81\":\"29#十进制小数与二进制的转换\",\"82\":\"29#计算机是怎么存小数的\",\"83\":\"29#在计算机中-0-1-0-2-并不等于完整的-0-3。\",\"84\":\"30\",\"85\":\"30#http基本概念\",\"86\":\"30#http是什么\",\"87\":\"30#http常见的状态码\",\"88\":\"30#http常见字段有哪些\",\"89\":\"30#get与post请求\",\"90\":\"30#get与post的区别\",\"91\":\"30#get和post的方法都是安全和幂等的吗\",\"92\":\"30#http缓存技术\",\"93\":\"30#强缓存\",\"94\":\"30#协商缓存\",\"95\":\"30#http特性\",\"96\":\"31\",\"97\":\"31#_1-如何避免发送http请求\",\"98\":\"31#_2-如何减少http请求次数\",\"99\":\"31#_3-如何减少http响应的数据大小\",\"100\":\"31#_1-http的性能问题\",\"101\":\"31#_2-兼容http1-1\",\"102\":\"31#_3-头部压缩\",\"103\":\"31#静态表编码\",\"104\":\"31#动态编码表\",\"105\":\"31#_4-二进制帧\",\"106\":\"31#_5-并发传输\",\"107\":\"31#_6-服务器主动推送资源\",\"108\":\"31#_1-http2的问题\",\"109\":\"31#_1-队头阻塞\",\"110\":\"31#_2-tcp与tls的握手延迟\",\"111\":\"31#_3-网络迁移需要重新连接\",\"112\":\"31#_2-quic协议的特点\",\"113\":\"31#_1-无队头阻塞\",\"114\":\"31#_2-更快连接建立\",\"115\":\"31#_3-连接迁移\",\"116\":\"31#_3-http3协议\",\"117\":\"32\",\"118\":\"32#_1-分析性能损耗\",\"119\":\"32#硬件优化\",\"120\":\"32#软件优化\",\"121\":\"32#证书优化\",\"122\":\"32#会话复用\",\"123\":\"32#https中tcp三次握手和tls握手能同时进行吗\",\"124\":\"33\",\"125\":\"33#http和https\",\"126\":\"33#_1-http和https的区别\",\"127\":\"33#_2-https解决了http的那些问题\",\"128\":\"33#如何解决的\",\"129\":\"33#_3-https是如何建立连接的-期间交互了什么\",\"130\":\"33#_4-https的应用数据时如保证完整性的\",\"131\":\"34\",\"132\":\"34#tcp-是有三个特点-面向连接、可靠、基于字节流。\",\"133\":\"34#_1-http和rpc的区别\",\"134\":\"34#_2-websocket是什么\",\"135\":\"35\",\"136\":\"35#apr\",\"137\":\"35#dhcp\",\"138\":\"35#nat\",\"139\":\"35#icmp\",\"140\":\"36\",\"141\":\"36#ping的工作原理\",\"142\":\"36#查询报文类型\",\"143\":\"36#traceroute\",\"144\":\"36#断网了还能ping通127-0-0-1吗\",\"145\":\"36#什么是127-0-0-1\",\"146\":\"36#tcp和ping数据的区别\",\"147\":\"36#为什么断网了还能ping通127-0-0-1\",\"148\":\"36#_127-0-0-1和localhost和0-0-00有什么区别\",\"149\":\"37\",\"150\":\"37#ip基本认识\",\"151\":\"37#ip的基础知识\",\"152\":\"37#ip的分类\",\"153\":\"37#什么是a-b-c类\",\"154\":\"37#什么是d类-e类\",\"155\":\"37#无分类地址cidr\",\"156\":\"37#公有-ip-地址与私有-ip-地址\",\"157\":\"37#ip-地址与路由控制\",\"158\":\"37#ip分片与重组\",\"159\":\"37#ipv6-基本认识\",\"160\":\"37#ipv6的首部改进\",\"161\":\"38\",\"162\":\"38#为什么-time-wait-等待的时间是-2msl\",\"163\":\"38#为什么需要-time-wait-状态\",\"164\":\"38#time-wait-过多有什么危害\",\"165\":\"38#如何优化-time-wait\",\"166\":\"38#服务器出现大量-time-wait-状态的原因有哪些\",\"167\":\"38#服务器出现大量-close-wait-状态的原因有哪些\",\"168\":\"39\",\"169\":\"39#什么是syn攻击-如何避免syn攻击\",\"170\":\"39#什么时syn超时-如何解决syn超时\",\"171\":\"40\",\"172\":\"40#udp和tcp的区别和应用场景\",\"173\":\"40#tcp和udp的区别\",\"174\":\"40#连接\",\"175\":\"41\",\"176\":\"41#针对tcp应该如何socket编程\",\"177\":\"41#listen-时候参数-backlog-的意义\",\"178\":\"41#accept-发生在三次握手的哪一步\",\"179\":\"41#客户端调用-close-了-连接是断开的流程是什么\",\"180\":\"41#服务端没有调用listen-客户端请求建立连接会发生什么\",\"181\":\"41#没有listen可以建立tcp连接吗\",\"182\":\"41#没有accpet-能建立tcp连接吗\",\"183\":\"41#为什么半连接队列要设计成哈希表\",\"184\":\"41#会有一个cookies队列吗\",\"185\":\"41#cookies方案为什么不直接取代半连接队列\",\"186\":\"41#tcp和udp可以同时绑定相同的端口吗\",\"187\":\"41#_1-tcp和udp可以同时绑定相同的端口吗\",\"188\":\"41#_2-多个tcp可以同时绑定一个端口吗\",\"189\":\"41#_3-重启-tcp-服务进程时-为什么会有-address-in-use-的报错信息\",\"190\":\"41#_4-重启-tcp-服务进程时-如何避免-address-in-use-的报错信息\",\"191\":\"41#_5-客户端的端口可以重复使用吗\",\"192\":\"41#_6-多个客户端可以-bind-同一个端口吗\",\"193\":\"41#_7-客户端-tcp-连接-time-wait-状态过多-会导致端口资源耗尽而无法建立新的连接吗\",\"194\":\"42\",\"195\":\"42#如何优化tcp\",\"196\":\"42#tcp三次握手的性能提升\",\"197\":\"42#tcp四次挥手性能的提升\",\"198\":\"42#tcp传输数据的性能提升\",\"199\":\"43\",\"200\":\"43#tcp基本认识\",\"201\":\"43#tcp的头格式\",\"202\":\"43#tcp工作在那一层\",\"203\":\"43#什么是tcp协议\",\"204\":\"43#什么是tcp连接\",\"205\":\"43#如何确定一个tcp连接\",\"206\":\"43#如何理解tcp是基于字节流的协议\",\"207\":\"43#先来说说为什么-udp-是面向报文的协议\",\"208\":\"43#再来说说为什么-tcp-是面向字节流的协议\",\"209\":\"43#tcp半连接队列和全连接队列\",\"210\":\"43#syn报文在什么情况下会被丢弃\",\"211\":\"43#拔掉网线之后-tcp连接会消失吗\",\"212\":\"43#为什么-tcp-tw-reuse-默认是关闭的\",\"213\":\"43#用了tcp传输数据就一定不会丢包吗\",\"214\":\"44\",\"215\":\"44#拥塞控制\",\"216\":\"44#慢启动\",\"217\":\"44#拥塞避免\",\"218\":\"44#拥塞发生\",\"219\":\"44#快速恢复\",\"220\":\"45\",\"221\":\"45#滑动窗口\",\"222\":\"45#窗口大小由哪一方决定\",\"223\":\"45#发送方的滑动窗口\",\"224\":\"45#程序如何表示发送方的四个部分呢\",\"225\":\"45#接收方的滑动窗口\",\"226\":\"45#接收窗口和发送窗口的大小是相等的吗\",\"227\":\"45#流量控制\",\"228\":\"45#操作系统缓冲区和滑动窗口的关系\",\"229\":\"45#窗口关闭\",\"230\":\"45#糊涂窗口综合征\",\"231\":\"46\",\"232\":\"46#tcp的重传机制\",\"233\":\"46#_1-超时重传\",\"234\":\"46#_2-快速重传\",\"235\":\"46#_3-sack方法\",\"236\":\"46#_4-duplicate-sack\",\"237\":\"47\",\"238\":\"47#tcp连接的建立\",\"239\":\"47#为什么是三次握手\",\"240\":\"47#为什么每次建立tcp链接的时候-初始化序列号的都要求不一样\",\"241\":\"47#初始序列号isn是如何随机产生的\",\"242\":\"47#既然ip层会分片-为什么tcp层还需要mss\",\"243\":\"47#当第一次握手丢失\",\"244\":\"47#第二次握手丢失\",\"245\":\"47#第三次握手丢失\",\"246\":\"47#为什么每次建立tcp连接-初始化序列号都要不一样\",\"247\":\"47#tcp-序列号和确认号是如何变化的\",\"248\":\"47#万能公式\",\"249\":\"47#已建立的tcp连接-收到syn会发生什么\",\"250\":\"47#killcx-的工具\",\"251\":\"47#tcpkill-的工具\",\"252\":\"47#tcp-的-keepalive-和-http-的-keep-alive-是一个东西吗\",\"253\":\"48\",\"254\":\"48#tcp断开连接\",\"255\":\"48#tcp的四次挥手\",\"256\":\"48#第一次挥手丢失\",\"257\":\"48#第二次挥手丢失\",\"258\":\"48#第三次挥手丢失\",\"259\":\"48#第四次挥手丢失\",\"260\":\"48#tcp四次挥手可以变成三次吗\",\"261\":\"48#粗暴关闭vs优雅关闭\",\"262\":\"48#什么情况下会出现三次挥手\",\"263\":\"48#四次挥手中收到乱序的fin包怎么办\",\"264\":\"48#在time-wait状态的tcp接收到syn报文会怎么样\",\"265\":\"48#syn合法\",\"266\":\"48#syn非法\",\"267\":\"48#在-time-wait-状态-收到-rst-会断开连接吗\",\"268\":\"48#如果已经建立了链接-客户端突然挂怎么办\",\"269\":\"48#如果已经建立了链接-服务端突然挂怎么办\",\"270\":\"48#tcp连接-一端断电和进程崩溃有什么区别\",\"271\":\"48#客户端主机宕机又重启\",\"272\":\"49\",\"273\":\"49#如何基于udp实现可靠传输\",\"274\":\"49#quic是如何实现可靠传输的\",\"275\":\"49#packet-header\",\"276\":\"49#quic-frame-header\",\"277\":\"49#quic-是如何解决-tcp-队头阻塞问题的\",\"278\":\"49#quic-是如何做流量控制的\",\"279\":\"49#quic-对拥塞控制改进\",\"280\":\"49#quic-更快的连接建立\",\"281\":\"49#quic-是如何迁移连接的\",\"282\":\"50\",\"283\":\"50#网络模型\",\"284\":\"51\",\"285\":\"51#应用层\",\"286\":\"51#用户态和内核态\",\"287\":\"51#传输层-作为传输媒介\",\"288\":\"51#网络层-有着实际的传输功能\",\"289\":\"51#ip协议的寻址作用\",\"290\":\"51#ip协议还可以路由\",\"291\":\"51#网络接口层\",\"292\":\"52\",\"293\":\"52#_1-浏览器第一步工作是解析ulr-然后生产http请求消息-然后会委托操作系统发送消息\",\"294\":\"52#_2-在发送之前-必须查询服务器域名对应的ip地址-在委托操作系统发送消息时必须提供通讯对象的ip地址\",\"295\":\"52#dns服务器-专门保存了-web-服务器域名与-ip-的对应关系\",\"296\":\"52#只指路不带路\",\"297\":\"52#_3-通过dns获取到ip后-把传输工作给操作系统中的协议栈\",\"298\":\"52#_4-http协议是基于tcp协议传输的\",\"299\":\"52#_1-第一次握手\",\"300\":\"52#_2-第二次握手\",\"301\":\"52#_3-第三次握手\",\"302\":\"52#完整的tcp报文\",\"303\":\"52#_4-ip\",\"304\":\"52#_5-mac\",\"305\":\"52#_5-网卡-真正的数据发送\",\"306\":\"52#_6-交换机\",\"307\":\"52#_7-路由器\",\"308\":\"52#_8-客户端-服务器\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[2],\"1\":[2,16],\"2\":[2,5],\"3\":[2],\"4\":[2,3],\"5\":[2,3],\"6\":[2,1],\"7\":[2,2],\"8\":[2,3],\"9\":[2],\"10\":[2,11],\"11\":[2,10],\"12\":[2,6],\"13\":[2],\"14\":[2,8],\"15\":[2,8],\"16\":[1],\"17\":[null,null,1],\"18\":[1],\"19\":[null,null,1],\"20\":[1,42],\"21\":[2,21],\"22\":[3,3],\"23\":[3,1],\"24\":[3,37],\"25\":[3,10],\"26\":[3,24],\"27\":[2,15],\"28\":[2,50],\"29\":[3],\"30\":[1],\"31\":[2,15],\"32\":[2,12],\"33\":[2,10],\"34\":[1],\"35\":[2,5],\"36\":[2,7],\"37\":[2,5],\"38\":[2,11],\"39\":[3,16],\"40\":[3],\"41\":[2,8],\"42\":[2],\"43\":[4,54],\"44\":[5,29],\"45\":[2,23],\"46\":[4,59],\"47\":[4,80],\"48\":[2],\"49\":[2,135],\"50\":[4,12],\"51\":[1,8],\"52\":[1,49],\"53\":[3,36],\"54\":[2],\"55\":[1],\"56\":[3,114],\"57\":[1,132],\"58\":[3,48],\"59\":[1,47],\"60\":[1,53],\"61\":[2,45],\"62\":[1,83],\"63\":[1],\"64\":[3,18],\"65\":[1,17],\"66\":[1,64],\"67\":[1,136],\"68\":[1,49],\"69\":[2,136],\"70\":[2],\"71\":[1,22],\"72\":[1,105],\"73\":[1,5],\"74\":[2,17],\"75\":[2,67],\"76\":[2,27],\"77\":[2,10],\"78\":[1,16],\"79\":[1],\"80\":[2,66],\"81\":[1,53],\"82\":[2,213],\"83\":[1,24],\"84\":[1],\"85\":[1],\"86\":[2,23],\"87\":[2],\"88\":[2,37],\"89\":[2],\"90\":[2,11],\"91\":[2,19],\"92\":[1,1],\"93\":[2,37],\"94\":[2,13],\"95\":[2,28],\"96\":[1],\"97\":[2,12],\"98\":[2,13],\"99\":[3,4],\"100\":[2,45],\"101\":[3,12],\"102\":[2,13],\"103\":[1,20],\"104\":[1,17],\"105\":[2,25],\"106\":[2,45],\"107\":[2,22],\"108\":[2,8],\"109\":[3,12],\"110\":[2,1],\"111\":[2,22],\"112\":[2,5],\"113\":[2,18],\"114\":[2,27],\"115\":[2,5],\"116\":[2,30],\"117\":[1],\"118\":[2,6],\"119\":[1,9],\"120\":[1,25],\"121\":[1,33],\"122\":[1,29],\"123\":[1,20],\"124\":[1],\"125\":[2],\"126\":[3,15],\"127\":[3,8],\"128\":[2,33],\"129\":[4,138],\"130\":[2,20],\"131\":[1],\"132\":[4,8],\"133\":[2,33],\"134\":[2,24],\"135\":[1],\"136\":[2,83],\"137\":[2,100],\"138\":[2,91],\"139\":[2,116],\"140\":[1],\"141\":[1],\"142\":[1,63],\"143\":[2,97],\"144\":[4],\"145\":[3,25],\"146\":[2,51],\"147\":[4,23],\"148\":[5,31],\"149\":[1],\"150\":[1,28],\"151\":[1,26],\"152\":[2,5],\"153\":[4,48],\"154\":[3,13],\"155\":[1,45],\"156\":[4,35],\"157\":[2,27],\"158\":[1,56],\"159\":[2,67],\"160\":[2,25],\"161\":[3],\"162\":[6,34],\"163\":[5,17],\"164\":[4,21],\"165\":[4,7],\"166\":[5,54],\"167\":[5,33],\"168\":[1],\"169\":[3,64],\"170\":[3,30],\"171\":[1],\"172\":[2],\"173\":[2],\"174\":[2,73],\"175\":[1],\"176\":[2,40],\"177\":[5,27],\"178\":[3,6],\"179\":[5,38],\"180\":[3,12],\"181\":[2,47],\"182\":[3,5],\"183\":[2,29],\"184\":[1,6],\"185\":[2,23],\"186\":[2],\"187\":[3,16],\"188\":[2,45],\"189\":[1,25],\"190\":[10,13],\"191\":[1,25],\"192\":[1,22],\"193\":[9,34],\"194\":[1],\"195\":[2],\"196\":[2,15],\"197\":[2,55],\"198\":[2,28],\"199\":[1],\"200\":[1],\"201\":[2,37],\"202\":[2,6],\"203\":[2,37],\"204\":[2,14],\"205\":[2,50],\"206\":[2],\"207\":[4,10],\"208\":[4,9],\"209\":[1,29],\"210\":[2,55],\"211\":[3,2],\"212\":[1,17],\"213\":[2,67],\"214\":[1],\"215\":[2,21],\"216\":[1,23],\"217\":[1,11],\"218\":[1,27],\"219\":[1,30],\"220\":[1],\"221\":[1,17],\"222\":[2,8],\"223\":[2,40],\"224\":[2,28],\"225\":[2,19],\"226\":[2,13],\"227\":[1,8],\"228\":[2,13],\"229\":[1,32],\"230\":[1,45],\"231\":[1],\"232\":[1],\"233\":[2,28],\"234\":[2,7],\"235\":[2,11],\"236\":[3,16],\"237\":[1],\"238\":[2,28],\"239\":[2,30],\"240\":[3,4],\"241\":[2,17],\"242\":[3,17],\"243\":[2,25],\"244\":[2,12],\"245\":[2,10],\"246\":[3,47],\"247\":[3],\"248\":[1,46],\"249\":[3,21],\"250\":[2,29],\"251\":[2,12],\"252\":[1,19],\"253\":[1],\"254\":[1],\"255\":[2,30],\"256\":[2,8],\"257\":[2,22],\"258\":[2,5],\"259\":[1,11],\"260\":[2,11],\"261\":[2,51],\"262\":[2,34],\"263\":[1,11],\"264\":[3],\"265\":[2,14],\"266\":[2,14],\"267\":[8,4],\"268\":[2,12],\"269\":[2,9],\"270\":[3,30],\"271\":[2,2],\"272\":[1],\"273\":[1],\"274\":[2,2],\"275\":[2,25],\"276\":[3,14],\"277\":[5,32],\"278\":[3,38],\"279\":[2,7],\"280\":[2,28],\"281\":[3,19],\"282\":[1],\"283\":[2,63],\"284\":[1,4],\"285\":[2,7],\"286\":[2,3],\"287\":[3,28],\"288\":[3,5],\"289\":[2,11],\"290\":[1,4],\"291\":[2,17],\"292\":[2],\"293\":[4],\"294\":[3],\"295\":[4,19],\"296\":[1],\"297\":[3,33],\"298\":[2,9],\"299\":[2,25],\"300\":[2,17],\"301\":[2,10],\"302\":[2],\"303\":[2,26],\"304\":[2,28],\"305\":[4,14],\"306\":[2,34],\"307\":[2,60],\"308\":[3,16]},\"averageFieldLength\":[2.1353812858817522,28.083495109258095,0.10277777777777777],\"storedFields\":{\"0\":{\"h\":\"🌟 Flipped的个人介绍页 🌟\"},\"1\":{\"h\":\"📋 个人信息\",\"t\":[\"姓名: Flipped\",\"职位: 牛马大学生\",\"联系方式: \",\"📧 邮箱: 3154147351@qq.com\",\"📱 手机: 不给\",\"🐱 GitHub: github.com/Flipped\"]},\"2\":{\"h\":\"📝 简介\",\"t\":[\"你好！我是Flipped，一名在校大学生，热衷于学习新技术并将其应用于实际项目中。\"]},\"3\":{\"h\":\"🚀 技能\"},\"4\":{\"h\":\"🖥️ 编程语言\",\"t\":[\"JavaScript\",\"Python\",\"C++\"]},\"5\":{\"h\":\"🌐 前端技术\",\"t\":[\"Vue.js\",\"HTML5\"]},\"6\":{\"h\":\"🛠️ 后端技术\",\"t\":[\"Go\"]},\"7\":{\"h\":\"🗄️ 数据库\",\"t\":[\"MySQL\",\"MongoDB\"]},\"8\":{\"h\":\"🔧 工具\",\"t\":[\"Git\",\"Docker\",\"Kubernetes\"]},\"9\":{\"h\":\"📚 项目经验\"},\"10\":{\"h\":\"📦 项目名称1\",\"t\":[\"描述: 一个基于go语言开发的投票系统\",\"职责: 全栈开发\",\"技术栈: go, JavaScript\",\"亮点: 实现了用户注册、投票，以及投票管理\"]},\"11\":{\"h\":\"📝 项目名称2\",\"t\":[\"描述: 一个基于Vue的博客系统\",\"职责: 前端开发\",\"技术栈: Vue\",\"亮点: 实现了文章发布、评论、点赞等功能\"]},\"12\":{\"h\":\"🎓 教育背景\",\"t\":[\"本科: 信息与计算科学, 河南科技学院 (2021-2025)\"]},\"13\":{\"h\":\"🎖️ 证书\"},\"14\":{\"h\":\"🎨 兴趣爱好\",\"t\":[\"🖥️ 编程\",\"📚 阅读\",\"🌍 旅行\",\"🎵 音乐\"]},\"15\":{\"h\":\"💬 个人格言\",\"t\":[\"\\\"永远不要停止学习，因为生活永远不会停止教导。\\\"\",\"感谢您的阅读！如需更多信息或讨论技术问题，请随时联系我。\",\"更新日期: 2024年5月29日\"]},\"16\":{\"h\":\"学习笔记\"},\"17\":{\"c\":[\"计算机基础\"]},\"18\":{\"h\":\"LeetCode\"},\"19\":{\"c\":[\"计算机基础\"]},\"20\":{\"h\":\"用户登录\",\"t\":[\"僵尸进程（Zombie Process）：当一个进程完成执行，但其父进程尚未调用wait()或waitpid()来获取其终止状态时，该进程就成为僵尸进程。僵尸进程不再执行任何代码，但在系统进程表中仍然存在，直到其父进程请求并处理了它的终止状态为止。\",\"孤儿进程（Orphan Process）：当父进程提前终止或意外退出时，其子进程可能会成为孤儿进程。这些孤儿进程会被 init 进程（在大多数Unix系统中是PID为1的特殊进程）接管。init 进程会成为孤儿进程的新父进程，并负责回收它们的资源，防止它们变成僵尸进程。\",\"守护进程（Daemon Process）：守护进程是在后台运行的系统服务进程，通常在系统启动时启动，并一直运行直到系统关闭。它们通常不与用户直接交互，而是执行系统级别的任务，如日志记录、网络服务等。\",\"饥饿进程（Starvation Process）：饥饿进程是指因为资源分配问题而无法获得所需资源（如CPU时间、内存等）而无法继续执行的进程。饥饿可能是由于不公平的资源分配策略或竞争条件引起的。\",\"[TOC]\",\"计网部分：\"]},\"21\":{\"h\":\"1.TCP和UDP的区别\",\"t\":[\"TCP和UDP是传输层常见的两种传输协议，提供一种可靠的数据传输和通信方式；\",\"其中，TCP的特点是：面向连接，可靠的，基于字节流的\",\"提供一种可靠的数据传输，所以一般适用于上传下载，网页请求，邮件发送等场景\",\"UDP的特点是：无连接，不可靠的，面向报文的 提供一种快速，但相对不可靠的数据传输，所以常用在对数据实时性要求较高，对数据完整性和正确性不那么高的场景，比如音视频通话，一些实时游戏\"]},\"22\":{\"h\":\"2.TCP是如何做链接管理的？\",\"t\":[\"TCP在连接时使用三次握手，在断开时使用四次握手；确保连接的稳定和可靠\"]},\"23\":{\"h\":\"3.TCP是如何保证可靠的？\",\"t\":[\"通过确认应答机制以及重传机制来保证数据传输的可靠\"]},\"24\":{\"h\":\"4.重传机制有哪些？\",\"t\":[\"1.超时重传：已建立连接或者正在建立连接的两方，其中一方在发出数据包之后超一定时间，不返回ACK包，那么这一方就会认定出现丢包现象，重传这个数据包\",\"2.快速重传：已建立连接或者正在建立连接的两方，其中一方在发出数据包之后，重复三次收到相同的ACK包，那么这一方就会认为数据包丢失，重传数据包； 快速重传解决了超时重传重传周期太长的问题，但是超时重传和快速重传都具有一个问题：在一端 发送一堆数据包之后，其中某一个/几个数据包丢失时，无法精准定位是哪一个/几个，所以会选择将这个数据包之后的所有数据包全部重传一遍，容易造成资源的浪费，和网络的负担\",\"3.SACK：在TCP头部加一个SACK字段在每次接收完数据之后，将接收到数据的信息放到ACK包的这个字段，告知对方接收了哪些数据；这样如果出现数据丢失，发送方根据这一字段就可以精准定位这个丢失包，并且重发这个包\",\"4.Duplicate SACK：又称D_SACK，用于通知发送方哪些数据被重复接收了；让发送方知道时丢包还是网络延迟\"]},\"25\":{\"h\":\"5.TCP是如何保证有序的？\",\"t\":[\"在发送方，当传输层使用TCP协议时，数据包在经过传输层时可能会被拆分成多个小数据包，这个时候在TCP报文段中，每段数据都会被标记上一个序列号，表示数据在数据流中的位置\",\"在发送方接受到这些数据包的时候，会将它放到缓冲区，并根据序列号进行排序和重新组装，以确保数据的有序性\"]},\"26\":{\"h\":\"6.粘包问题？\",\"t\":[\"TCP时一个面向字节流的协议，所谓字节流就是一串没有边界的二进制数据\",\"在当使用TCP协议时，在传输层，一个完整的数据包可能会被拆分成多个小的数据包，也可能多个小的数据包会被合并成一个大数据包发送，就会出现连包和拆包的问题，导致接收方无法正确解析数据边界，造成数据处理错误\",\"解决方法：\",\"1.固定数据长度：在发送数据的同时，将每个包的长度固定\",\"2.使用特殊符号标识边界：例如在每一个完整的数据之后加一个特殊字符\",\"3.自定义消息结构：我们可以自定义一个消息结构，由头部和消息体组成，在头部保存当前整个消息的长度\",\"4.通过自定义协议\"]},\"27\":{\"h\":\"7.滑动窗口\",\"t\":[\"在TCP建立连接的时候，双方协商缓冲区大小，通过Window字段告知对方本端的缓冲区大小， 并在TCP连接建立之后开辟出一片缓冲区\",\"在连接建立之后，发送端就可以跟据接收端和本端窗口大小，向对方发送相应的字节数；接收放在接收完数据之后将其放到缓冲区，等待上层应用读取，当数据被读取，相应的缓冲区就会被释放；并跟据本端剩余缓冲区大小通告对方当前能接受数据的缓冲区大小\",\"发送方根据接收方的窗口变化，相应改变本端的窗口大小；然后发送方就可以根据接收端和本端窗口大小继续发送数据\"]},\"28\":{\"h\":\"8.拥塞控制\",\"t\":[\"1.慢启动：在TCP连接建立完成之后，它发送数据的能力会呈指数形式增长，每收到1次ACK，拥塞窗口加1\",\"2.拥塞避免：当拥塞窗口超过慢启动门限，就会进入拥塞避免算法，此时他发送数据的能力呈线性增长，每当收到一个 ACK 时，cwnd 增加 1/cwnd。\",\"3.拥塞发生：\",\"发生超时重传的拥塞发生算法：慢启动门限变成拥塞窗口/2，直接将拥塞窗口降为1\",\"发生快速重传的拥塞发生算法：将拥塞窗口减半，慢启动门限等于当前拥塞窗口，进入快恢复算法\",\"4.快速恢复：\",\"拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；\",\"重传丢失的数据包；\",\"如果再收到重复的 ACK，那么 cwnd 增加 1；\",\"如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；\"]},\"29\":{\"h\":\"9.TCP的三次握手和四次挥手？\"},\"30\":{\"h\":\"三次握手\"},\"31\":{\"h\":\"1.第一次握手\",\"t\":[\"首先双方都处于closed状态，客户端会发送一个带有SYN（同步序列编号）标志的TCP报文到服务器，表示客户端请求连接；并且在其中客户端还会选择一个ISN（初始序列号）放入SYN报文段中\",\"第一次握手之后：客户端处于SYN_SENT状态（同步已发送），服务器处于LISTEN（监听状态）\"]},\"32\":{\"h\":\"2.第二次握手\",\"t\":[\"服务器同意建立连接，会回复一个带有SYN和ACK（确认号）标识的TCP报文；服务器也会选择一个初始序列号用于标识服务器到客户端的数据流\",\"第二次握手之后：客户端处于SYN_SENT状态，服务器处于SYN-RCVD（半连接状态）\"]},\"33\":{\"h\":\"3.第三次握手\",\"t\":[\"客户端在接收服务器的带有SYN和ACK（确认号）标识的TCP报文之后，会向服务器发送一个带有ACK标志的确认报文段;并且这个报文字段包含客户端收到的服务端的ISN，以及ACK（表示客户端希望下一次接受的序列号）\",\"第三次握手之后：客户端和服务器都进入ESTABLISHED\",\"三次握手的目的是确认双方都有发送和接受的能力\"]},\"34\":{\"h\":\"四次挥手\"},\"35\":{\"h\":\"1.第一次挥手\",\"t\":[\"客户端主动想要断开连接，向服务器发送一个FIN报文，之后客户端进入FIN_WAIT_1状态\"]},\"36\":{\"h\":\"2.第二次挥手\",\"t\":[\"服务端收到该报文，向客户端发送一个ACK报文，服务端进入CLOSE_WAIT状态，客户端接收之后进入FIN_WAIT_2状态\"]},\"37\":{\"h\":\"3.第三次挥手\",\"t\":[\"服务端可能还有数据需要处理和发送，等服务端不再发送数据时，发送FIN报文，之后服务端进入LAST_ACK状态\"]},\"38\":{\"h\":\"4.第四次挥手\",\"t\":[\"客户端向服务端发送ACK报文，服务端接收到报文之后进入CLOSE状态，而客户端则会TIME_WAIT(2MSL)之后进入CLOSE状态\",\"主动关闭连接的，才有 TIME_WAIT 状态。\"]},\"39\":{\"h\":\"10.time_wait状态的意义\",\"t\":[\"TIME_WAIT状态标识一个连接已经完成了关闭过程，并且在等最后的确认报文\",\"有两点作用：\",\"第一点：\",\"防止历史连接中的数据，被后面相同四元组的连接错误的接收；\",\"第二点：\",\"保证「被动关闭连接」的一方，能被正确的关闭；\",\"如果没有time_wait状态或者time_wait时间太短，可能导致数据错乱或者连接错误\"]},\"40\":{\"h\":\"11.为什么需要三次握手而不是四次，两次\"},\"41\":{\"h\":\"什么是restful风格？\",\"t\":[\"RESTful 是一种针对网络应用程序设计的架构风格，它基于 HTTP 协议，强调了资源的标识、状态和操作的统一性。\"]},\"42\":{\"h\":\"用户登录：\"},\"43\":{\"h\":\"1.什么是OAUTH2.0?\",\"t\":[\"OAuth 2.0 是一种用于授权的开放标准协议，它允许第三方应用程序在资源所有者的许可下访问资源所有者的资源，而无需暴露资源所有者的凭据（如用户名和密码）。它通常用于提供第三方访问HTTP服务，例如社交媒体账户、在线文件存储等。OAuth 2.0 是 OAuth 协议的第二个版本，比 OAuth 1.0 简化了许多流程，增强了灵活性和安全性。\",\"OAuth 2.0 的工作流程主要涉及以下角色：\",\"资源所有者（Resource Owner）：即用户，拥有受保护的资源，并通过授权服务器授予客户端访问这些资源的权限\",\"客户端（Client）：想要访问资源拥有者的资源的应用程序。它需要获得授权才能访问资源服务器上的受保护资源。\",\"授权服务器（Authorization Server）：处理客户端的授权请求，并颁发访问令牌。授权服务器验证资源拥有者的身份并获取其授权。\",\"资源服务器（Resource Server）：托管资源拥有者的受保护资源，并使用访问令牌来验证和处理客户端的请求。\",\"OAuth 2.0 的基本授权流程如下：\",\"客户端请求授权：客户端向资源所有者请求授权，通常通过用户界面引导用户进行授权。\",\"资源所有者授予授权：资源所有者同意授权，并通过授权服务器生成授权代码（Authorization Code）。\",\"客户端获取授权代码：客户端收到授权代码。\",\"客户端交换授权代码：客户端将授权代码发送给授权服务器，交换访问令牌。\",\"授权服务器颁发访问令牌：授权服务器验证授权代码并向客户端颁发访问令牌。\",\"客户端访问资源：客户端使用访问令牌访问资源服务器上的资源。\"]},\"44\":{\"h\":\"a. OAuth 2.0 授权模式\",\"t\":[\"OAuth 2.0 定义了多种授权模式，以满足不同的应用场景：\",\"授权码模式（Authorization Code Grant）：最常用的模式，适用于服务器端应用，包含了授权码的获取和交换流程。\",\"简化模式（Implicit Grant）：主要用于浏览器中的单页应用，省略了授权码的交换步骤，直接获取访问令牌。\",\"密码模式（Resource Owner Password Credentials Grant）：用户直接向客户端提供用户名和密码，适用于信任级别较高的应用。\",\"客户端凭证模式（Client Credentials Grant）：客户端以自身身份获取访问令牌，用于访问自身资源或服务端间的交互。\"]},\"45\":{\"h\":\"2.用户扫码是如何实现的\",\"t\":[\"这边以微信登陆为例：\",\"首先用户点击微信登陆，第三方网站或应用程序生成一个用于登录的二维码，并将其展示给用户。\",\"用户使用微信扫描该二维码。\",\"微信客户端将请求发送到微信服务器，并请求用户授权该第三方应用程序访问其个人信息。\",\"用户在微信客户端上看到授权请求，可以选择允许或拒绝。\",\"如果用户同意授权，微信服务器带着授权码回调到回调地址上，然后第三方网站或应用程序带着这个授权码向微信服务器请求令牌\",\"微信服务器在校验授权码有效性之后，将向第三方应用程序颁发一个访问令牌（Access Token），该令牌用于代表用户访问其个人信息。\",\"第三方应用程序可以使用此访问令牌来获取用户的个人信息，例如昵称、头像等。用户在第三方应用程序中进行操作，第三方应用程序使用访问令牌向微信服务器请求用户的个人信息。\"]},\"46\":{\"h\":\"3. 如果要实现不同域名下的cookie正常使用，应该怎么处理？\",\"t\":[\"设置 Cookie 的域名属性： 当设置 Cookie 时，可以通过指定域名属性来确保 Cookie 在不同子域名之间共享。例如，如果你希望 Cookie 在example.com和subdomain.example.com之间共享，则可以设置 Cookie 的域名属性为.example.com（注意前面的点号），这样 Cookie 就可以在所有以example.com为结尾的子域名下共享。\",\"document.cookie = \\\"name=value; domain=.example.com; path=/\\\";\",\"设置跨域资源共享（CORS）： 如果是通过 AJAX 或 Fetch 发起的跨域请求，需要在服务器端设置适当的 CORS 头来允许跨域请求。服务器响应中应包含 Access-Control-Allow-Origin 头，并设置为允许访问的域名。例如：\",\"Access-Control-Allow-Origin: https://example.com\",\"使用代理： 如果跨域请求不能通过上述方法解决，可以考虑在服务器端设置代理，即在同一域名下创建一个中间层，由该中间层代理请求到其他域名，然后再将结果返回给客户端。这种方法可以绕过浏览器的同源策略限制。\",\"设置 Cookie 的路径：确保路径参数设置为 Cookie 所在的路径。通常，将路径设置为根路径 / 是最简单和最通用的方法，使得 Cookie 在整个网站的所有页面中可用。\",\"document.cookie = \\\"name=value; domain=.example.com; path=/\\\";\"]},\"47\":{\"h\":\"4.假如1亿用户体量，如何设计一个登录验签服务？\",\"t\":[\"设计一个支持 1 亿用户体量的登录验签服务需要考虑到高可用性、安全性和性能等因素。以下是一个可能的设计方案：\",\"负载均衡：使用负载均衡技术将流量分发到多个服务器上，以确保服务的高可用性和可扩展性。可以考虑使用负载均衡器如 Nginx 或 AWS ELB。\",\"分布式架构：采用分布式架构，将用户数据和登录状态分布在多个服务器上，以应对大规模用户的访问。可以使用分布式数据库（如MySQL Cluster、Cassandra等）或 NoSQL 数据库（如MongoDB、Redis等）来存储用户数据和登录状态。\",\"安全性：\",\"使用 HTTPS 协议进行通信，以保障数据的安全传输。\",\"对用户密码进行加密存储，推荐使用哈希函数加盐存储用户密码，如 bcrypt。\",\"使用 JWT（JSON Web Token）或类似的令牌机制来生成并验证用户身份，避免在服务端存储用户的敏感信息。\",\"实施防火墙、DDoS 防护和安全审计等安全措施，保护系统免受恶意攻击。\",\"高性能：\",\"使用缓存技术加速登录验签过程，例如，将经常访问的用户信息存储在缓存中，减少数据库访问次数。\",\"使用异步处理技术，如消息队列，将请求分发给多个工作节点并行处理，提高系统的响应速度和吞吐量。\",\"对数据库进行优化，如索引、分片等，以提高查询性能和扩展性。\",\"监控和日志：建立完善的监控系统，实时监控系统运行状态、性能指标和异常情况，并及时进行预警和处理。同时，记录日志以便追踪和排查问题。\",\"容灾备份：定期进行数据备份，并建立容灾备份系统，以防止数据丢失和系统故障导致的服务中断。\",\"合理的访问限制：实施合理的访问限制策略，如限制登录失败次数、IP 访问频率等，以防止暴力破解和恶意攻击。\",\"持续优化：定期进行性能测试和优化，不断改进系统架构和代码实现，以适应不断增长的用户体量和变化的需求。\"]},\"48\":{\"h\":\"CPU Cache\"},\"49\":{\"h\":\"cup cache\",\"t\":[\"L1 Cache 通常会分为「数据缓存」和「指令缓存」\",\"L1 Cache 和 L2 Cache 都是每个 CPU 核心独有的，而 L3 Cache 是多个 CPU 核心共享的。\",\"程序执行时，会先将内存中的数据加载到共享的 L3 Cache 中，再加载到每个核心独有的 L2 Cache，最后进入到最快的 L1 Cache，之后才会被 CPU 读取。它们之间的层级关系，如下图：\",\"越靠近 CPU 核心的缓存其访问速度越快，CPU 访问 L1 Cache 只需要 2~4 个时钟周期，访问 L2 Cache 大约 10~20 个时钟周期，访问 L3 Cache 大约 20~60 个时钟周期，而访问内存速度大概在 200~300 个 时钟周期之间。如下表格：\",\"CPU Cache 是由很多个 Cache Line 组成的。CPU Cache Line ，它表示 CPU Cache 一次性能加载数据的大小，而 Cache Line 是由各种标志（Tag）+ 数据块（Data Block）组成\",\"CPU Cache 的数据是从内存中读取过来的，它是以一小块一小块读取数据的，而不是按照单个数组元素来读取数据的，在 CPU Cache 中的，这样一小块一小块的数据，称为 Cache Line（缓存块）。\",\"直接映射 Cache 采用的策略，就是把内存块的地址始终「映射」在一个 CPU Cache Line（缓存块） 的地址，至于映射关系实现方式，则是使用「取模运算」，取模运算的结果就是内存块地址对应的 CPU Cache Line（缓存块） 的地址。但是这样会出现多个内存块对应同一个 CPU Cache Line\",\"举个例子，内存共被划分为 32 个内存块，CPU Cache 共有 8 个 CPU Cache Line，假设 CPU 想要访问第 15 号内存块，如果 15 号内存块中的数据已经缓存在 CPU Cache Line 中的话，则是一定映射在 7 号 CPU Cache Line 中，因为 15 % 8 的值是 7。\",\"因此，为了区别不同的内存块，在对应的 CPU Cache Line 中我们还会存储一个组标记（Tag）。这个组标记会记录当前 CPU Cache Line 中存储的数据对应的内存块，我们可以用这个组标记来区分不同的内存块。\",\"除了组标记信息外，CPU Cache Line 还有两个信息：\",\"一个是，从内存加载过来的实际存放数据（*Data*）。\",\"另一个是，有效位（*Valid bit*），它是用来标记对应的 CPU Cache Line 中的数据是否是有效的，如果有效位是 0，无论 CPU Cache Line 中是否有数据，CPU 都会直接访问内存，重新加载数据。\",\"CPU 在从 CPU Cache 读取数据的时候，并不是读取 CPU Cache Line 中的整个数据块，而是读取 CPU 所需要的一个数据片段，这样的数据统称为一个字（*Word*）。那怎么在对应的 CPU Cache Line 中数据块中找到所需的字呢？答案是，需要一个偏移量（Offset）。\",\"因此，一个内存的访问地址，包括组标记、CPU Cache Line 索引、偏移量这三种信息，于是 CPU 就能通过这些信息，在 CPU Cache 中找到缓存的数据。而对于 CPU Cache 里的数据结构，则是由索引 + 有效位 + 组标记 + 数据块组成。\"]},\"50\":{\"h\":\"如何写出让 CPU 跑得更快的代码？\",\"t\":[\"以如果 CPU 所要操作的数据在 CPU Cache 中的话，这样将会带来很大的性能提升。访问的数据在 CPU Cache 中的话，意味着缓存命中，缓存命中率越高的话，代码的性能就会越好，CPU 也就跑的越快。因此我们要来着手提高缓存的命中率\"]},\"51\":{\"h\":\"数据缓存\",\"t\":[\"遇到遍历数组的情况时，按照内存布局顺序访问，将可以有效的利用 CPU Cache 带来的好处，提高数据缓存的命中率，这样我们代码的性能就会得到很大的提升\"]},\"52\":{\"h\":\"指令缓存\",\"t\":[\"分支预测器。对于 if 条件语句，意味着此时至少可以选择跳转到两段不同的指令执行，也就是 if 还是 else 中的指令。那么，如果分支预测可以预测到接下来要执行 if 里的指令，还是 else 指令的话，就可以「提前」把这些指令放在指令缓存中，这样 CPU 可以直接从 Cache 读取到指令，于是执行速度就会很快。\",\"你觉得先遍历再排序速度快，还是先排序再遍历速度快呢？\",\"当数组中的元素是随机的，分支预测就无法有效工作，而当数组元素都是是顺序的，分支预测器会动态地根据历史命中数据对未来进行预测，这样命中率就会很高。\",\"因此，先排序再遍历速度会更快，这是因为排序之后，数字是从小到大的，那么前几次循环命中 if < 50 的次数会比较多，于是分支预测就会缓存 if 里的 array[i] = 0 指令到 Cache 中，后续 CPU 执行该指令就只需要从 Cache 读取就好了。\"]},\"53\":{\"h\":\"多核 CPU 的缓存命中率\",\"t\":[\"在单核 CPU中，虽然只能执行一个线程，但是操作系统给每个线程分配了一个时间片，时间片用完了，就调度下一个线程，于是各个线程就按时间片交替地占用 CPU，从宏观上看起来各个线程同时在执行。\",\"而现代 CPU 都是多核心的，线程可能在不同 CPU 核心来回切换执行，这对 CPU Cache 不是有利的，虽然 L3 Cache 是多核心之间共享的，但是 L1 和 L2 Cache 都是每个核心独有的，如果一个线程在不同核心来回切换，各个核心的缓存命中率就会受到影响，相反如果线程都在同一个核心上执行，那么其数据的 L1 和 L2 Cache 的缓存命中率可以得到有效提高，缓存命中率高就意味着 CPU 可以减少访问 内存的频率。\",\"线程绑定在某一个 CPU 核心上，这样性能可以得到非常可观的提升。\"]},\"54\":{\"h\":\"CUP是如何执行任务的?\"},\"55\":{\"h\":\"CPU如何执行任务的\"},\"56\":{\"h\":\"Cache 伪共享是什么？\",\"t\":[\"现在假设有一个双核心的 CPU，这两个 CPU 核心并行运行着两个不同的线程，它们同时从内存中读取两个不同的数据，分别是类型为 long 的变量 A 和 B，这个两个数据的地址在物理内存上是连续的，如果 Cahce Line 的大小是 64 字节，并且变量 A 在 Cahce Line 的开头位置，那么这两个数据是位于同一个 Cache Line 中，又因为 CPU Cache Line 是 CPU 从内存读取数据到 Cache 的单位，所以这两个数据会被同时读入到了两个 CPU 核心中各自 Cache 中。\",\"①.最开始变量 A 和 B 都还不在 Cache 里面，假设 1 号核心绑定了线程 A，2 号核心绑定了线程 B，线程 A 只会读写变量 A，线程 B 只会读写变量 B。\",\"②. 1 号核心读取变量 A，由于 CPU 从内存读取数据到 Cache 的单位是 Cache Line，也正好变量 A 和 变量 B 的数据归属于同一个 Cache Line，所以 A 和 B 的数据都会被加载到 Cache，并将此 Cache Line 标记为「独占」状态。\",\"③. 接着，2 号核心开始从内存里读取变量 B，同样的也是读取 Cache Line 大小的数据到 Cache 中，此 Cache Line 中的数据也包含了变量 A 和 变量 B，此时 1 号和 2 号核心的 Cache Line 状态变为「共享」状态。\",\"④. 1 号核心需要修改变量 A，发现此 Cache Line 的状态是「共享」状态，所以先需要通过总线发送消息给 2 号核心，通知 2 号核心把 Cache 中对应的 Cache Line 标记为「已失效」状态，然后 1 号核心对应的 Cache Line 状态变成「已修改」状态，并且修改变量 A。\",\"⑤. 之后，2 号核心需要修改变量 B，此时 2 号核心的 Cache 中对应的 Cache Line 是已失效状态，另外由于 1 号核心的 Cache 也有此相同的数据，且状态为「已修改」状态，所以要先把 1 号核心的 Cache 对应的 Cache Line 写回到内存，然后 2 号核心再从内存读取 Cache Line 大小的数据到 Cache 中，最后把变量 B 修改到 2 号核心的 Cache 中，并将状态标记为「已修改」状态。\",\"所以，可以发现如果 1 号和 2 号 CPU 核心这样持续交替的分别修改变量 A 和 B，就会重复 ④ 和 ⑤ 这两个步骤，Cache 并没有起到缓存的效果，虽然变量 A 和 B 之间其实并没有任何的关系，但是因为同时归属于一个 Cache Line ，这个 Cache Line 中的任意数据被修改后，都会相互影响，从而出现 ④ 和 ⑤ 这两个步骤。\",\"因此，这种因为多个线程同时读写同一个 Cache Line 的不同变量时，而导致 CPU Cache 失效的现象称为伪共享（*False Sharing*）。\"]},\"57\":{\"h\":\"避免伪共享的方法\",\"t\":[\"因此，对于多个线程共享的热点数据，即经常会修改的数据，应该避免这些数据刚好在同一个 Cache Line 中，否则就会出现为伪共享的问题。\",\"接下来，看看在实际项目中是用什么方式来避免伪共享的问题的。\",\"在 Linux 内核中存在 __cacheline_aligned_in_smp 宏定义，是用于解决伪共享的问题。\",\"从上面的宏定义，我们可以看到：\",\"如果在多核（MP）系统里，该宏定义是 __cacheline_aligned，也就是 Cache Line 的大小；\",\"而如果在单核系统里，该宏定义是空的；\",\"因此，针对在同一个 Cache Line 中的共享的数据，如果在多核之间竞争比较严重，为了防止伪共享现象的发生，可以采用上面的宏定义使得变量在 Cache Line 里是对齐的。\",\"举个例子，有下面这个结构体：\",\"结构体里的两个成员变量 a 和 b 在物理内存地址上是连续的，于是它们可能会位于同一个 Cache Line 中，如下图：\",\"所以，为了防止前面提到的 Cache 伪共享问题，我们可以使用上面介绍的宏定义，将 b 的地址设置为 Cache Line 对齐地址，如下：\",\"这样 a 和 b 变量就不会在同一个 Cache Line 中了，如下图：\",\"所以，避免 Cache 伪共享实际上是用空间换时间的思想，浪费一部分 Cache 空间，从而换来性能的提升。\",\"我们再来看一个应用层面的规避方案，有一个 Java 并发框架 Disruptor 使用「字节填充 + 继承」的方式，来避免伪共享的问题。\",\"Disruptor 中有一个 RingBuffer 类会经常被多个线程使用，代码如下：\",\"你可能会觉得 RingBufferPad 类里 7 个 long 类型的名字很奇怪，但事实上，它们虽然看起来毫无作用，但却对性能的提升起到了至关重要的作用。\",\"我们都知道，CPU Cache 从内存读取数据的单位是 CPU Cache Line，一般 64 位 CPU 的 CPU Cache Line 的大小是 64 个字节，一个 long 类型的数据是 8 个字节，所以 CPU 一下会加载 8 个 long 类型的数据。\",\"根据 JVM 对象继承关系中父类成员和子类成员，内存地址是连续排列布局的，因此 RingBufferPad 中的 7 个 long 类型数据作为 Cache Line 前置填充，而 RingBuffer 中的 7 个 long 类型数据则作为 Cache Line 后置填充，这 14 个 long 变量没有任何实际用途，更不会对它们进行读写操作。\",\"另外，RingBufferFelds 里面定义的这些变量都是 final 修饰的，意味着第一次加载之后不会再修改， 又由于「前后」各填充了 7 个不会被读写的 long 类型变量，所以无论怎么加载 Cache Line，这整个 Cache Line 里都没有会发生更新操作的数据，于是只要数据被频繁地读取访问，就自然没有数据被换出 Cache 的可能，也因此不会产生伪共享的问题。\"]},\"58\":{\"h\":\"CPU 是根据什么来选择当前要执行的线程。\",\"t\":[\"在 Linux 内核中，进程和线程都是用 task_struct 结构体表示的，区别在于线程的 task_struct 结构体里部分资源是共享了进程已创建的资源，比如内存地址空间、代码段、文件描述符等，所以 Linux 中的线程也被称为轻量级进程，因为线程的 task_struct 相比进程的 task_struct 承载的 资源比较少，因此以「轻」得名。\",\"一般来说，没有创建线程的进程，是只有单个执行流，它被称为是主线程。如果想让进程处理更多的事情，可以创建多个线程分别去处理，但不管怎么样，它们对应到内核里都是 task_struct。\",\"所以，Linux 内核里的调度器，调度的对象就是 task_struct，接下来我们就把这个数据结构统称为任务。\",\"在 Linux 系统中，根据任务的优先级以及响应要求，主要分为两种，其中优先级的数值越小，优先级越高：\",\"实时任务，对系统的响应时间要求很高，也就是要尽可能快的执行实时任务，优先级在 0~99 范围内的就算实时任务；\",\"普通任务，响应时间没有很高的要求，优先级在 100~139 范围内都是普通任务级别；\"]},\"59\":{\"h\":\"调度类\",\"t\":[\"由于任务有优先级之分，Linux 系统为了保障高优先级的任务能够尽可能早的被执行，于是分为了这几种调度类，如下图：\",\"Deadline 和 Realtime 这两个调度类，都是应用于实时任务的，这两个调度类的调度策略合起来共有这三种，它们的作用如下：\",\"SCHED_DEADLINE：是按照 deadline 进行调度的，距离当前时间点最近的 deadline 的任务会被优先调度；\",\"SCHED_FIFO：对于相同优先级的任务，按先来先服务的原则，但是优先级更高的任务，可以抢占低优先级的任务，也就是优先级高的可以「插队」；\",\"SCHED_RR：对于相同优先级的任务，轮流着运行，每个任务都有一定的时间片，当用完时间片的任务会被放到队列尾部，以保证相同优先级任务的公平性，但是高优先级的任务依然可以抢占低优先级的任务；\",\"而 Fair 调度类是应用于普通任务，都是由 CFS 调度器管理的，分为两种调度策略：\",\"SCHED_NORMAL：普通任务使用的调度策略；\",\"SCHED_BATCH：后台任务的调度策略，不和终端进行交互，因此在不影响其他需要交互的任务，可以适当降低它的优先级。\"]},\"60\":{\"h\":\"完全公平调度\",\"t\":[\"我们平日里遇到的基本都是普通任务，对于普通任务来说，公平性最重要，在 Linux 里面，实现了一个基于 CFS 的调度算法，也就是完全公平调度（*Completely Fair Scheduling*）。\",\"这个算法的理念是想让分配给每个任务的 CPU 时间是一样，于是它为每个任务安排一个虚拟运行时间 vruntime，如果一个任务在运行，其运行的越久，该任务的 vruntime 自然就会越大，而没有被运行的任务，vruntime 是不会变化的。\",\"那么，在 CFS 算法调度的时候，会优先选择 vruntime 少的任务，以保证每个任务的公平性。\",\"虽然是普通任务，但是普通任务之间还是有优先级区分的，所以在计算虚拟运行时间 vruntime 还要考虑普通任务的权重值，注意权重值并不是优先级的值，内核中会有一个 nice 级别与权重值的转换表，nice 级别越低的权重值就越大。 于是就有了以下这个公式：\",\"你可以不用管 NICE_0_LOAD 是什么，你就认为它是一个常量，那么在「同样的实际运行时间」里，高权重任务的 vruntime 比低权重任务的 vruntime 少，于是高权重的获得的实际运行时间自然就多了。\"]},\"61\":{\"h\":\"CPU 运行队列\",\"t\":[\"一个系统通常都会运行着很多任务，多任务的数量基本都是远超 CPU 核心数量，因此这时候就需要排队。\",\"事实上，每个 CPU 都有自己的运行队列（*Run Queue, rq*），用于描述在此 CPU 上所运行的所有进程，其队列包含三个运行队列，Deadline 运行队列 dl_rq、实时任务运行队列 rt_rq 和 CFS 运行队列 cfs_rq，其中 cfs_rq 是用红黑树来描述的，按 vruntime 大小来排序的，最左侧的叶子节点，就是下次会被调度的任务。\",\"这几种调度类是有优先级的，优先级如下：Deadline > Realtime > Fair，这意味着 Linux 选择下一个任务执行的时候，会按照此优先级顺序进行选择，也就是说先从 dl_rq 里选择任务，然后从 rt_rq 里选择任务，最后从 cfs_rq 里选择任务。因此，实时任务总是会比普通任务优先被执行。\"]},\"62\":{\"h\":\"调整优先级\",\"t\":[\"如果我们启动任务的时候，没有特意去指定优先级的话，默认情况下都是普通任务，普通任务的调度类是 Fair，由 CFS 调度器来进行管理。CFS 调度器的目的是实现任务运行的公平性，也就是保障每个任务的运行的时间是差不多的。\",\"如果你想让某个普通任务有更多的执行时间，可以调整任务的 nice 值，从而让优先级高一些的任务执行更多时间。nice 的值能设置的范围是 -20～19， 值越低，表明优先级越高，因此 -20 是最高优先级，19 则是最低优先级，默认优先级是 0。\",\"是不是觉得 nice 值的范围很诡异？事实上，nice 值并不是表示优先级，而是表示优先级的修正数值，它与优先级（priority）的关系是这样的：priority(new) = priority(old) + nice。内核中，priority 的范围是 0~139，值越低，优先级越高，其中前面的 0~99 范围是提供给实时任务使用的，而 nice 值是映射到 100~139，这个范围是提供给普通任务用的，因此 nice 值调整的是普通任务的优先级。\",\"在前面我们提到了，权重值与 nice 值的关系的，nice 值越低，权重值就越大，计算出来的 vruntime 就会越少，由于 CFS 算法调度的时候，就会优先选择 vruntime 少的任务进行执行，所以 nice 值越低，任务的优先级就越高。\",\"我们可以在启动任务的时候，可以指定 nice 的值，比如将 mysqld 以 -3 优先级：\",\"如果想修改已经运行中的任务的优先级，则可以使用 renice 来调整 nice 值：\",\"nice 调整的是普通任务的优先级，所以不管怎么缩小 nice 值，任务永远都是普通任务，如果某些任务要求实时性比较高，那么你可以考虑改变任务的优先级以及调度策略，使得它变成实时任务，比如：\",\"!\"]},\"63\":{\"h\":\"CUP的缓存一致性\"},\"64\":{\"h\":\"CPU Cache 的数据写入\",\"t\":[\"事实上，数据不光是只有读操作，还有写操作，那么如果数据写入 Cache 之后，内存与 Cache 相对应的数据将会不同，这种情况下 Cache 和内存数据都不一致了，于是我们肯定是要把 Cache 中的数据同步到内存里的。\",\"写直达（Write Through）\",\"写回（Write Back）\"]},\"65\":{\"h\":\"写直达\",\"t\":[\"保持内存与 Cache 一致性最简单的方式是，把数据同时写入内存和 Cache 中，这种方法称为写直达（*Write Through*）。\",\"写直达法很直观，也很简单，但是问题明显，无论数据在不在 Cache 里面，每次写操作都会写回到内存，这样写操作将会花费大量的时间，无疑性能会受到很大的影响。\"]},\"66\":{\"h\":\"写回\",\"t\":[\"在写回机制中，当发生写操作时，新的数据仅仅被写入 Cache Block 里，只有当修改过的 Cache Block「被替换」时才需要写到内存中，减少了数据写回内存的频率，这样便可以提高系统的性能。\",\"如果当发生写操作时，数据已经在 CPU Cache 里的话，则把数据更新到 CPU Cache 里，同时标记 CPU Cache 里的这个 Cache Block 为脏（Dirty）的，这个脏的标记代表这个时候，我们 CPU Cache 里面的这个 Cache Block 的数据和内存是不一致的，这种情况是不用把数据写到内存里的；\",\"如果当发生写操作时，数据所对应的 Cache Block 里存放的是「别的内存地址的数据」的话，就要检查这个 Cache Block 里的数据有没有被标记为脏的： \",\"如果是脏的话，我们就要把这个 Cache Block 里的数据写回到内存，然后再把当前要写入的数据，先从内存读入到 Cache Block 里，然后再把当前要写入的数据写入到 Cache Block，最后也把它标记为脏的；\",\"如果不是脏的话，把当前要写入的数据先从内存读入到 Cache Block 里，接着将数据写入到这个 Cache Block 里，然后再把这个 Cache Block 标记为脏的就好了。\",\"这样的好处是，如果我们大量的操作都能够命中缓存，那么大部分时间里 CPU 都不需要读写内存，自然性能相比写直达会高很多。\",\"为什么缓存没命中时，还要定位 Cache Block？这是因为此时是要判断数据即将写入到 cache block 里的位置，是否被「其他数据」占用了此位置，如果这个「其他数据」是脏数据，那么就要帮忙把它写回到内存。\",\"左半部分就是读操作的流程，右半部分就是写操作的流程：\"]},\"67\":{\"h\":\"缓存一致性问题\",\"t\":[\"现在 CPU 都是多核的，由于 L1/L2 Cache 是多个核心各自独有的，那么会带来多核心的缓存一致性（*Cache Coherence*） 的问题，如果不能保证缓存一致性的问题，就可能造成结果错误。\",\"假设 A 号核心和 B 号核心同时运行两个线程，都操作共同的变量 i（初始值为 0 ）。\",\"这时如果 A 号核心执行了 i++ 语句的时候，为了考虑性能，使用了我们前面所说的写回策略，先把值为 1 的执行结果写入到 L1/L2 Cache 中，然后把 L1/L2 Cache 中对应的 Block 标记为脏的，这个时候数据其实没有被同步到内存中的，因为写回策略，只有在 A 号核心中的这个 Cache Block 要被替换的时候，数据才会写入到内存里。\",\"如果这时旁边的 B 号核心尝试从内存读取 i 变量的值，则读到的将会是错误的值，因为刚才 A 号核心更新 i 值还没写入到内存中，内存中的值还依然是 0。这个就是所谓的缓存一致性问题，A 号核心和 B 号核心的缓存，在这个时候是不一致，从而会导致执行结果的错误。\",\"那么，要解决这一问题，就需要一种机制，来同步两个不同核心里面的缓存数据。\",\"第一点，某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为写传播（*Write Propagation*）；\",\"第二点，某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为事务的串行化（*Transaction Serialization*）。\",\"第一点写传播很容易就理解，当某个核心在 Cache 更新了数据，就需要同步到其他核心的 Cache 里。\",\"假设我们有一个含有 4 个核心的 CPU，这 4 个核心都操作共同的变量 i（初始值为 0 ）。A 号核心先把 i 值变为 100，而此时同一时间，B 号核心先把 i 值变为 200，这里两个修改，都会「传播」到 C 和 D 号核心。\",\"那么问题就来了，C 号核心先收到了 A 号核心更新数据的事件，再收到 B 号核心更新数据的事件，因此 C 号核心看到的变量 i 是先变成 100，后变成 200。\",\"而如果 D 号核心收到的事件是反过来的，则 D 号核心看到的是变量 i 先变成 200，再变成 100，虽然是做到了写传播，但是各个 Cache 里面的数据还是不一致的。\",\"所以，我们要保证 C 号核心和 D 号核心都能看到相同顺序的数据变化，比如变量 i 都是先变成 100，再变成 200，这样的过程就是事务的串行化。\",\"要实现事务串行化，要做到 2 点：\",\"CPU 核心对于 Cache 中数据的操作，需要同步给其他 CPU 核心；\",\"要引入「锁」的概念，如果两个 CPU 核心里有相同数据的 Cache，那么对于这个 Cache 数据的更新，只有拿到了「锁」，才能进行对应的数据更新。\"]},\"68\":{\"h\":\"总线嗅探\",\"t\":[\"写传播的原则就是当某个 CPU 核心更新了 Cache 中的数据，要把该事件广播通知到其他核心。最常见实现的方式是总线嗅探（*Bus Snooping*）。\",\"我还是以前面的 i 变量例子来说明总线嗅探的工作机制，当 A 号 CPU 核心修改了 L1 Cache 中 i 变量的值，通过总线把这个事件广播通知给其他所有的核心，然后每个 CPU 核心都会监听总线上的广播事件，并检查是否有相同的数据在自己的 L1 Cache 里面，如果 B 号 CPU 核心的 L1 Cache 中有该数据，那么也需要把该数据更新到自己的 L1 Cache。\",\"可以发现，总线嗅探方法很简单， CPU 需要每时每刻监听总线上的一切活动，但是不管别的核心的 Cache 是否缓存相同的数据，都需要发出一个广播事件，这无疑会加重总线的负载。\",\"另外，总线嗅探只是保证了某个 CPU 核心的 Cache 更新数据这个事件能被其他 CPU 核心知道，但是并不能保证事务串行化。\",\"于是，有一个协议基于总线嗅探机制实现了事务串行化，也用状态机机制降低了总线带宽压力，这个协议就是 MESI 协议，这个协议就做到了 CPU 缓存一致性\"]},\"69\":{\"h\":\"MESI 协议\",\"t\":[\"MESI 协议其实是 4 个状态单词的开头字母缩写，分别是：\",\"Modified，已修改\",\"Exclusive，独占\",\"Shared，共享\",\"Invalidated，已失效\",\"这四个状态来标记 Cache Line 四个不同的状态。\",\"「已修改」状态就是我们前面提到的脏标记，代表该 Cache Block 上的数据已经被更新过，但是还没有写到内存里。而「已失效」状态，表示的是这个 Cache Block 里的数据已经失效了，不可以读取该状态的数据。\",\"「独占」和「共享」状态都代表 Cache Block 里的数据是干净的，也就是说，这个时候 Cache Block 里的数据和内存里面的数据是一致性的。\",\"「独占」和「共享」的差别在于，独占状态的时候，数据只存储在一个 CPU 核心的 Cache 里，而其他 CPU 核心的 Cache 没有该数据。这个时候，如果要向独占的 Cache 写数据，就可以直接自由地写入，而不需要通知其他 CPU 核心，因为只有你这有这个数据，就不存在缓存一致性的问题了，于是就可以随便操作该数据。\",\"另外，在「独占」状态下的数据，如果有其他核心从内存读取了相同的数据到各自的 Cache ，那么这个时候，独占状态下的数据就会变成共享状态。\",\"那么，「共享」状态代表着相同的数据在多个 CPU 核心的 Cache 里都有，所以当我们要更新 Cache 里面的数据的时候，不能直接修改，而是要先向所有的其他 CPU 核心广播一个请求，要求先把其他核心的 Cache 中对应的 Cache Line 标记为「无效」状态，然后再更新当前 Cache 里面的数据。\",\"我们举个具体的例子来看看这四个状态的转换：\",\"当 A 号 CPU 核心从内存读取变量 i 的值，数据被缓存在 A 号 CPU 核心自己的 Cache 里面，此时其他 CPU 核心的 Cache 没有缓存该数据，于是标记 Cache Line 状态为「独占」，此时其 Cache 中的数据与内存是一致的；\",\"然后 B 号 CPU 核心也从内存读取了变量 i 的值，此时会发送消息给其他 CPU 核心，由于 A 号 CPU 核心已经缓存了该数据，所以会把数据返回给 B 号 CPU 核心。在这个时候， A 和 B 核心缓存了相同的数据，Cache Line 的状态就会变成「共享」，并且其 Cache 中的数据与内存也是一致的；\",\"当 A 号 CPU 核心要修改 Cache 中 i 变量的值，发现数据对应的 Cache Line 的状态是共享状态，则要向所有的其他 CPU 核心广播一个请求，要求先把其他核心的 Cache 中对应的 Cache Line 标记为「无效」状态，然后 A 号 CPU 核心才更新 Cache 里面的数据，同时标记 Cache Line 为「已修改」状态，此时 Cache 中的数据就与内存不一致了。\",\"如果 A 号 CPU 核心「继续」修改 Cache 中 i 变量的值，由于此时的 Cache Line 是「已修改」状态，因此不需要给其他 CPU 核心发送消息，直接更新数据即可。\",\"如果 A 号 CPU 核心的 Cache 里的 i 变量对应的 Cache Line 要被「替换」，发现 Cache Line 状态是「已修改」状态，就会在替换前先把数据同步到内存。\",\"所以，可以发现当 Cache Line 状态是「已修改」或者「独占」状态时，修改更新其数据不需要发送广播给其他 CPU 核心，这在一定程度上减少了总线带宽压力。\",\"事实上，整个 MESI 的状态可以用一个有限状态机来表示它的状态流转。下图即是 MESI 协议的状态图：\",\"MESI 协议的四种状态之间的流转过程：\"]},\"70\":{\"h\":\"什么是中断？\"},\"71\":{\"h\":\"中断\",\"t\":[\"在计算机中，中断是系统用来响应硬件设备请求的一种机制，操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应请求。\",\"中断是一种异步的事件处理机制，可以提高系统的并发处理能力。\",\"操作系统收到了中断请求，会打断其他进程的运行，所以中断请求的响应程序，也就是中断处理程序，要尽可能快的执行完，这样可以减少对正常进程运行调度地影响。\",\"中断处理程序在响应中断时，可能还会「临时关闭中断」，这意味着，如果当前中断处理程序没有执行完之前，系统中其他的中断请求都无法被响应，也就说中断有可能会丢失，所以中断处理程序要短且快。\"]},\"72\":{\"h\":\"软中断\",\"t\":[\"Linux 系统为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了两个阶段，分别是「上半部和下半部分」。\",\"上半部用来快速处理中断，一般会暂时关闭中断请求，主要负责处理跟硬件紧密相关或者时间敏感的事情。\",\"下半部用来延迟处理上半部未完成的工作，一般以「内核线程」的方式运行。\",\"网卡收到网络包后，通过 DMA 方式将接收到的数据写入内存，接着会通过硬件中断通知内核有新的数据到了，于是内核就会调用对应的中断处理程序来处理该事件，这个事件的处理也是会分成上半部和下半部。\",\"上部分要做的事情很少，会先禁止网卡中断，避免频繁硬中断，而降低内核的工作效率。接着，内核会触发一个软中断，把一些处理比较耗时且复杂的事情，交给「软中断处理程序」去做，也就是中断的下半部，其主要是需要从内存中找到网络数据，再按照网络协议栈，对网络数据进行逐层解析和处理，最后把数据送给应用程序。\",\"所以，中断处理程序的上部分和下半部可以理解为：\",\"上半部直接处理硬件请求，也就是硬中断，主要是负责耗时短的工作，特点是快速执行；\",\"下半部是由内核触发，也就说软中断，主要是负责上半部未完成的工作，通常都是耗时比较长的事情，特点是延迟执行；\",\"还有一个区别，硬中断（上半部）是会打断 CPU 正在执行的任务，然后立即执行中断处理程序，而软中断（下半部）是以内核线程的方式执行，并且每一个 CPU 都对应一个软中断内核线程，名字通常为「ksoftirqd/CPU 编号」，比如 0 号 CPU 对应的软中断内核线程的名字是 ksoftirqd/0\",\"不过，软中断不只是包括硬件设备中断处理程序的下半部，一些内核自定义事件也属于软中断，比如内核调度等、RCU 锁（内核里常用的一种锁）等\",\"在 Linux 系统里，我们可以通过查看 /proc/softirqs 的 内容来知晓「软中断」的运行情况，以及 /proc/interrupts 的 内容来知晓「硬中断」的运行情况。\",\"如果在 top 命令发现，CPU 在软中断上的使用率比较高，而且 CPU 使用率最高的进程也是软中断 ksoftirqd 的时候，这种一般可以认为系统的开销被软中断占据了。\",\"这时我们就可以分析是哪种软中断类型导致的，一般来说都是因为网络接收软中断导致的，如果是的话，可以用 sar 命令查看是哪个网卡的有大量的网络包接收，再用 tcpdump 抓网络包，做进一步分析该网络包的源头是不是非法地址，如果是就需要考虑防火墙增加规则，如果不是，则考虑硬件升级等。\"]},\"73\":{\"h\":\"冯诺依曼模型\",\"t\":[\"运算器，存储器，控制器，输入设备，输出设备\"]},\"74\":{\"h\":\"内存：\",\"t\":[\"我们的程序和数据都是存储在内存，存储的区域是线性的。内存的地址是从 0 开始编号的，然后自增排列，最后一个地址为内存总字节数 - 1。\",\"在计算机数据存储中，存储数据的基本单位是字节（*byte*），1 字节等于 8 位（8 bit）。每一个字节都对应一个内存地址。\"]},\"75\":{\"h\":\"中央处理器：\",\"t\":[\"中央处理器也就是我们常说的 CPU，32 位和 64 位 CPU 最主要区别在于一次能计算多少字节数据：\",\"32 位 CPU 一次可以计算 4 个字节；\",\"64 位 CPU 一次可以计算 8 个字节；\",\"这里的 32 位和 64 位，通常称为 CPU 的位宽，代表的是 CPU 一次可以计算（运算）的数据量。\",\"之所以 CPU 要这样设计，是为了能计算更大的数值，如果是 8 位的 CPU，那么一次只能计算 1 个字节 0~255 范围内的数值，这样就无法一次完成计算 10000 * 500 ，于是为了能一次计算大数的运算，CPU 需要支持多个 byte 一起计算，所以 CPU 位宽越大，可以计算的数值就越大，比如说 32 位 CPU 能计算的最大整数是 4294967295。\",\"CPU 内部还有一些组件，常见的有寄存器、控制单元和逻辑运算单元等。其中，控制单元负责控制 CPU 工作，逻辑运算单元负责计算，而寄存器可以分为多种类，每种寄存器的功能又不尽相同。\",\"CPU 中的寄存器主要作用是存储计算时的数据\",\"常见的寄存器种类：\",\"通用寄存器，用来存放需要进行运算的数据，比如需要进行加和运算的两个数据。\",\"程序计数器，用来存储 CPU 要执行下一条指令「所在的内存地址」，注意不是存储了下一条要执行的指令，此时指令还在内存中，程序计数器只是存储了下一条指令「的地址」。\",\"指令寄存器，用来存放当前正在执行的指令，也就是指令本身，指令被执行完成之前，指令都存储在这里。\"]},\"76\":{\"h\":\"总线：\",\"t\":[\"总线是用于 CPU 和内存以及其他设备之间的通信，总线可分为 3 种：\",\"地址总线，用于指定 CPU 将要操作的内存地址；\",\"数据总线，用于读写内存的数据；\",\"控制总线，用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线；\",\"当 CPU 要读写内存数据的时候，一般需要通过下面这三个总线：\",\"首先要通过「地址总线」来指定内存的地址；\",\"然后通过「控制总线」控制是读或写命令；\",\"最后通过「数据总线」来传输数据；\"]},\"77\":{\"h\":\"输入、输出设备\",\"t\":[\"输入设备向计算机输入数据，计算机经过计算后，把数据输出给输出设备。期间，如果输入设备是键盘，按下按键时是需要和 CPU 进行交互的，这时就需要用到控制总线了。\"]},\"78\":{\"h\":\"存储器的层次结构\",\"t\":[\"每个存储器只和相邻的一层存储器设备打交道，并且存储设备为了追求更快的速度，所需的材料成本必然也是更高，也正因为成本太高，所以 CPU 内部的寄存器、L1\\\\L2\\\\L3 Cache 只好用较小的容量，相反内存、硬盘则可用更大的容量，这就我们今天所说的存储器层次结构。\"]},\"79\":{\"h\":\"计算机保存数据的形式\"},\"80\":{\"h\":\"用补码的形式保存负数：\",\"t\":[\"我们以 int 类型的数字作为例子，int 类型是 32 位的，其中最高位是作为「符号标志位」，正数的符号位是 0，负数的符号位是 1，剩余的 31 位则表示二进制数据。\",\"那么，对于 int 类型的数字 1 的二进制数表示如下：\",\"而负数就比较特殊了点，负数在计算机中是以「补码」表示的，所谓的补码就是把正数的二进制全部取反再加 1，比如 -1 的二进制是把数字 1 的二进制取反后再加 1，如下图：\",\"为什么计算机要用补码的方式来表示负数？\",\"假设不用补码的方式来表示负数，而只是把最高位的符号标志位变为 1 表示负数，如下图过程：\",\"如果采用这种方式来表示负数的二进制的话，试想一下 -2 + 1 的运算过程，如下图：\",\"上面的运算过程中得到结果是 -3，这种负数的表示方式是不能用常规的加法来计算了，就需要特殊处理，要先判断数字是否为负数，如果是负数就要把加法操作变成减法操作才可以得到正确对结果。\",\"到这里，我们就可以回答前面提到的「负数为什么要用补码方式来表示」的问题了。\",\"如果负数不是使用补码的方式表示，则在做基本对加减法运算的时候，还需要多一步操作来判断是否为负数，如果为负数，还得把加法反转成减法，或者把减法反转成加法，这就非常不好了，毕竟加减法运算在计算机里是很常使用的，所以为了性能考虑，应该要尽量简化这个运算过程。\",\"而用了补码的表示方式，对于负数的加减法操作，实际上是和正数加减法操作一样的。你可以看到下图，用补码表示的负数在运算 -2 + 1 过程的时候，其结果是正确的：\"]},\"81\":{\"h\":\"十进制小数与二进制的转换\",\"t\":[\"小数部分的转换不同于整数部分，它采用的是乘 2 取整法，将十进制中的小数部分乘以 2 作为二进制的一位，然后继续取小数部分乘以 2 作为下一位，直到不存在小数为止。\",\"以 8.625 转二进制作为例子\",\"最后把「整数部分 + 小数部分」结合在一起后，其结果就是 1000.101。\",\"但是，并不是所有小数都可以用二进制表示，前面提到的 0.625 小数是一个特例，刚好通过乘 2 取整法的方式完整的转换成二进制。\",\"如果我们用相同的方式，来把 0.1 转换成二进制，过程如下：\",\"可以发现，0.1 的二进制表示是无限循环的。\",\"由于计算机的资源是有限的，所以是没办法用二进制精确的表示 0.1，只能用「近似值」来表示，就是在有限的精度情况下，最大化接近 0.1 的二进制数，于是就会造成精度缺失的情况。\",\"对于二进制小数转十进制时，需要注意一点，小数点后面的指数幂是负数。\",\"举个例子，二进制 1010.101 转十进制的过程，如下图：\"]},\"82\":{\"h\":\"计算机是怎么存小数的？\",\"t\":[\"计算机存储小数的采用的是浮点数，名字里的「浮点」表示小数点是可以浮动的。\",\"比如 1000.101 这个二进制数，可以表示成 1.000101 x 2^3，类似于数学上的科学记数法。\",\"该方法在小数点左边只有一个数字，而且把这种整数部分没有前导 0 的数字称为规格化，比如 1.0 x 10^(-9) 是规格化的科学记数法，而 0.1 x 10^(-9) 和 10.0 x 10^(-9) 就不是了。\",\"因此，如果二进制要用到科学记数法，同时要规范化，那么不仅要保证基数为 2，还要保证小数点左侧只有 1 位，而且必须为 1。\",\"所以通常将 1000.101 这种二进制数，规格化表示成 1.000101 x 2^3，其中，最为关键的是 000101 和 3 这两个东西，它就可以包含了这个二进制小数的所有信息：\",\"000101 称为尾数，即小数点后面的数字；\",\"3 称为指数，指定了小数点在数据中的位置；\",\"现在绝大多数计算机使用的浮点数，一般采用的是 IEEE 制定的国际标准，这种标准形式如下图：\",\"这三个重要部分的意义如下：\",\"符号位：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；\",\"指数位：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，指数位的长度越长则数值的表达范围就越大；\",\"尾数位：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且尾数的长度决定了这个数的精度，因此如果要表示精度更高的小数，则就要提高尾数位的长度；\",\"用 32 位来表示的浮点数，则称为单精度浮点数，也就是我们编程语言中的 float 变量，而用 64 位来表示的浮点数，称为双精度浮点数，也就是 double 变量，它们的结构如下：\",\"可以看到：\",\"double 的尾数部分是 52 位，float 的尾数部分是 23 位，由于同时都带有一个固定隐含位（这个后面会说），所以 double 有 53 个二进制有效位，float 有 24 个二进制有效位，所以所以它们的精度在十进制中分别是 log10(2^53) 约等于 15.95 和 log10(2^24) 约等于 7.22 位，因此 double 的有效数字是 15~16 位，float 的有效数字是 7~8 位，这些有效位是包含整数部分和小数部分；\",\"double 的指数部分是 11 位，而 float 的指数位是 8 位，意味着 double 相比 float 能表示更大的数值范围；\",\"那二进制小数，是如何转换成二进制浮点数的呢？\",\"我们就以 10.625 作为例子，看看这个数字在 float 里是如何存储的。\",\"首先，我们计算出 10.625 的二进制小数为 1010.101。\",\"然后把小数点，移动到第一个有效数字后面，即将 1010.101 右移 3 位成 1.010101，右移 3 位就代表 +3，左移 3 位就是 -3。\",\"float 中的「指数位」就跟这里移动的位数有关系，把移动的位数再加上「偏移量」，float 的话偏移量是 127，相加后就是指数位的值了，即指数位这 8 位存的是 10000010（十进制 130），因此你可以认为「指数位」相当于指明了小数点在数据中的位置。\",\"1.010101 这个数的小数点右侧的数字就是 float 里的「尾数位」，由于尾数位是 23 位，则后面要补充 0，所以最终尾数位存储的数字是 01010100000000000000000。\",\"在算指数的时候，你可能会有疑问为什么要加上偏移量呢？\",\"前面也提到，指数可能是正数，也可能是负数，即指数是有符号的整数，而有符号整数的计算是比无符号整数麻烦的，所以为了减少不必要的麻烦，在实际存储指数的时候，需要把指数转换成无符号整数。\",\"float 的指数部分是 8 位，IEEE 标准规定单精度浮点的指数取值范围是 -126 ~ +127，于是为了把指数转换成无符号整数，就要加个偏移量，比如 float 的指数偏移量是 127，这样指数就不会出现负数了。\",\"比如，指数如果是 8，则实际存储的指数是 8 + 127（偏移量）= 135，即把 135 转换为二进制之后再存储，而当我们需要计算实际的十进制数的时候，再把指数减去「偏移量」即可。\",\"细心的朋友肯定发现，移动后的小数点左侧的有效位（即 1）消失了，它并没有存储到 float 里。\",\"这是因为 IEEE 标准规定，二进制浮点数的小数点左侧只能有 1 位，并且还只能是 1，既然这一位永远都是 1，那就可以不用存起来了。\",\"于是就让 23 位尾数只存储小数部分，然后在计算时会自动把这个 1 加上，这样就可以节约 1 位的空间，尾数就能多存一位小数，相应的精度就更高了一点。\",\"那么，对于我们在从 float 的二进制浮点数转换成十进制时，要考虑到这个隐含的 1，转换公式如下：\",\"举个例子，我们把下图这个 float 的数据转换成十进制，过程如下：\"]},\"83\":{\"h\":\"。\",\"t\":[\"因为有的小数无法可以用「完整」的二进制来表示，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。\",\"我们在 goland里执行 0.1 + 0.2，你会得到下面这个结果：\",\"而我们二进制只能精准表达 2 除尽的数字 1/2, 1/4, 1/8，但是对于 0.1(1/10) 和 0.2(1/5)，在二进制中都无法精准表示时，需要根据精度舍入。\"]},\"84\":{\"h\":\"HTTP\"},\"85\":{\"h\":\"HTTP基本概念\"},\"86\":{\"h\":\"HTTP是什么？\",\"t\":[\"HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。 HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（两个以上的参与者），以及相关的各种控制和错误处理方式（行为约定和规范）。 HTTP 协议是一个双向协议。 HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」\"]},\"87\":{\"h\":\"HTTP常见的状态码：\"},\"88\":{\"h\":\"HTTP常见字段有哪些：\",\"t\":[\"Host 字段\",\"客户端发送请求时，用来指定服务器的域名。\",\"Content-Length 字段\",\"服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度。\",\"HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题。\",\"Connection 字段\",\"Connection 字段最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。\",\"Content-Type 字段\",\"Content-Type 字段用于服务器回应时，告诉客户端，本次数据是什么格式。\",\"Content-Encoding 字段\",\"Content-Encoding 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式\"]},\"89\":{\"h\":\"GET与POST请求:\"},\"90\":{\"h\":\"GET与POST的区别:\",\"t\":[\"GET：从服务器获取指定的资源 GET请求的参数都是在URL，URL 规定只能支持 ASCII，浏览器会对URL的长度进行限制\",\"POST：根据请求负荷（报文body）对指定的资源做出处理\"]},\"91\":{\"h\":\"GET和POST的方法都是安全和幂等的吗？\",\"t\":[\"安全：请求方法不会破坏服务器上的资源\",\"幂等：多次执行相同的操作，结构都是相同的\",\"GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、浏览器上可被缓存的。\",\"POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存。\"]},\"92\":{\"h\":\"HTTP缓存技术\",\"t\":[\"强制缓存和协商缓存\"]},\"93\":{\"h\":\"强缓存：\",\"t\":[\"指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。\",\"强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：\",\"Cache-Control， 是一个相对时间；\",\"Expires，是一个绝对时间；\",\"Cache-Control 的优先级高于 Expires\",\"Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。具体的实现流程如下：\",\"当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；\",\"浏览器再次请求访问服务器中的该资源时，会先通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期，如果没有，则使用该缓存，否则重新请求服务器；\",\"服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control\"]},\"94\":{\"h\":\"协商缓存：\",\"t\":[\"通过服务端告知用户端是否可以使用缓E存的方式是协商缓存\",\"有两种实现方式：一种是基于时间，一种是基于一个唯一标识符\",\"Etag 的优先级更高\",\"协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。\"]},\"95\":{\"h\":\"HTTP特性：\",\"t\":[\"优点：简单，灵活和易于扩展，应用广泛，跨平台\",\"**缺点：**无状态，明文传输，不安全\",\"不安全表现在:明文传输,容易被窃听,容易被篡改,无法验证通信方身份信息容易被假的网站冒充\",\"HTTP 的安全问题，可以用 HTTPS 的方式解决\",\"「请求 - 应答」性能的关键在这两点： 性能：长连接，可以使用管道（减少整体响应时间），容易造成队头阻塞（影响性能）\"]},\"96\":{\"h\":\"HTTP的更迭\"},\"97\":{\"h\":\"1.如何避免发送HTTP请求\",\"t\":[\"通过缓存技术，把URL作为key,响应作为Value，两者间映射\",\"设置缓存时间过期之后重新请求，带上Etag头，如果一样说明资源未改变，可以使用客户端的缓存**304 Not Modified**\"]},\"98\":{\"h\":\"2.如何减少HTTP请求次数\",\"t\":[\"1.减少重定向次数\",\"将重定向的工作交给代理服务器，可以鉴赏HTTP请求次数\",\"2.合并请求\",\"合并请求的方式就是合并资源，以一个大资源的请求替换多个小资源的请求。但是如果有一个小资源改变就需要重新下载全部\",\"3.延迟发送请求\",\"按需获取，当用户有需要操作时再获取资源\"]},\"99\":{\"h\":\"3.如何减少HTTP响应的数据大小？\",\"t\":[\"无损压缩：解压之后和原来数据一模一样\",\"有损压缩：和原来数据和接近\"]},\"100\":{\"h\":\"1.HTTP的性能问题\",\"t\":[\"消息的大小变大了，页面资源变多了内容形式变多样了实时性要求变高了\",\"造成HTTP1.1的出现高延迟\",\"延迟高的问题来源：\",\"延迟难以下降，虽然现在网络的「带宽」相比以前变多了，但是延迟降到一定幅度后，就很难再下降了，说白了就是到达了延迟的下限；\",\"并发连接有限，谷歌浏览器最大并发连接数是 6 个，而且每一个连接都要经过 TCP 和 TLS 握手耗时，以及 TCP 慢启动过程给流量带来的影响；\",\"队头阻塞问题，同一连接只能在完成一个 HTTP 事务（请求和响应）后，才能处理下一个事务；\",\"HTTP 头部巨大且重复，由于 HTTP 协议是无状态的，每一个请求都得携带 HTTP 头部，特别是对于有携带 Cookie 的头部，而 Cookie 的大小通常很大；\",\"不支持服务器推送消息，因此当客户端需要获取通知时，只能通过定时器不断地拉取消息，这无疑浪费大量了带宽和服务器资源。\"]},\"101\":{\"h\":\"2.兼容HTTP1.1\",\"t\":[\"HTTP2可以兼容HTTP1.1 1.HTTP2没有在URL中引入新的协议名，仍然使用「http://」表示明文协议，用「https://」表示加密协议。 2.只在应用层做了改变，基本改变了HTTP报文的传输格式\"]},\"102\":{\"h\":\"3.头部压缩\",\"t\":[\"HTTP1.1的头部存在问题，太大了需要压缩,请求中大量字段重复需要避免重复性，字段需要改成二进制编码\",\"使用HPACK 算法：\",\"静态字典；\",\"动态字典；\",\"Huffman 编码（压缩算法）；\"]},\"103\":{\"h\":\"静态表编码\",\"t\":[\"HTTP/2 为高频出现在头部的字符串和字段建立了一张静态表 根据 RFC7541 规范，如果头部字段属于静态表范围，并且 Value 是变化，那么它的 HTTP/2 头部前 2 位固定为 01\",\"Huffman 编码的原理是将高频出现的信息用「较短」的编码表示，从而缩减字符串长度。\"]},\"104\":{\"h\":\"动态编码表\",\"t\":[\"不在静态编码表的范围内时，要自行构建动态表 使得动态表生效有一个前提：必须同一个连接上，重复传输完全相同的 HTTP 头部 字典累计越来越大，会有一个限制\",\"动态表是具有时序性的，如果首次出现的请求发生了丢包，后续的收到请求，对方就无法解码出 HPACK 头部，因为对方还没建立好动态表，因此后续的请求解码会阻塞到首次请求中丢失的数据包重传过来。\"]},\"105\":{\"h\":\"4.二进制帧\",\"t\":[\"HTTP2把报文从文本改成了二进制格式，HTTP/2 把响应报文划分成了两类帧（Frame）\",\"HEADERS（首部）和 DATA（消息负载） 是帧的类型\",\"前三个字节为帧长度，帧长度后面的一个字节为帧类型\",\"帧类型后面的一个字节是标志位，可以保存 8 个标志位，用于携带简单的控制信息 帧头的最后 4 个字节是流标识符（Stream ID），它的作用是用来标识该 Frame 属于哪个 Stream\"]},\"106\":{\"h\":\"5.并发传输\",\"t\":[\"多个 Stream 跑在一条 TCP 连接，同一个 HTTP 请求与响应是跑在同一个 Stream 中，HTTP 消息可以由多个 Frame 构成， 一个 Frame 可以由多个 TCP 报文构成。\",\"不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ），因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息，而同一 Stream 内部的帧必须是严格有序的。\",\"当 HTTP/2 实现 100 个并发 Stream 时，只需要建立一次 TCP 连接，而 HTTP/1.1 需要建立 100 个 TCP 连接，每个 TCP 连接都要经过 TCP 握手、慢启动以及 TLS 握手过程，这些都是很耗时的。\"]},\"107\":{\"h\":\"6.服务器主动推送资源\",\"t\":[\"比如，客户端通过 HTTP/1.1 请求从服务器那获取到了 HTML 文件，而 HTML 可能还需要依赖 CSS 来渲染页面，这时客户端还要再发起获取 CSS 文件的请求，需要两次消息往返 在 HTTP/2 中，客户端在访问 HTML 时，服务器可以直接主动推送 CSS 文件，减少了消息传递的次数。\"]},\"108\":{\"h\":\"1.HTTP2的问题\",\"t\":[\"HTTP2是基于TCP协议实现的\",\"队头阻塞；\",\"TCP 与 TLS 的握手时延迟；\",\"网络迁移需要重新连接；\"]},\"109\":{\"h\":\"1.队头阻塞：\",\"t\":[\"HTTP/2 多个请求是跑在一个 TCP 连接中的，那么当 TCP 丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求。\"]},\"110\":{\"h\":\"2.TCP与TLS的握手延迟\",\"t\":[\"TCP三次握手TLS四次握手\"]},\"111\":{\"h\":\"3.网络迁移需要重新连接\",\"t\":[\"一个 TCP 连接是由四元组（源 IP 地址，源端口，目标 IP 地址，目标端口）确定的，这意味着如果 IP 地址或者端口变动了，就会导致需要 TCP 与 TLS 重新握手，这不利于移动设备切换网络的场景，比如 4G 网络环境切换成 WiFi。\"]},\"112\":{\"h\":\"2.QUIC协议的特点\",\"t\":[\"它具有类似 TCP 的连接管理、拥塞窗口、流量控制的网络特性\"]},\"113\":{\"h\":\"1.无队头阻塞\",\"t\":[\"某个流中的一个数据包丢失了，即使该流的其他数据包到达了，数据也无法被 HTTP/3 读取，直到 QUIC 重传丢失的报文，数据才会交给 HTTP/3。 QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。\"]},\"114\":{\"h\":\"2.更快连接建立\",\"t\":[\"QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS 1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。\"]},\"115\":{\"h\":\"3.连接迁移\",\"t\":[\"通过连接 ID 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己\"]},\"116\":{\"h\":\"3.HTTP3协议\",\"t\":[\"HTTP3在头部压缩升级到了QPACK，静态表更大\",\"QUIC 会有两个特殊的单向流，所谓的单向流只有一端可以发送消息，双向则指两端都可以发送消息，传输 HTTP 消息时用的是双向流，这两个单向流的用法：\",\"一个叫 QPACK Encoder Stream，用于将一个字典（Key-Value）传递给对方，比如面对不属于静态表的 HTTP 请求头部，客户端可以通过这个 Stream 发送字典；\",\"一个叫 QPACK Decoder Stream，用于响应对方，告诉它刚发的字典已经更新到自己的本地动态表了，后续就可以使用这个字典来编码了。\",\"这两个特殊的单向流是用来同步双方的动态表，编码方收到解码方更新确认的通知后，才使用动态表编码 HTTP 头部\"]},\"117\":{\"h\":\"HTTPS如何优化\"},\"118\":{\"h\":\"1.分析性能损耗\",\"t\":[\"第一个环节， TLS 协议握手过程；\",\"第二个环节，握手后的对称加密报文传输。\",\"第一个环节的性能损耗更大一些\"]},\"119\":{\"h\":\"硬件优化\",\"t\":[\"HTTPS协议是计算密集型，而不是I/O密集型，应该买CUP，应该选择可以支持 AES-NI 特性的 CPU\"]},\"120\":{\"h\":\"软件优化\",\"t\":[\"软件的优化方向可以分成两种：软件升级，协议优化\",\"软件升级存在一定风险\",\"主攻协议优化： \",\"密钥算法优化：密钥交换算法尽量不要选择RSA密钥交换算法，而是选择ECDHE密钥交换算法，椭圆 x25519 曲线——不仅可以减少时间，还可以拥有前向安全性\",\"TLS升级：TLS 1.3 把 Hello 和公钥交换这两个消息合并成了一个消息，于是这样就减少到只需 1 RTT 就能完成 TLS 握手。只支持ECDHE算法\"]},\"121\":{\"h\":\"证书优化\",\"t\":[\"对于证书的优化，可以有两个方向：\",\"一个是证书传输，\",\"一个是证书验证；\",\"证书传输优化\",\"要让证书更便于传输，那必然是减少证书的大小，这样可以节约带宽，也能减少客户端的运算量。所以，对于服务器的证书应该选择椭圆曲线（ECDSA）证书，而不是 RSA 证书，因为在相同安全强度下， ECC 密钥长度比 RSA 短的多。\",\"2.证书传输优化\",\"OCSP ，名为在线证书状态协议（Online Certificate Status Protocol）来查询证书的有效性，它的工作方式是向 CA 发送查询请求，让 CA 返回证书的有效状态。\"]},\"122\":{\"h\":\"会话复用\",\"t\":[\"第一种叫 Session ID；\",\"第二种叫 Session Ticket；\",\"都不具备前向安全性\",\"Session ID：客户端和服务器首次 TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识 弊端：客户端再次e连接不一定会命中上次访问过的服务器，客户端增多，占用服务器的内存太多\",\"Session Ticket:服务端不在储存会话密钥，而是把缓存交给客户端\",\"TLS1.3:客户端会把 Ticket 和 HTTP 请求一同发送给服务端，这种方式叫 Pre-shared Key。\"]},\"123\":{\"h\":\"\",\"t\":[\"如果客户端和服务端同时支持 TCP Fast Open 功能，那么在完成首次通信过程后，后续客户端与服务端 的通信则可以绕过三次握手发送数据，这就减少了握手带来的 1 个 RTT 的时间消耗。\",\"在特定的， TCP Fast Open + TLSv1.3同时开启的情况下，并且是第二次进行通信，这样才可以跳过三次握手，直接进行TLS握手\"]},\"124\":{\"h\":\"HTTP和HTTPS的区别\"},\"125\":{\"h\":\"HTTP和HTTPS：\"},\"126\":{\"h\":\"1.HTTP和HTTPS的区别：\",\"t\":[\"安全性：HTTP是明文传输不安全，HTTPS在TCP和HTTTP网络层之间加入了SSL/TLS协议（报文可以加密传输）更安全\",\"建立连接的复杂程度上：HTTP连接简单三次握手之后就可以进行报文的传输，而HTTPS在三次握手之后还需要进行一次SSL/TLS的握手过程之后可以进行加密传输\",\"默认端口：HTTP是80，HTTPS是443\",\"HTTPS需要向CA申请数字证书，来保证服务器的身份是可信的\"]},\"127\":{\"h\":\"2.HTTPS解决了HTTP的那些问题?\",\"t\":[\"安全上:通信加密(防止信息泄露),校验机制(防止通信内容被篡改),身份验证(防止被假网站骗)\"]},\"128\":{\"h\":\"如何解决的?\",\"t\":[\"混合加密:在通信建立之前使用非对称加密,通信过程中使用对称加密\",\"对称加密和非对称加密\",\"对称加密:加密和解密使用相同的密钥,加密速度非常快,但是双方需要共享密钥容易造成密钥的丢失 非对称加密:公钥加密私钥解密,加密和解密过程慢,但是只有对应的私钥才能解密更安全\",\"摘要算法+数字签名:\",\"1.摘要算法:对内容进行哈希,计算出一个唯一的哈希值(可以保证内容不被篡改,但是如果连哈希值和内容一起被篡改,还是会造成内容的篡改) 2.数字签名:采用非对称加密算法,公钥和私钥可以双向解密 私钥加密，公钥解密。这个目的是为了保证消息不会被冒充，非对称加密的用途主要在于通过「私钥加密，公钥解密」的方式，来确认消息的身份,加密的不是内容而是哈希值\",\"数字证书:\",\"防止公钥是假的\"]},\"129\":{\"h\":\"3.HTTPS是如何建立连接的,期间交互了什么?\",\"t\":[\"SSL/TLS 协议基本流程：\",\"客户端向服务器索要并验证服务器的公钥。\",\"双方协商生产「会话秘钥」。\",\"双方采用「会话秘钥」进行加密通信。\",\"TLS四次握手:（RSA）\",\"RSA算法的缺陷：不支持向前保密\",\"首先客户端发送ClientHello(加密通信)请求\",\"（1）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。\",\"（2）客户端生产的随机数（Client Random），后面用于生成「会话秘钥」条件之一。\",\"（3）客户端支持的密码套件列表，如RSA 加密算法。\",\"服务器收到客户端请求后，向客户端发出响应 SeverHello\",\"（1）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。\",\"（2）服务器生产的随机数（Server Random），也是后面用于生产「会话秘钥」条件之一。\",\"（3）确认的密码套件列表，如 RSA 加密算法。密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法（握手时密钥交换算法和签名算法都是使用 RSA）\",\"（4）服务器的数字证书「Server Certificate」。\",\"「Server Hello Done」结束\",\"客户端收到服务器的回应之后，确认服务器的数字证书的真实性。从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息「Client Key Exchange」：\",\"（1）一个随机数（pre-master key）。该随机数会被服务器公钥加密。\",\"（2）加密通信算法改变通知「Change Cipher Spec」，表示随后的信息都将用「会话秘钥」加密通信。\",\"（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时「Encrypted Handshake Message（Finishd）把之前所有内容的发生的数据做个摘要，用来供服务端校验。\",\"服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。\",\"（1）加密通信算法改变通知「Change Cipher Spec」，Encrypted Handshake Message验证，表示随后的信息都将用「会话秘钥」加密通信。\",\"（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。\",\"TLS四次握手:（ECDHE）\",\"可以不用等最后一次握手结束就可以传输消息\",\"DH 算法分为两种实现：\",\"static DH 算法，一方的私钥是静态的，不具有前向安全性；\",\"DHE 算法，两方的密钥全部随机，现在常用的，计算性能不佳；\",\"ECDHE算法， ECC 椭圆曲线特性，可以用更少的计算量计算出公钥\",\"使用了 ECDHE，在 TLS 第四次握手前，客户端就已经发送了加密的 HTTP 数据，而对于 RSA 握手过程，必须要完成 TLS 四次握手，才能传输应用数据。\",\"首先客户端发送ClientHello(加密通信)请求\",\"（1）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。\",\"（2）客户端生产的随机数（Client Random），后面用于生成「会话秘钥」条件之一。\",\"（3）客户端支持的密码套件列表，如RSA 加密算法。\",\"服务器收到客户端请求后，向客户端发出响应 SeverHello\",\"（1）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。\",\"（2）服务器生产的随机数（Server Random）\",\"（4）确认的密码套件列表，如 RSA 加密算法。密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法\",\"密钥协商算法使用 ECDHE；\",\"签名算法使用 RSA\",\"（5）服务器的数字证书「Certificate」消息，会把证书也发给客户端，「Server Key Exchange」这个过程中 服务器生产的随机数（Server Random）作为服务端的私钥，基点 G 和私钥计算出服务端的椭圆曲线公钥。。\",\"「Server Hello Done」结束\",\"第二轮结束后共享的消息：Client Random、Server Random 、使用的椭圆曲线、椭圆曲线基点 G、服务端椭圆曲线的公钥\",\"客户端收到服务器的回应之后，确认服务器的数字证书的真实性。从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息「Client Key Exchange」：\",\"（1）一个随机数（pre-master key）作为客户端椭圆曲线的私钥。生成客户端的椭圆曲线公钥。\",\"（2）最终的会话密钥，就是用「客户端随机数 + 服务端随机数 + x（ECDHE 算法算出的共享密钥） 」三个材料生成的。\",\"（3）加密通信算法改变通知「Change Cipher Spec」，表示随后的信息都将用「会话秘钥」加密通信。\",\"（4）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时「Encrypted Handshake Message（Finishd）把之前所有内容的发生的数据做个摘要，用来供服务端校验。\",\"服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。\",\"（1）加密通信算法改变通知「Change Cipher Spec，表示随后的信息都将用「会话秘钥」加密通信。\",\"（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。\"]},\"130\":{\"h\":\"4.HTTPS的应用数据时如保证完整性的\",\"t\":[\"TLS 在实现上分为握手协议和记录协议两层：\",\"TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；\",\"TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；\",\"HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全。\",\"假基站和抓包工具\"]},\"131\":{\"h\":\"应用层的协议\"},\"132\":{\"h\":\"TCP 是有三个特点， 、 、基于 。\",\"t\":[\"RPC（Remote Procedure Call），又叫做远程过程调用。它本身并不是一个具体的协议，而是一种调用方式。\"]},\"133\":{\"h\":\"1.HTTP和RPC的区别\",\"t\":[\"1.服务发现 找到服务对应的 IP 端口的过程，其实就是服务发现。 HTTP中使用DNS服务，而RPC有专门的**中间服务**去保存服务名和IP信息\",\"2.底层连接形式 HTTP：其默认在建立底层 TCP 连接之后会一直保持这个连接（Keep Alive），之后的请求和响应都会复用这条连接。 RPC：也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个连接池\",\"3.传输的内容这个将结构体转为二进制数组的过程就叫序列化，反过来将二进制数组复原成结构体的过程叫反序列化。\",\"HTTP：使用 Json 来序列化结构体数据。 RPC：可以采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据\"]},\"134\":{\"h\":\"2.WebSocket是什么\",\"t\":[\"WebSocket：\",\"为了兼容这些使用场景。浏览器在 TCP 三次握手建立连接之后，都统一使用 HTTP 协议先进行一次通信。\",\"如果此时是普通的 HTTP 请求，那后续双方就还是老样子继续用普通 HTTP 协议进行交互，这点没啥疑问。\",\"如果这时候是想建立 WebSocket 连接，就会在 HTTP 请求里带上一些特殊的header 头，请求升级\",\"WebSocket完美继承了 TCP 协议的全双工能力，\",\"双全功：同一时间里，双方都可以主动向对方发送数据\"]},\"135\":{\"h\":\"IP协议的相关技术\"},\"136\":{\"h\":\"APR:\",\"t\":[\"在传输一个 IP 数据报的时候，确定了源 IP 地址和目标 IP 地址后，就会通过主机「路由表」确定 IP 数据包下一跳。然而，网络层的下一层是数据链路层，所以我们还要知道「下一跳」的 MAC 地址。\",\"由于主机的路由表中可以找到下一跳的 IP 地址，所以可以通过 ARP 协议，求得下一跳的 MAC 地址。\",\"那么 ARP 又是如何知道对方 MAC 地址的呢？\",\"简单地说，ARP 是借助 ARP 请求与 ARP 响应两种类型的包确定 MAC 地址的。\",\"主机会通过广播发送 ARP 请求，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。\",\"当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包里的内容，如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，那么这个设备就将自己的 MAC 地址塞入 ARP 响应包返回给主机。\",\"操作系统通常会把第一次通过 ARP 获取的 MAC 地址缓存起来，以便下次直接从缓存中找到对应 IP 地址的 MAC 地址。\",\"不过，MAC 地址的缓存是有一定期限的，超过这个期限，缓存的内容将被清除。\",\"RARP 协议你知道是什么吗？\",\"ARP 协议是已知 IP 地址求 MAC 地址，那 RARP 协议正好相反，它是已知 MAC 地址求 IP 地址。例如将打印机服务器等小型嵌入式设备接入到网络时就经常会用得到。\",\"通常这需要架设一台 RARP 服务器，在这个服务器上注册设备的 MAC 地址及其 IP 地址。然后再将这个设备接入到网络，接着：\",\"该设备会发送一条「我的 MAC 地址是XXXX，请告诉我，我的IP地址应该是什么」的请求信息。\",\"RARP 服务器接到这个消息后返回「MAC地址为 XXXX 的设备，IP地址为 XXXX」的信息给这个设备。\",\"最后，设备就根据从 RARP 服务器所收到的应答信息设置自己的 IP 地址。\"]},\"137\":{\"h\":\"DHCP:\",\"t\":[\"客户端首先发起 DHCP 发现报文（DHCP DISCOVER） 的 IP 数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是 UDP 广播通信，其使用的广播目的地址是 255.255.255.255（端口 67） 并且使用 0.0.0.0（端口 68） 作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，链路层然后将帧广播到所有的网络中设备。\",\"DHCP 服务器收到 DHCP 发现报文时，用 DHCP 提供报文（DHCP OFFER） 向客户端做出响应。该报文仍然使用 IP 广播地址 255.255.255.255，该报文信息携带服务器提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 IP 地址租用期。\",\"客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 DHCP 请求报文（DHCP REQUEST进行响应，回显配置的参数。\",\"最后，服务端用 DHCP ACK 报文对 DHCP 请求报文进行响应，应答所要求的参数。\",\"一旦客户端收到 DHCP ACK 后，交互便完成了，并且客户端能够在租用期内使用 DHCP 服务器分配的 IP 地址。\",\"如果租约的 DHCP IP 地址快期后，客户端会向服务器发送 DHCP 请求报文：\",\"服务器如果同意继续租用，则用 DHCP ACK 报文进行应答，客户端就会延长租期。\",\"服务器如果不同意继续租用，则用 DHCP NACK 报文，客户端就要停止使用租约的 IP 地址。\",\"可以发现，DHCP 交互中，全程都是使用 UDP 广播通信。\",\"用的是广播，那如果 DHCP 服务器和客户端不是在同一个局域网内，路由器又不会转发广播包，那不是每个网络都要配一个 DHCP 服务器？\",\"所以，为了解决这一问题，就出现了 DHCP 中继代理。有了 DHCP 中继代理以后，对不同网段的 IP 地址分配也可以由一个 DHCP 服务器统一进行管理。\",\"DHCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，而 DHCP 中继代理在收到这个广播包以后，再以单播的形式发给 DHCP 服务器。\",\"服务器端收到该包以后再向 DHCP 中继代理返回应答，并由 DHCP 中继代理将此包广播给 DHCP 客户端 。\",\"因此，DHCP 服务器即使不在同一个链路上也可以实现统一分配和管理IP地址。\"]},\"138\":{\"h\":\"NAT:\",\"t\":[\"把私有 IP 地址转换成公有 IP 地址。把 IP 地址 + 端口号一起进行转换。网络地址与端口转换 NAPT。\",\"有两个客户端 192.168.1.10 和 192.168.1.11 同时与服务器 183.232.231.172 进行通信，并且这两个客户端的本地端口都是 1025。\",\"此时，两个私有 IP 地址都转换 IP 地址为公有地址 120.229.175.121，但是以不同的端口号作为区分。\",\"于是，生成一个 NAPT 路由器的转换表，就可以正确地转换地址跟端口的组合，令客户端 A、B 能同时与服务器之间进行通信。\",\"由于 NAT/NAPT 都依赖于自己的转换表，因此会有以下的问题：\",\"外部无法主动与 NAT 内部服务器建立连接，因为 NAPT 转换表没有转换记录。\",\"转换表的生成与转换操作都会产生性能开销。\",\"通信过程中，如果 NAT 路由器重启了，所有的 TCP 连接都将被重置。\",\"第一种就是改用 IPv6\",\"IPv6 可用范围非常大，以至于每台设备都可以配置一个公有 IP 地址，就不搞那么多花里胡哨的地址转换了，但是 IPv6 普及速度还需要一些时间。\",\"第二种 NAT 穿透技术\",\"NAT 穿越技术拥有这样的功能，它能够让网络应用程序主动发现自己位于 NAT 设备之后，并且会主动获得 NAT 设备的公有 IP，并为自己建立端口映射条目，注意这些都是 NAT设备后的应用程序自动完成的。\",\"也就是说，在 NAT 穿透技术中，NAT设备后的应用程序处于主动地位，它已经明确地知道 NAT 设备要修改它外发的数据包，于是它主动配合 NAT 设备的操作，主动地建立好映射，这样就不像以前由 NAT 设备来建立映射了。\",\"就是客户端主动从 NAT 设备获取公有 IP 地址，然后自己建立端口映射条目，然后用这个条目对外通信，就不需要 NAT 设备来进行转换了。\"]},\"139\":{\"h\":\"ICMP:\",\"t\":[\"ICMP 全称是 Internet Control Message Protocol，也就是互联网控制报文协议。\",\"ICMP 主要的功能包括：确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。\",\"在 IP 通信中如果某个 IP 包因为某种原因未能达到目标地址，那么这个具体的原因将由 ICMP 负责通知。\",\"ICMP 大致可以分为两大类：\",\"一类是用于诊断的查询消息，也就是「查询报文类型」\",\"另一类是通知出错原因的错误消息，也就是「差错报文类型」\",\"IGMP 是因特网组管理协议，工作在主机（组播成员）和最后一跳路由之间\",\"IGMP 报文向路由器申请加入和退出组播组，默认情况下路由器是不会转发组播包到连接中的主机，除非主机通过 IGMP 加入到组播组，主机申请加入到组播组时，路由器就会记录 IGMP 路由器表，路由器后续就会转发组播包到对应的主机了。\",\"IGMP 报文采用 IP 封装，IP 头部的协议号为 2，而且 TTL 字段值通常为 1，因为 IGMP 是工作在主机与连接的路由器之间。\",\"路由器会周期性发送目的地址为 224.0.0.1（表示同一网段内所有主机和路由器） IGMP 常规查询报文。\",\"主机1 和 主机 3 收到这个查询，随后会启动「报告延迟计时器」，计时器的时间是随机的，通常是 0~10 秒，计时器超时后主机就会发送 IGMP 成员关系报告报文（源 IP 地址为自己主机的 IP 地址，目的 IP 地址为组播地址）。如果在定时器超时之前，收到同一个组内的其他主机发送的成员关系报告报文，则自己不再发送，这样可以减少网络中多余的 IGMP 报文数量。\",\"路由器收到主机的成员关系报文后，就会在 IGMP 路由表中加入该组播组，后续网络中一旦该组播地址的数据到达路由器，它会把数据包转发出去。\",\"离开组播组的情况一，网段中仍有该组播组：\",\"主机 1 要离开组 224.1.1.1，发送 IGMPv2 离组报文，报文的目的地址是 224.0.0.2（表示发向网段内的所有路由器）\",\"路由器 收到该报文后，以 1 秒为间隔连续发送 IGMP 特定组查询报文（共计发送 2 个），以便确认该网络是否还有 224.1.1.1 组的其他成员。\",\"主机 3 仍然是组 224.1.1.1 的成员，因此它立即响应这个特定组查询。路由器知道该网络中仍然存在该组播组的成员，于是继续向该网络转发 224.1.1.1 的组播数据包。\",\"离开组播组的情况二，网段中没有该组播组：\",\"主机 1 要离开组播组 224.1.1.1，发送 IGMP 离组报文。\",\"路由器收到该报文后，以 1 秒为间隔连续发送 IGMP 特定组查询报文（共计发送 2 个）。此时在该网段内，组 224.1.1.1 已经没有其他成员了，因此没有主机响应这个查询。\",\"一定时间后，路由器认为该网段中已经没有 224.1.1.1 组播组成员了，将不会再向这个网段转发该组播地址的数据包。\"]},\"140\":{\"h\":\"ping的工作原理\"},\"141\":{\"h\":\"ping的工作原理\"},\"142\":{\"h\":\"查询报文类型\",\"t\":[\"回送消息 —— 类型 0 和 8\",\"回送消息用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息，ping 命令就是利用这个消息实现的。\",\"可以向对端主机发送回送请求的消息（ICMP Echo Request Message，类型 8），也可以接收对端主机发回来的回送应答消息（ICMP Echo Reply Message，类型 0）。\",\"相比原生的 ICMP，这里多了两个字段：\",\"标识符：用以区分是哪个应用程序发 ICMP 包，比如用进程 PID 作为标识符；\",\"序号：序列号从 0 开始，每发送一次新的回送请求就会加 1， 可以用来确认网络包是否有丢失。\",\"在选项数据中，ping 还会存放发送请求的时间值，来计算往返时间，说明路程的长短\",\"ping 命令执行的时候，源主机首先会构建一个 ICMP 回送请求消息数据包。\",\"ICMP 数据包内包含多个字段，最重要的是两个：\",\"第一个是类型，对于回送请求消息而言该字段为 8；\",\"另外一个是序号，主要用于区分连续 ping 的时候发出的多个数据包\",\"目标主机 会构建一个 ICMP 回送响应消息数据包，回送响应数据包的类型字段为 0，序号为接收到的请求数据包中的序号，然后再发送出去给源主机\",\"在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 回送响应消息，则说明目标主机可达。\",\"此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。\"]},\"143\":{\"h\":\"traceroute :\",\"t\":[\"1. traceroute 作用一\",\"traceroute 的第一个作用就是故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。\",\"它的原理就是利用 IP 包的生存期限 从 1 开始按照顺序递增的同时发送 UDP 包，强制接收 ICMP 超时消息的一种方法。\",\"比如，将 TTL 设置 为 1，则遇到第一个路由器，就牺牲了，接着返回 ICMP 差错报文网络包，类型是时间超时。\",\"接下来将 TTL 设置为 2，第一个路由器过了，遇到第二个路由器也牺牲了，也同时返回了 ICMP 差错报文数据包，如此往复，直到到达目的主机。\",\"这样的过程，traceroute 就可以拿到了所有的路由器 IP。\",\"当然有的路由器根本就不会返回这个 ICMP，所以对于有的公网地址，是看不到中间经过的路由的。\",\"发送方如何知道发出的 UDP 包是否到达了目的主机呢？\",\"traceroute 在发送 UDP 包时，会填入一个不可能的端口号值作为 UDP 目标端口号：33434。然后对于每个下一个探针，它都会增加一个，这些端口都是通常认为不会被使用，不过，没有人知道当某些应用程序监听此类端口时会发生什么。\",\"当目的主机，收到 UDP 包后，会返回 ICMP 差错报文消息，但这个差错报文消息的类型是「端口不可达」。\",\"所以，当差错报文类型是端口不可达时，说明发送方发出的 UDP 包到达了目的主机。\",\"2. traceroute 作用二\",\"traceroute 还有一个作用是故意设置不分片，从而确定路径的 MTU。\",\"这样做的目的是为了路径MTU发现。\",\"因为有的时候我们并不知道路由器的 MTU 大小，以太网的数据链路上的 MTU 通常是 1500 字节，但是非以太网的 MTU 值就不一样了，所以我们要知道 MTU 的大小，从而控制发送的包大小。\",\"它的工作原理如下：\",\"首先在发送端主机发送 IP 数据报时，将 IP 包首部的分片禁止标志位设置为 1。根据这个标志位，途中的路由器不会对大数据包进行分片，而是将包丢弃。\",\"随后，通过一个 ICMP 的不可达消息将数据链路上 MTU 的值一起给发送主机，不可达消息的类型为「需要进行分片但设置了不分片位」。\",\"发送主机端每次收到 ICMP 差错报文时就减少包的大小，以此来定位一个合适的 MTU 值，以便能到达目标主机。\"]},\"144\":{\"h\":\"断网了还能ping通127.0.0.1吗？\"},\"145\":{\"h\":\"什么是127.0.0.1\",\"t\":[\"首先，这是个 IPV4 地址。\",\"IPV4 地址有 32 位，一个字节有 8 位，共 4 个字节。\",\"其中127 开头的都属于回环地址，也是 IPV4 的特殊地址，没什么道理，就是人为规定的。\",\"ping 作为一个小软件，它的功能比较简单，就是尝试发送一个小小的消息到目标机器上，判断目的机器是否可达，其实也就是判断目标机器网络是否能连通。\"]},\"146\":{\"h\":\"TCP和Ping数据的区别：\",\"t\":[\"在 TCP 传输中创建的方式是 socket(AF_INET, SOCK_STREAM, 0);，其中 AF_INET 表示将使用 IPV4 里 host:port 的方式去解析待会你输入的网络地址。SOCK_STREAM 是指使用面向字节流的 TCP 协议，工作在传输层。\",\"创建好了 socket 之后，就可以愉快的把要传输的数据写到这个文件里。调用 socket 的sendto接口的过程中进程会从用户态进入到内核态，最后会调用到 sock_sendmsg 方法。\",\"然后进入传输层，带上TCP头。网络层带上IP头，数据链路层带上 MAC头等一系列操作后。进入网卡的发送队列 ring buffer ，顺着网卡就发出去了。\",\"回到 ping ，创建 socket 的时候用的是 socket(AF_INET,SOCK_RAW,IPPROTO_ICMP)，SOCK_RAW 是原始套接字 ，工作在网络层，ping 在进入内核态后最后也是调用的 sock_sendmsg 方法，进入到网络层后加上ICMP和IP头后，数据链路层加上MAC头，也是顺着网卡发出。\"]},\"147\":{\"h\":\"为什么断网了还能ping通127.0.0.1？\",\"t\":[\"当发现目标IP是回环地址时，就会选择本地网卡。\",\"本地网卡会把数据推到一个叫 input_pkt_queue 的 **链表**中。这个链表，其实是所有网卡共享的，上面挂着发给本机的各种消息。消息被发送到这个链表后，会再触发一个软中断。\",\"专门处理软中断\\\"ksoftirqd\\\"（这是个内核线程），它在收到软中断后就会立马去链表里把消息取出，然后顺着数据链路层、网络层等层层往上传递最后给到应用程序。\",\"根本就没有出网络，而是在本机打了一个转又回去了\",\"ping回环地址和ping本机地址没有什么区别\"]},\"148\":{\"h\":\"127.0.0.1和localhost和0.0.00有什么区别？\",\"t\":[\"127.0.0.1是一个回环地址，localhost是一个域名默认等于127.0.0.1\",\"其次就是 0.0.0.0，执行 ping 0.0.0.0 ，是会失败的，因为它在IPV4中表示的是无效的目标地址。\",\"$ ping 0.0.0.0 PING 0.0.0.0 (0.0.0.0): 56 data bytes ping: sendto: No route to host ping: sendto: No route to host\",\"我们启动服务器的时候，一般会 listen 一个 IP 和端口，等待客户端的连接。\",\"如果此时 listen 的是本机的 0.0.0.0 , 那么它表示本机上的所有IPV4地址。\"]},\"149\":{\"h\":\"基础IP\"},\"150\":{\"h\":\"IP基本认识\",\"t\":[\"IP 在 TCP/IP 参考模型中处于第三层，也就是网络层。\",\"网络层的主要作用是：实现主机与主机之间的通信，也叫点对点（end to end）通信。\",\"网络层和数据链路层有什么关系？\",\"MAC 的作用则是实现「直连」的两个设备之间通信，而 IP 则负责在「没有直连」的两个网络之间进行通信传输。\",\"源IP地址和目标IP地址在传输过程中是不会变化的（前提：没有使用 NAT 网络），只有源 MAC 地址和目标 MAC 一直在变化\"]},\"151\":{\"h\":\"IP的基础知识\",\"t\":[\"在 TCP/IP 网络通信时，为了保证能正常通信，每个设备都需要配置正确的 IP 地址，否则无法实现正常的通信。\",\"IP 地址（IPv4 地址）由 32 位正整数来表示，IP 地址在计算机是以二进制的方式处理的。\",\"而人类为了方便记忆采用了点分十进制的标记方式，也就是将 32 位 IP 地址以每 8 位为组，共分为 4 组，每组以「.」隔开，再将每组转换成十进制。\"]},\"152\":{\"h\":\"IP的分类：\",\"t\":[\"上图中黄色部分为分类号，用以区分 IP 地址类别。\"]},\"153\":{\"h\":\"什么是A，B，C类？\",\"t\":[\"其中对于 A、B、C 类主要分为两个部分，分别是网络号和主机号。\",\"因为在 IP 地址中，有两个 IP 是特殊的，分别是主机号全为 1 和 全为 0 地址。\",\"主机号全为 1 指定某个网络下的所有主机，用于广播\",\"主机号全为 0 指定某个网络\",\"广播地址：同一个链路中相互连接的主机之间发送数据包。\",\"在本网络内广播的叫做本地广播。例如网络地址为 192.168.0.0/24 的情况下，广播地址是 192.168.0.255 。因为这个广播地址的 IP 包会被路由器屏蔽，所以不会到达 192.168.0.0/24 以外的其他链路上。\",\"在不同网络之间的广播叫做直接广播。例如网络地址为 192.168.0.0/24 的主机向 192.168.1.255/24 的目标地址发送 IP 包。收到这个包的路由器，将数据转发给 192.168.1.0/24，从而使得所有 192.168.1.1~192.168.1.254 的主机都能收到这个包（由于直接广播有一定的安全问题，多数情况下会在路由器上设置为不转发。） 。\"]},\"154\":{\"h\":\"什么是D类，E类？\",\"t\":[\"而 D 类和 E 类地址是没有主机号的，所以不可用于主机 IP，D 类常被用于多播，E 类是预留的分类，暂时未使用。\",\"多播：用于将包发送给特定组内的所有主机。\"]},\"155\":{\"h\":\"无分类地址CIDR\",\"t\":[\"32 比特的 IP 地址被划分为两部分，前面是网络号，后面是主机号。\",\"表示形式 a.b.c.d/x，其中 /x 表示前 x 位属于网络号， x 的范围是 0 ~ 32，这就使得 IP 地址更加具有灵活性。\",\"子网掩码，掩码的意思就是掩盖掉主机号，剩余的就是网络号。\",\"将子网掩码和 IP 地址按位计算 AND，就可得到网络号。\",\"分离网络号和主机号：因为两台计算机要通讯，首先要判断是否处于同一个广播域内，即网络地址是否相同。如果网络地址相同，表明接受方在本网络上，那么可以把数据包直接发送到目标主机。\",\"进行子网划分：子网划分实际上是将主机地址分为两个部分：子网网络地址和子网主机地址。\",\"未做子网划分的 ip 地址：网络地址＋主机地址\",\"做子网划分后的 ip 地址：网络地址＋（子网网络地址＋子网主机地址）\"]},\"156\":{\"h\":\"公有 IP 地址与私有 IP 地址\",\"t\":[\"就像每个小区都有自己的楼编号和门牌号，你小区家可以叫 1 栋 101 号，我小区家也可以叫 1 栋 101，没有任何问题。但一旦出了小区，就需要带上中山路 666 号（公网 IP 地址），是国家统一分配的，不能两个小区都叫中山路 666。\",\"所以，公有 IP 地址是有个组织统一分配的，假设你要开一个博客网站，那么你就需要去申请购买一个公有 IP，这样全世界的人才能访问。并且公有 IP 地址基本上要在整个互联网范围内保持唯一。\",\"公有IP：私有 IP 地址通常是内部的 IT 人员管理，公有 IP 地址是由 ICANN 组织管理，中文叫「互联网名称与数字地址分配机构」。\"]},\"157\":{\"h\":\"IP 地址与路由控制\",\"t\":[\"IP地址的网络地址这一部分是用于进行路由控制。\",\"路由控制表中记录着网络地址与下一步应该发送至路由器的地址。在主机和路由器上都会有各自的路由器控制表。\",\"在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择相同位数最多的网络地址，也就是最长匹配。\",\"环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址。\",\"计算机使用一个特殊的 IP 地址 127.0.0.1 作为环回地址。与该地址具有相同意义的是一个叫做 localhost 的主机名。使用这个 IP 或主机名时，数据包不会流向网络\"]},\"158\":{\"h\":\"IP分片与重组\",\"t\":[\"每种数据链路的最大传输单元 MTU 都是不相同的，如 FDDI 数据链路 MTU 4352、以太网的 MTU 是 1500 字节等。\",\"每种数据链路的 MTU 之所以不同，是因为每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的 MTU 也就不同。\",\"其中，我们最常见数据链路是以太网，它的 MTU 是 1500 字节。\",\"那么当 IP 数据包大小大于 MTU 时， IP 数据包就会被分片。\",\"经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行，路由器是不会进行重组的。\",\"假设发送方发送一个 4000 字节的大数据报，若要传输在以太网链路，则需要把数据报分片成 3 个小数据报进行传输，再交由接收方重组成大数据报。\",\"在分片传输中，一旦某个分片丢失，则会造成整个 IP 数据报作废，TCP确实通过TCP选项中的最大报文段长度（MSS）来控制数据包的大小，以避免IP层的分片。TCP的MSS是指TCP报文段中数据字段的最大长度，它考虑了底层网络链路的MTU，并在发送数据时将数据分成适当大小的段，以确保不会在传输过程中发生IP层的分片。这样做的好处是可以减少IP层分片带来的性能损耗和数据报文丢失的风险。那么对于 UDP 我们尽量不要发送一个大于 MTU 的数据报文。\"]},\"159\":{\"h\":\"IPv6 基本认识\",\"t\":[\"但是 IPv6 的地址是 128 位的，这可分配的地址数量是大的惊人，说个段子 IPv6 可以保证地球上的每粒沙子都能被分配到一个 IP 地址。\",\"但是因为 IPv4 和 IPv6 不能相互兼容，所以不但要我们电脑、手机之类的设备支持，还需要网络运营商对现有的设备进行升级，所以这可能是 IPv6 普及率比较慢的一个原因。\",\"IPv6 可自动配置，即使没有 DHCP 服务器也可以实现自动分配IP地址，真是便捷到即插即用啊。\",\"IPv6 包头包首部长度采用固定的值 40 字节，去掉了包头校验和，简化了首部结构，减轻了路由器负荷，大大提高了传输的性能。\",\"IPv6 有应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能，大大提升了安全性。\",\"IPv6 地址长度是 128 位，是以每 16 位作为一组，每组用冒号 「:」 隔开。\",\"如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号 「::」隔开。但是，一个 IP 地址中只允许出现一次两个连续的冒号。\",\"单播地址，用于一对一的通信\",\"在同一链路单播通信，不经过路由器，可以使用链路本地单播地址，IPv4 没有此类型\",\"在内网里单播通信，可以使用唯一本地地址，相当于 IPv4 的私有 IP\",\"在互联网通信，可以使用全局单播地址，相当于 IPv4 的公有 IP\",\"组播地址，用于一对多的通信\",\"任播地址，用于通信最近的节点，最近的节点是由路由协议决定\",\"没有广播地址\"]},\"160\":{\"h\":\"IPv6的首部改进：\",\"t\":[\"取消了首部校验和字段。 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。\",\"取消了分片/重新组装相关字段。 分片与重组是耗时的过程，IPv6 不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。\",\"取消选项字段。 选项字段不再是标准 IP 首部的一部分了，但它并没有消失，而是可能出现在 IPv6 首部中的「下一个首部」指出的位置上。删除该选项字段使的 IPv6 的首部成为固定长度的 40 字节\"]},\"161\":{\"h\":\"CLOSE_WAIT和TIME_WAIT\"},\"162\":{\"h\":\"为什么 TIME_WAIT 等待的时间是 2MSL？\",\"t\":[\"MSL时报文的最大生存时间，超过这个时间就会丢弃这个报文\",\"IP头中有一个有一个TTL字段，是IP数据报文可以跳跃的最大路由数，每经过一个路由就会减一，直到为0\",\"所以 MSL 应该要大于等于 TTL 消耗为 0 的时间，以确保报文已被自然消亡。\",\"TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了。\",\"2MSL时长 这其实是相当于至少允许报文丢失一次。从客户端接收到 FIN 后发送 ACK 开始计时的。\"]},\"163\":{\"h\":\"为什么需要 TIME_WAIT 状态？\",\"t\":[\"防止历史连接中的数据，被后面相同四元组的连接错误的接收：\",\"2MSL足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。\",\"保证「被动关闭连接」的一方，能被正确的关闭：\",\"等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。\",\"序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据。\",\"2MSL足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。\"]},\"164\":{\"h\":\"TIME_WAIT 过多有什么危害？\",\"t\":[\"如果客户端（主动发起关闭连接方）的 TIME_WAIT 状态过多，占满了所有端口资源，那么就无法对「目的 IP+ 目的 PORT」都一样的服务端发起连接了\",\"如果服务端（主动发起关闭连接方）的 TIME_WAIT 状态过多，TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等\"]},\"165\":{\"h\":\"如何优化 TIME_WAIT？\",\"t\":[\"如果服务端要避免过多的 TIME_WAIT 状态的连接，就永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT\"]},\"166\":{\"h\":\"服务器出现大量 TIME_WAIT 状态的原因有哪些？\",\"t\":[\"服务器主动断开了很多TCP连接\",\"什么场景下服务端会主动断开连接呢？\",\"第一个场景：HTTP 没有使用长连接\",\"使用的是短链接，过程就是 建立 TCP -> 请求资源 -> 响应资源 -> 释放连接\",\"根据大多数 Web 服务的实现，不管哪一方禁用了 HTTP Keep-Alive，都是由服务端主动关闭连接\",\"客户端禁用了 HTTP Keep-Alive，服务端开启 HTTP Keep-Alive，谁是主动关闭方？\",\"HTTP Keep-Alive的设计初衷就是为用户的后续请求重用连接，当用户端禁用时，服务端在响应完就关闭连接，灰常合理\",\"客户端开启了 HTTP Keep-Alive，服务端关闭 HTTP Keep-Alive，谁是主动关闭方？\",\"这时服务端在发完 HTTP 响应后，服务端也会主动关闭连接\",\"第二个场景：HTTP 长连接超时\",\"如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，定时器的时间一到，nginx 就会触发回调函数来关闭该连接，那么此时服务端上就会出现 TIME_WAIT 状态的连接。\",\"第三个场景：HTTP 长连接的请求数量达到上限\",\"Web 服务端通常会有个参数，来定义一条 HTTP 长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接。\"]},\"167\":{\"h\":\"服务器出现大量 CLOSE_WAIT 状态的原因有哪些？\",\"t\":[\"当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接。\",\"一个普通的 TCP 服务端的流程：\",\"创建服务端 socket，bind 绑定端口、listen 监听端口\",\"将服务端 socket 注册到 epoll\",\"epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket\",\"将已连接的 socket 注册到 epoll\",\"epoll_wait 等待事件发生\",\"对方连接关闭时，我方调用 close\",\"当服务端出现大量 CLOSE_WAIT 状态的连接的时候，通常都是代码的问题，这时候我们需要针对具体的代码一步一步的进行排查和定位，主要分析的方向就是服务端为什么没有调用 close。\"]},\"168\":{\"h\":\"SYN延时和泛洪攻击\"},\"169\":{\"h\":\"什么是SYN攻击，如何避免SYN攻击？\",\"t\":[\"​ 攻击者在短时内向服务端发送大量的SYN报文，将服务端的半连接队列占满，使得服务器不能为正常用户服务\",\"半连接队列（SYN队列）：收到SYN报文时，就会创建一个半连接对象，内核会把该链接放到SYN队列 全连接队列（Accept队列）：收到客户端的ACK报文时，内核从SYN队列取出一条半连接队列，创建一个全连接队列，然后添加到accept队列\",\"当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃\",\"1.调大 netdev_max_backlog\",\"当网卡接收数据包的速度大于内核处理的速度时，会有一个队列用于保存这些数据包。我们可以调大这个队列的最大值\",\"2.增大 TCP 半连接队列\",\"增大三个参数：net.ipv4.tcp_max_syn_backlog， listen() 函数中的 backlog， net.core.somaxconn\",\"3.开启 net.ipv4.tcp_syncookies\",\"当半连接队列满了的时候，将接受的SYN报文，计算出一个cookie，然后将这个cookie值返回给客户端，当服务端接收到ACK时，会判断ACK包的合法性，如果合法就创建一个全连接队列\",\"4.减少 SYN+ACK 重传次数\",\"TCP 会重传 SYN+ACK ，当重传超过次数达到上限后，就会断开连接。我们可以减少重传的上限\",\"5.防火墙设置\",\"有时防火墙或者网络设备的设置会导致TCP连接建立失败。检查防火墙设置，确保允许了TCP连接建立所需要的端口和协议。\"]},\"170\":{\"h\":\"什么时SYN超时，如何解决SYN超时？\",\"t\":[\"SYN超时(SYN TIMEOUT)：在TCP连接的建立阶段，客户端会发送一个SYN（同步）报文段到服务器，服务器接收到后会回复一个SYN-ACK（同步-确认）报文段，最后客户端再发送一个ACK（确认）报文段确认连接建立。如果在某个阶段出现超时，可能会导致连接建立失败。SYN超时可能会由于网络延迟，拥塞或网络故障等原因引起。\",\"1.增加SYN超时时间：调整服务器的SYN超时时间，使其能够容忍更长的等待时间\",\"2.优化网络连接：检查网络设备，链路和路由器等，确保网络的稳定性和低延迟\",\"3.加强服务器性能：提升服务器的资源和处理能力，以应对更多的连接请求\"]},\"171\":{\"h\":\"TCP和UDP的区别\"},\"172\":{\"h\":\"UDP和TCP的区别和应用场景：\"},\"173\":{\"h\":\"TCP和UDP的区别：\"},\"174\":{\"h\":\"连接：\",\"t\":[\"TCP面向连接的传输层协议，需要在传输之前建立连接\",\"UDP不需要连接，即刻传数据\",\"2. 服务对象\",\"TCP 是一对一的两点服务，即一条连接只有两个端点。\",\"UDP 支持一对一、一对多、多对多的交互通信\",\"3. 可靠性\",\"TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。\",\"UDP 是尽最大努力交付，不保证可靠交付数据\",\"4. 拥塞控制、流量控制\",\"TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。\",\"UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。\",\"5. 首部开销\",\"TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。\",\"UDP 首部只有 8 个字节，并且是固定不变的，开销较小。\",\"6. 传输方式\",\"TCP 是流式传输，没有边界，但保证顺序和可靠。\",\"UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。\",\"7. 分片不同\",\"TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。\",\"UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。\"]},\"175\":{\"h\":\"TCP的socket编程\"},\"176\":{\"h\":\"针对TCP应该如何socket编程？\",\"t\":[\"服务端创建一个监听socket和客户端初始化用来通信的 socket，得到文件描述符；\",\"服务端调用 bind，将 socket 绑定在指定的 IP 地址和端口;\",\"服务端调用 listen，进行监听；\",\"服务端调用 accept，等待客户端连接；\",\"客户端调用 connect，向服务端的地址和端口发起连接请求；\",\"服务端 accept 返回一个新创建的用于传输的 socket（已完成的） 的文件描述符；\",\"客户端调用 write 写入数据；服务端调用 read 读取数据；\",\"客户端断开连接时，会调用 close，那么服务端 read 读取数据的时候，就会读取到了 EOF，待处理完数据后，服务端调用 close，表示连接关闭。\",\"监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作监听 socket，一个叫作已完成连接 socket。\"]},\"177\":{\"h\":\"listen 时候参数 backlog 的意义？\",\"t\":[\"半连接队列（SYN 队列）：接收到一个 SYN 建立连接请求，处于 SYN_RCVD 状态；\",\"全连接队列（Accpet 队列）：已完成 TCP 三次握手过程，处于 ESTABLISHED 状态；\",\"所以现在通常认为 backlog 是 accept 队列。\",\"但是上限值是内核参数 somaxconn 的大小，也就说 accpet 队列长度 = min(backlog, somaxconn)。\"]},\"178\":{\"h\":\"accept 发生在三次握手的哪一步？\",\"t\":[\"客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后\"]},\"179\":{\"h\":\"客户端调用 close 了，连接是断开的流程是什么？\",\"t\":[\"客户端调用 close，表明客户端没有数据需要发送了，则此时会向服务端发送 FIN 报文，进入 FIN_WAIT_1 状态；\",\"服务端接收到了 FIN 报文，TCP 协议栈会为 FIN 包插入一个文件结束符 EOF 到接收缓冲区中，应用程序可以通过 read 调用来感知这个 FIN 包。这个 EOF 会被放在已排队等候的其他已接收的数据之后，这就意味着服务端需要处理这种异常情况，因为 EOF 表示在该连接上再无额外数据到达。此时，服务端进入 CLOSE_WAIT 状态；\",\"接着，当处理完数据后，自然就会读到 EOF，于是也调用 close 关闭它的套接字，这会使得服务端发出一个 FIN 包，之后处于 LAST_ACK 状态；\"]},\"180\":{\"h\":\"服务端没有调用Listen,客户端请求建立连接会发生什么？\",\"t\":[\"服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，然后客户端对服务端发起了连接建立，服务端会回 RST 报文\"]},\"181\":{\"h\":\"没有listen可以建立TCP连接吗？\",\"t\":[\"是可以的，客户端是可以自己连自己的形成连接（TCP自连接），也可以两个客户端同时向对方发出请求建立连接（TCP同时打开），这两个情况都有个共同点，就是没有服务端参与，也就是没有listen，就能建立连接。\",\"因为客户端没有执行listen，因为半连接队列和全连接队列都是在执行 listen 方法时，内核自动创建的。\",\"但内核还有个全局 hash 表，可以用于存放 sock 连接的信息。\",\"这个全局 hash 表其实还细分为 ehash，bhash和listen_hash等，但因为过于细节，大家理解成有一个全局 hash 就够了，\",\"在 TCP 自连接的情况中，客户端在 connect 方法时，最后会将自己的连接信息放入到这个全局 hash 表中，然后将信息发出，消息在经过回环地址重新回到 TCP 传输层的时候，就会根据 IP + 端口信息，再一次从这个全局 hash 中取出信息。于是握手包一来一回，最后成功建立连接。\"]},\"182\":{\"h\":\"没有Accpet，能建立TCP连接吗？\",\"t\":[\"建立连接的过程中根本不需要accept()参与， 执行accept()只是为了从全连接队列里取出一条连接。\"]},\"183\":{\"h\":\"为什么半连接队列要设计成哈希表？\",\"t\":[\"全连接里队列，他本质是个链表，因为也是线性结构，说它是个队列也没毛病。它里面放的都是已经建立完成的连接，这些连接正等待被取走。而服务端取走连接的过程中，并不关心具体是哪个连接，只要是个连接就行，所以直接从队列头取就行了。这个过程算法复杂度为O(1)。\",\"而半连接队列却不太一样，因为队列里的都是不完整的连接，嗷嗷等待着第三次握手的到来。那么现在有一个第三次握手来了，则需要从队列里把相应IP端口的连接取出，如果半连接队列还是个链表，那我们就需要依次遍历，才能拿到我们想要的那个连接，算法复杂度就是O(n)。\",\"而如果将半连接队列设计成哈希表，那么查找半连接的算法复杂度就回到O(1)了。\",\"因此出于效率考虑，全连接队列被设计成链表，而半连接队列被设计为哈希表。\"]},\"184\":{\"h\":\"会有一个cookies队列吗\",\"t\":[\"实际上cookies并不会有一个专门的队列保存，它是通过通信双方的IP地址端口、时间戳、MSS等信息进行实时计算的，保存在TCP报头的seq里。\"]},\"185\":{\"h\":\"cookies方案为什么不直接取代半连接队列？\",\"t\":[\"凡事皆有利弊，cookies方案虽然能防 SYN Flood攻击，但是也有一些问题。因为服务端并不会保存连接信息，所以如果传输过程中数据包丢了，也不会重发第二次握手的信息。\",\"另外，编码解码cookies，都是比较耗CPU的，利用这一点，如果此时攻击者构造大量的第三次握手包（ACK包），同时带上各种瞎编的cookies信息，服务端收到ACK包后以为是正经cookies，憨憨地跑去解码（耗CPU），最后发现不是正经数据包后才丢弃。\",\"这种通过构造大量ACK包去消耗服务端资源的攻击，叫ACK攻击，受到攻击的服务器可能会因为CPU资源耗尽导致没能响应正经请求。\"]},\"186\":{\"h\":\"TCP和UDP可以同时绑定相同的端口吗？\"},\"187\":{\"h\":\"1.TCP和UDP可以同时绑定相同的端口吗？\",\"t\":[\"可以\",\"在数据链路层中，通过 MAC 地址来寻找局域网中的主机。在网际层中，通过 IP 地址来寻找网络中互连的主机或路由器。在传输层中，需要通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序。\",\"TCP和UDP在内核中是两个完全独立的软件模块：当主机接收到一个数据包，跟据数据包的头部，确定是TCP还是UDP然后交给对应的模块，然后模块处理之后跟据端口号发送给对应的应用程序\"]},\"188\":{\"h\":\"2.\",\"t\":[\"如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”。\",\"但是如果ip不同端口相同的话就可以绑定\",\"但是如果 TCP 绑定的地址是 0.0.0.0 和端口 8888，而如果 另一个TCP 绑定的地址是其他地址和端口 8888，那么执行 bind() 时候也会出错。（这是因为 0.0.0.0 地址比较特殊，代表任意地址，意味着绑定了 0.0.0.0 地址，相当于把主机上的所有 IP 地址都绑定了。）\",\"这个问题也可以由 SO_REUSEADDR 解决，因为它的另外一个作用：绑定的 IP地址 + 端口时，只要 IP 地址不是正好(exactly)相同，那么允许绑定。\"]},\"189\":{\"h\":\"\",\"t\":[\"当 TCP 服务进程重启时，服务端会出现 TIME_WAIT 状态的连接，TIME_WAIT 状态的连接使用的 IP+PORT 仍然被认为是一个有效的 IP+PORT 组合，相同机器上不能够在该 IP+PORT 组合上进行绑定，那么执行 bind() 函数的时候，就会返回了 Address already in use 的错误。\",\"等TIME_WAIT结束之后就可以，重启TCP服务\"]},\"190\":{\"h\":\"4.重启 TCP 服务进程时，如何避免“Address in use”的报错信息？\",\"t\":[\"因为 SO_REUSEADDR 作用是：如果当前启动进程绑定的 IP+PORT 与处于TIME_WAIT 状态的连接占用的 IP+PORT 存在冲突，但是新启动的进程使用了 SO_REUSEADDR 选项，那么该进程就可以绑定成功\"]},\"191\":{\"h\":\"\",\"t\":[\"CP 连接是由四元组（源IP地址，源端口，目的IP地址，目的端口）唯一确认的，那么只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP 连接的。所以如果客户端已使用端口 64992 与服务端 A 建立了连接，那么客户端要与服务端 B 建立连接，还是可以使用端口 64992 的，因为内核是通过四元祖信息来定位一个 TCP 连接的，并不会因为客户端的端口号相同，而导致连接冲突的问题。\"]},\"192\":{\"h\":\"\",\"t\":[\"要看多个客户端绑定的 IP + PORT 是否都相同，如果都是相同的，那么在执行 bind() 时候就会出错，错误是“Address already in use”。\",\"一般而言，客户端不建议使用 bind 函数，应该交由 connect 函数来选择端口会比较好，因为客户端的端口通常都没什么意义。\"]},\"193\":{\"h\":\"7.客户端 TCP 连接 TIME_WAIT 状态过多，会导致端口资源耗尽而无法建立新的连接吗？\",\"t\":[\"针对这个问题，也是有解决办法的，那就是打开 net.ipv4.tcp_tw_reuse 这个内核参数。\",\"因为开启了这个内核参数后，客户端调用 connect 函数时，如果选择到的端口，已经被相同四元组的连接占用的时候，就会判断该连接是否处于 TIME_WAIT 状态，如果该连接处于 TIME_WAIT 状态并且 TIME_WAIT 状态持续的时间超过了 1 秒，那么就会重用这个连接，然后就可以正常使用该端口了。\",\"开启了 net.ipv4.tcp_tw_reuse 内核参数，是客户端（连接发起方） 在调用 connect() 函数时才起作用，所以在服务端开启这个参数是没有效果的。\"]},\"194\":{\"h\":\"TCP的优化\"},\"195\":{\"h\":\"如何优化TCP？\"},\"196\":{\"h\":\"TCP三次握手的性能提升？\",\"t\":[\"客户端优化：\",\"SYN_SENT优化，跟据服务器的繁忙程度修改SNY重传次数\",\"服务端优化：\",\"SYN_RCV状态的优化,同样是修改重发次数 调整半连接队列的大小\",\"如何绕过三次握手：\",\"TCP_FAST_OPEN功能，第一次建立握手时还是三次链接，之后建立连接就不需要握手了 需要双方同时打开才能有效\"]},\"197\":{\"h\":\"TCP四次挥手性能的提升？\",\"t\":[\"主动方的优化：\",\"CLOSE函数和SHUTDOWN函数的区别：\",\"close函数是直接完全断开连接，双方都不能发送或者接受消息， 此时，调用了 close 函数的一方的连接叫做「孤儿连接」\",\"shutdown函数是优雅的可以控制只关闭一个方向的连接\",\"SHUT_RD(0)：关闭连接的「读」这个方向，如果接收缓冲区有已接收的数据，则将会被丢弃，并且后续再收到新的数据，会对数据进行 ACK，然后悄悄地丢弃。也就是说，对端还是会接收到 ACK，在这种情况下根本不知道数据已经被丢弃了。\",\"SHUT_WR(1)：关闭连接的「写」这个方向，这就是常被称为「半关闭」的连接。如果发送缓冲区还有未发送的数据，将被立即发送出去，并发送一个 FIN 报文给对端。\",\"SHUT_RDWR(2)：相当于 SHUT_RD 和 SHUT_WR 操作各一次，关闭套接字的读和写两个方向。\",\"被动方的优化：\",\"如果双方同时关闭连接会出现什么？\",\"双方在等待 ACK 报文的过程中，都等来了 FIN 报文。这是一种新情况，所以连接会进入一种叫做 CLOSING 的新状态，它替代了 FIN_WAIT2 状态\"]},\"198\":{\"h\":\"TCP传输数据的性能提升？\",\"t\":[\"TCP 连接是由内核维护的，内核会为每个连接建立内存缓冲区：\",\"如果连接的内存配置过小，就无法充分使用网络带宽，TCP 传输效率就会降低；\",\"如果连接的内存配置过大，很容易把服务器资源耗尽，这样就会导致新连接无法建立；\",\"滑动窗口是如何影像传输速度的？ TCP报文发出去之后不会从内存中立马删除，因为重传的时候还需要用到\",\"这样看来，只要进程能及时地调用 read 函数读取数据，并且接收缓冲区配置得足够大，那么接收窗口就可以无限地放大，发送方也就无限地提升发送速度。\",\"这是不能可能的，因为网络的传输能力是有限的，当发送方依据发送窗口，发送超过网络处理能力的报文时，路由器会直接丢弃这些报文。因此，缓冲区的内存并不是越大越好。\",\"如何确定最大传输速度？\"]},\"199\":{\"h\":\"TCP的基本认识\"},\"200\":{\"h\":\"TCP基本认识\"},\"201\":{\"h\":\"TCP的头格式：\",\"t\":[\"序列号：在建立连接时由计算机生成的随机数作为其初始值，每发送一次数据，就累加一次。用来解决网络包乱序问题。\",\"确认应答号：指下一次「期望」收到的数据的序列号，发送端接收到确认答应之后，可以认定之前的数据全部被接收。用来解决丢包问题\",\"ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。\",\"RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。\",\"SYN：该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。\",\"FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。\"]},\"202\":{\"h\":\"TCP工作在那一层：\",\"t\":[\"TCP 是一个工作在传输层的可靠数据传输的服务，它能确保接收端接收的网络包是无损坏、无间隔、非冗余和按序的。\"]},\"203\":{\"h\":\"什么是TCP协议：\",\"t\":[\"TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。\",\"面向连接：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；\",\"可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；\",\"字节流：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。\"]},\"204\":{\"h\":\"什么是TCP连接:\",\"t\":[\"连接：用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。\",\"建立一个TCP连接需要：\",\"Socket：由 IP 地址和端口号组成\",\"序列号：用来解决乱序问题等\",\"窗口大小：用来做流量控制\"]},\"205\":{\"h\":\"如何确定一个TCP连接：\",\"t\":[\"TCP 四元组可以唯一的确定一个连接，四元组包括如下：\",\"源地址\",\"源端口\",\"目的地址\",\"目的端口\",\"源地址和目的地址在IP头部，源端口和目的端口在TCP头部\",\"有一个 IP 的服务端监听了一个端口，它的 TCP 的最大连接数是多少？\",\"对 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是服务端单机最大 TCP 连接数，约为 2 的 48 次方。\",\"文件描述符限制\",\"每个 TCP 连接都是一个文件，如果文件描述符被占满了，会发生 Too many open files。Linux 对可打开的文件描述符的数量分别作了三个方面的限制：\",\"系统级：当前系统可打开的最大数量\",\"用户级：指定用户可打开的最大数量\",\"进程级：单个进程可打开的最大数量\",\"内存限制，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的，如果内存资源被占满后，会发生 OOM\"]},\"206\":{\"h\":\"如何理解TCP是基于字节流的协议？\"},\"207\":{\"h\":\"先来说说为什么 UDP 是面向报文的协议？\",\"t\":[\"使用UDP传输协议的时候，操作系统不会对消息进行拆分。每个 UDP 报文就是一个用户消息的边界\",\"操作系统在收到 UDP 报文后，会将其插入到队列里，队列里的每一个元素就是一个 UDP 报文\"]},\"208\":{\"h\":\"再来说说为什么 TCP 是面向字节流的协议？\",\"t\":[\"消息可能会被操作系统分组成多个的 TCP 报文，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。\",\"如何解决粘包：\",\"固定长度的消息；\",\"特殊字符作为边界；\",\"自定义消息结构\"]},\"209\":{\"h\":\"TCP半连接队列和全连接队列\",\"t\":[\"如果持续不断地有连接因为 TCP 全连接队列溢出被丢弃，就应该调大 backlog 以及 somaxconn 参数\",\"开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接\",\"SYN攻击：\",\"增大半连接队列；\",\"开启 tcp_syncookies 功能\",\"减少 SYN+ACK 重传次数\",\"发送缓冲区不能超过「带宽时延积」\",\"如果发送缓冲区「超过」带宽时延积，超出的部分就没办法有效的网络传输，同时导致网络过载，容易丢包；\",\"如果发送缓冲区「小于」带宽时延积，就不能很好的发挥出网络的传输效率\"]},\"210\":{\"h\":\"SYN报文在什么情况下会被丢弃？\",\"t\":[\"net.ipv4.tcp_tw_recycle，如果开启该选项的话，允许处于 TIME_WAIT 状态的连接被快速回收；\",\"要使得这个选项生效，有一个前提条件，就是要打开 TCP 时间戳，即 net.ipv4.tcp_timestamps=1（默认即为 1)）。 当同时开启了recycle 和 timestamps 选项，会开启**「 per-host 的 PAWS 机制」**\",\"tcp_tw_recycle在NAT网络下使用是不安全的\",\"PAWS 就是为了避免TCP中序列号出现回绕，在开启 tcp_timestamps 选项情况下，一台机器发的所有 TCP 包都会带上发送时的时间戳，PAWS 要求连接双方维护最近一次收到的数据包的时间戳（Recent TSval），每收到一个新数据包都会读取数据包中的时间戳值跟 Recent TSval 值做比较，如果发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，就会直接丢弃这个数据包。\",\"per-host 是对「对端 IP 做 PAWS 检查」，而非对「IP + 端口」四元组做 PAWS 检查，在NAT网络下使用不安全\",\"半连接队列满了\",\"全连接队列满了\"]},\"211\":{\"h\":\"拔掉网线之后，TCP连接会消失吗？\",\"t\":[\"TCP连接存在于内核中，不会因为把掉网线造成TCP断开\"]},\"212\":{\"h\":\"\",\"t\":[\"RST 报文的时间戳即使过期了，只要 RST 报文的序列号在对方的接收窗口内，也是能被接受的。\",\"历史 RST 报文可能会终止后面相同四元组的连接，因为 PAWS 检查到即使 RST 是过期的，也不会丢弃。\",\"如果第四次挥手的 ACK 报文丢失了，有可能被动关闭连接的一方不能被正常的关闭;\"]},\"213\":{\"h\":\"用了TCP传输数据就一定不会丢包吗？\",\"t\":[\"TCP丢包：\",\"三次握手时（连接建立失败）\",\"流量控制丢包（当发送数据过快，流控队列长度txqueuelen又不够大时，就容易出现丢包现象。）\",\"网卡丢包（网线质量差，接触不良）RingBuffer过小导致丢包（网卡性能不足）\",\"接收缓冲区丢包，当缓冲区满了，就会将在收到的信息丢掉\",\"使用TCP出现丢包：\",\"聊天软件还需要将数据从TCP的接收缓冲区里读出来，如果在读出来这一刻，手机由于内存不足或其他各种原因，导致软件崩溃闪退了。\",\"这类丢包问题怎么解决：\",\"服务器可能记录了我们最近发过什么数据，假设每条消息都有个id，服务器和聊天软件每次都拿最新消息的id进行对比\",\"对于发送方，只要定时跟服务端的内容对账一下，就知道哪条消息没发送成功，直接重发就好了。\",\"如果接收方的聊天软件崩溃了，重启后跟服务器稍微通信一下就知道少了哪条数据，同步上来就是了，所以也不存在上面提到的丢包情况。\",\"TCP只保证传输层的消息可靠性，并不保证应用层的消息可靠性。如果我们还想保证应用层的消息可靠性，就需要应用层自己去实现逻辑做保证。\",\"主要有三个原因。\",\"第一，如果是两端通信，你聊天软件里有1000个好友，你就得建立1000个连接。但如果引入服务端，你只需要跟服务器建立1个连接就够了，聊天软件消耗的资源越少，手机就越省电。\",\"第二，就是安全问题，如果还是两端通信，随便一个人找你对账一下，你就把聊天记录给同步过去了，这并不合适吧。如果对方别有用心，信息就泄露了。引入第三方服务端就可以很方便的做各种鉴权校验。\",\"第三，是软件版本问题。软件装到用户手机之后，软件更不更新就是由用户说了算了。如果还是两端通信，且两端的软件版本跨度太大，很容易产生各种兼容性问题，但引入第三端服务器，就可以强制部分过低版本升级，否则不能使用软件。但对于大部分兼容性问题，给服务端加兼容逻辑就好了，不需要强制用户更新软件。\"]},\"214\":{\"h\":\"TCP的拥塞控制\"},\"215\":{\"h\":\"拥塞控制：\",\"t\":[\"避免「发送方」的数据填满整个网络，为了在「发送方」调节所要发送数据的量，定义了一个叫做「拥塞窗口」的概念。 $$ 什么是拥塞窗口，和发送窗口有什么关系？又是怎么知道当前网络出现了拥塞？拥塞控制有哪些？ $$ 拥塞窗口 cwnd是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的。发送窗口的值是swnd = min(cwnd, rwnd)，\",\"只要发生超时重传就会认为网络出现了拥塞\"]},\"216\":{\"h\":\"慢启动\",\"t\":[\"TCP在刚建立的时候，会一点一点提高发送数据包的数量，当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。\",\"发包个数呈指数增长\",\"有一个叫慢启动门限 ssthresh （slow start threshold）状态变量。\",\"当 cwnd < ssthresh 时，使用慢启动算法。\",\"当 cwnd >= ssthresh 时，就会使用「拥塞避免算法」。\"]},\"217\":{\"h\":\"拥塞避免\",\"t\":[\"**每当收到一个 ACK 时，cwnd 增加 1/cwnd。**从指数增长变成线性增长\",\"当触发了重传机制，也就进入了「拥塞发生算法」。\"]},\"218\":{\"h\":\"拥塞发生\",\"t\":[\"当发生了「超时重传」，则就会使用拥塞发生算法。\",\"这个时候，ssthresh 和 cwnd 的值会发生变化：\",\"ssthresh 设为 cwnd/2，\",\"cwnd 重置为 1 （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值\",\"当发生「快速重传」的时候，TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下：\",\"cwnd = cwnd/2 ，也就是设置为原来的一半;\",\"ssthresh = cwnd;\",\"进入快速恢复算法\"]},\"219\":{\"h\":\"快速恢复\",\"t\":[\"进入快速恢复算法如下：\",\"拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；\",\"重传丢失的数据包；\",\"如果再收到重复的 ACK，那么 cwnd 增加 1；目的是尽快将丢失的数据包发送给目标\",\"如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；\"]},\"220\":{\"h\":\"TCP的流量控制\"},\"221\":{\"h\":\"滑动窗口\",\"t\":[\"窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值\",\"累计确认或者累计应答：\",\"例如，如果接收方已经收到了序号为1至100的数据段，但是序号为101的数据段丢失了，接收方会发送一个确认报文，确认收到了1至100的数据。发送方收到这个确认后，会重新发送序号为101的数据段，以确保数据的完整性和正确性。\",\"如果接收方在接收到序号为1至98和序号为100的数据段后，发现序号为99的数据段丢失了，那么它会发送一个确认报文，确认收到了序号为1至98的数据，并且请求发送方重传序号为99的数据段。\"]},\"222\":{\"h\":\"窗口大小由哪一方决定？\",\"t\":[\"TCP 头里有一个字段叫 Window，也就是窗口大小。\",\"这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。\"]},\"223\":{\"h\":\"发送方的滑动窗口：\",\"t\":[\"#1 是已发送并收到 ACK确认的数据：1~31 字节\",\"#2 是已发送但未收到 ACK确认的数据：32~45 字节\",\"#3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节\",\"#4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后\",\"当发送方把数据「全部」都一下发送出去后，可用窗口的大小就为 0 了\",\"当收到之前发送的数据 32~36 字节的 ACK 确认应答后，如果发送窗口的大小没有变化，则滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认，接下来 52~56 字节又变成了可用窗口，那么后续也就可以发送 52~56 这 5 个字节的数据了。\"]},\"224\":{\"h\":\"程序如何表示发送方的四个部分呢？\",\"t\":[\"SND.WND：表示发送窗口的大小（大小是由接收方指定的）；\",\"SND.UNA（Send Unacknoleged）：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。\",\"SND.NXT：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。\",\"指向 #4 的第一个字节是个相对指针，它需要 SND.UNA 指针加上 SND.WND 大小的偏移量，就可以指向 #4 的第一个字节了。\",\"那么可用窗口大小的计算就可以是：\",\"可用窗口大小 = SND.WND -（SND.NXT - SND.UNA）\"]},\"225\":{\"h\":\"接收方的滑动窗口：\",\"t\":[\"RCV.WND：表示接收窗口的大小，它会通告给发送方。\",\"RCV.NXT：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。\",\"指向 #4 的第一个字节是个相对指针，它需要 RCV.NXT 指针加上 RCV.WND 大小的偏移量，就可以指向 #4 的第一个字节了。\"]},\"226\":{\"h\":\"接收窗口和发送窗口的大小是相等的吗？\",\"t\":[\"因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。\"]},\"227\":{\"h\":\"流量控制\",\"t\":[\"TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。\"]},\"228\":{\"h\":\"操作系统缓冲区和滑动窗口的关系：\",\"t\":[\"发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的，而操作系统的缓冲区，会被操作系统调整。\",\"先减少缓存，再收缩窗口，就会出现丢包的现象。\",\"为了防止这种情况发生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况\"]},\"229\":{\"h\":\"窗口关闭\",\"t\":[\"如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。\",\"窗口关闭的潜在危险？\",\"当窗口关闭的时候，接收方处理完数据会发送一个窗口大小非0的ACK报文，如果这个ACK报文丢失就会造成双方均处于等待的死锁环境\",\"TCP是如何解决窗口关闭的时候，潜在的死锁现象？\",\"只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。\",\"窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 RST 报文来中断连接\"]},\"230\":{\"h\":\"糊涂窗口综合征\",\"t\":[\"如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症。\",\"糊涂窗口综合症的现象是可以发生在发送方和接收方：\",\"接收方可以通告一个小的窗口\",\"而发送方可以发送小数据\",\"于是，要解决糊涂窗口综合症，就要同时解决上面两个问题就可以了：\",\"让接收方不通告小窗口给发送方，当「窗口大小」小于 min( MSS，缓存空间/2 ) ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为 0，等到窗口大小 >= MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。\",\"让发送方避免发送小数据，\",\"两个条件满足一个：\",\"条件一：要等到窗口大小 >= MSS 并且 数据大小 >= MSS；条件二：收到之前发送数据的 ack 回包；\",\"接收方得满足「不通告小窗口给发送方」+ 发送方开启 Nagle 算法，才能避免糊涂窗口综合症。\"]},\"231\":{\"h\":\"TCP的重传机制\"},\"232\":{\"h\":\"TCP的重传机制\"},\"233\":{\"h\":\"1.超时重传\",\"t\":[\"在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据\",\"超时时间应该设置为多少呢？\",\"RTT（Round-Trip Time 往返时延）数据发送时刻到接收到确认的时刻的差值\",\"RTO超时重传时间：\",\"RTO较长，重发很慢，没有效率\",\"RTO较短，导致没有丢包就会重传，导致更多的超时\",\"ROT应该较大于RTT\",\"**每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。**超时重传的周期可能时间过长\"]},\"234\":{\"h\":\"2.快速重传\",\"t\":[\"针对收到三次相同的报文，就会在定时器过期之前，重传丢失的报文\",\"但是他有一个问题重传的时候，是重传一个，还是重传所有的问题。\"]},\"235\":{\"h\":\"3.SACK方法\",\"t\":[\"SACK（ Selective Acknowledgment），选择性确认\",\"可以将已收到的数据的信息发送给「发送方」，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。\",\"需要两方都支持SACK\"]},\"236\":{\"h\":\"4.Duplicate SACK\",\"t\":[\"使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。\",\"可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;\",\"可以知道是不是「发送方」的数据包被网络延迟了;\",\"可以知道网络中是不是把「发送方」的数据包给复制了;\"]},\"237\":{\"h\":\"TCP连接的建立\"},\"238\":{\"h\":\"TCP连接的建立：\",\"t\":[\"TCP的三次握手：\",\"一开始双方处于close状态，服务器会主动监听某个端口处于LISTEN，\",\"第一次握手：客户端向服务端发送一个带有初始化序列号（ISN）的，SYN=1的SNTCP报文，之后客户端处于SYN_SENT状态\",\"第二次握手：服务端收到客户端发来的报文，然会向服务端发送一个带有自己初始化的随机序列号，确认应答号是客户端的ISN+1， 并且SYN和ACK都等于1的TCP报文，然后服务端处于SYN_RCYD（半连接状态）\",\"第三次握手：客户端向服务端发送一个，确认应答号为服务端ISN加1的，ACK为1，TCP报文发送给服务端，之后客户端处于ESTABLISHED（连接状态），可以携带数据\",\"第三次握手是可以携带数据的，前两次不可以携带数据\"]},\"239\":{\"h\":\"为什么是三次握手：\",\"t\":[\"1.TCP 使用三次握手建立连接的最主要原因是防止「历史连接」初始化了连接\",\"在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费。\",\"要解决这种现象，最好就是在服务端发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手。\",\"2.同步双方初始序列号\",\"序列号的作用：\",\"接收方可以去除重复的数据；\",\"接收方可以根据数据包的序列号按序接收；\",\"可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）\",\"一来一回，才能确保双方的初始序列号能被可靠的同步。\",\"两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收\"]},\"240\":{\"h\":\"为什么每次建立TCP链接的时候，初始化序列号的都要求不一样？\",\"t\":[\"首要目的是，防止历史报文被下一个相同四元组接收\",\"为了安全性，防止黑客伪造的相同序列号TCP报文被对方接收\"]},\"241\":{\"h\":\"初始序列号ISN是如何随机产生的？\",\"t\":[\"ISN = M + F(localhost, localport, remotehost, remoteport)\",\"M:计时器，每4微秒加一 F：是一个Hash，跟据源IP，目的IP，源端口，目标端口。随即生成一个随机数\"]},\"242\":{\"h\":\"既然IP层会分片，为什么TCP层还需要MSS？\",\"t\":[\"如果直接交给IP层，让他进行分片，如果其中一个IP包丢失，由于IP层没有超时重传，直接导致发送方迟迟接收不到ACK，导致整个IP报文被重传\",\"所以，为了达到最佳的传输效能 TCP 协议在建立连接的时候通常要协商双方的 MSS 值，当将分片交给TCP层后就不需要IP层进行分片了，如果一个TCP分片丢失，只用重发丢失片\",\"IP层分片：为了适应不同链路的MUT不同\"]},\"243\":{\"h\":\"当第一次握手丢失：\",\"t\":[\"会触发超时重传，并且重传的SYN报文序列号是一样的\",\"通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后，每次超时的时间是上一次的 2 倍。\",\"一般有一个最大重传次数 tcp_syn_retries，如果超过会在等一段时间（上一次超时的二倍），之后还没有，就断开连接\"]},\"244\":{\"h\":\"第二次握手丢失：\",\"t\":[\"客户端和服务端都会触发超时重传机制\",\"由于客户端在第一次握手之后迟迟没有接受ACK，会认为第一次握手报文丢失就会重新传SYN报文 然后，服务端的话由于长时间没有收到第三次握手，会认为第二次握手丢失就会重传SYN_ACK报文（也有一个最大重传次数 tcp_syn_retries）\"]},\"245\":{\"h\":\"第三次握手丢失：\",\"t\":[\"服务端会触发超时重传\",\"由于服务端长时间没有收到ACK报文，就会重传SYN_ACK报文\",\"ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文。\"]},\"246\":{\"h\":\"为什么每次建立TCP连接，初始化序列号都要不一样？\",\"t\":[\"尽最大可能避免历史报文被新的TCP连接接收到\",\"随机数是会基于时钟计时器递增的，基本不可能会随机成一样的初始化序列号。\",\"​ 序列号（SEQ）：用于对TCP连接上发送的每一个数据包进行编号0，序列号在整个TCP连接的生命周期中都是递增的，并且它们用于确定数据包的顺序以及检测数据包的丢失或乱序到达，序列号是一个 32 位的无符号数，因此在到达 4G 之后再循环回到 0。\",\"​ 初始化序列号（ISN）：用于每次建立TCP的链接，目的是确保每个TCP连接都具有唯一的起始序列号，以防止对连接的重放攻击和其他形式的网络攻击。初始化序列号可被视为一个 32 位的计数器，该计数器的数值每 4 微秒加 1，循环一次需要 4.55 小时。\",\"序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据。\",\"TCP时间戳：一个是便于精确计算 RTT ，另一个是能防止序列号回绕（PAWS）。\",\"防回绕序列号算法要求连接双方维护最近一次收到的数据包的时间戳（Recent TSval），每收到一个新数据包都会读取数据包中的时间戳值跟 Recent TSval 值做比较，如果发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，就会直接丢弃这个数据包。\",\"引入时间戳之后可以完全避免历史报文接收问题\"]},\"247\":{\"h\":\"TCP 序列号和确认号是如何变化的？\"},\"248\":{\"h\":\"万能公式\",\"t\":[\"发送的 TCP 报文：\",\"公式一：序列号 = 上一次发送的序列号 + len（数据长度）。特殊情况，如果上一次发送的报文是 SYN 报文或者 FIN 报文，则改为 上一次发送的序列号 + 1。\",\"公式二：确认号 = 上一次收到的报文中的序列号 + len（数据长度）。特殊情况，如果收到的是 SYN 报文或者 FIN 报文，则改为上一次收到的报文中的序列号 + 1。\",\"序列号：在建立连接时由内核生成的随机数作为其初始值，通过 SYN 报文传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。用来解决网络包乱序问题。\",\"确认号：指下一次「期望」收到的数据的序列号，发送端收到接收方发来的 ACK 确认报文以后，就可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包的问题。\",\"**控制位：**用来标识 TCP 报文是什么类型的报文，比如是 SYN 报文、数据报文、ACK 报文，FIN 报文等\"]},\"249\":{\"h\":\"已建立的TCP连接，收到SYN会发生什么？\",\"t\":[\"客户端的SYN报文中的源端口号和历史连接的不同\",\"服务端会认为这是一个新的连接请求，就会建立一个新的链接\",\"客户端的SYN中的端口号和历史连接的不同\",\"处于连接中的TCP连接，如果收到了SYN报文，服务端会返回一个带有正确的确认号和正确的序列号这个 ACK 被称之为 Challenge ACK。\",\"接着，客户端收到这个 Challenge ACK，发现确认号（ack num）并不是自己期望收到的，于是就会回 RST 报文，服务端收到后，就会释放掉该连接\"]},\"250\":{\"h\":\"killcx 的工具\",\"t\":[\"我们可以伪造一个四元组相同的 SYN 报文，来拿到“合法”的序列号！\",\"正如我们最开始学到的，如果处于 Established 状态的服务端，收到四元组相同的 SYN 报文后，会回复一个 Challenge ACK，这个 ACK 报文里的「确认号」，正好是服务端下一次想要接收的序列号，说白了，就是可以通过这一步拿到服务端下一次预期接收的序列号。\",\"然后用这个确认号作为 RST 报文的序列号，发送给服务端，此时服务端会认为这个 RST 报文里的序列号是合法的，于是就会释放连接！\"]},\"251\":{\"h\":\"tcpkill 的工具\",\"t\":[\"tcpkill 工具是在双方进行 TCP 通信时，拿到对方下一次期望收到的序列号，然后将序列号填充到伪造的 RST 报文，并将其发送给对方，达到关闭 TCP 连接的效果。\",\"无法关闭非活跃的TCP连接\"]},\"252\":{\"h\":\"\",\"t\":[\"HTTP 的 Keep-Alive，是由应用层（用户态） 实现的，称为 HTTP 长连接\",\"只要一端没有明确的提出断开连接，就会让这个TCP保持连接状态；但是有一个，HTTP连接超时时间的限制\",\"TCP 的 Keepalive，是由 TCP 层（内核态） 实现的，称为 TCP 保活机制\"]},\"253\":{\"h\":\"TCP连接的断开\"},\"254\":{\"h\":\"TCP断开连接\"},\"255\":{\"h\":\"TCP的四次挥手：\",\"t\":[\"第一次挥手，客户端主动想要断开连接，向服务器发送一个FIN报文，之后客户端进入FIN_WAIT_1状态\",\"第二次挥手，服务端收到该报文，向客户端发送一个ACK报文，服务端进入CLOSE_WAIT状态，客户端接收之后进入FIN_WAIT_2状态\",\"第三次挥手，服务端可能还有数据需要处理和发送，等服务端不再发送数据时，发送FIN报文，之后服务端进入LAST_ACK状态\",\"第四次挥手，客户端向服务端发送ACK报文，服务端接收到报文之后进入CLOSE状态，而客户端则会TIME_WAIT(2MSL)之后进入CLOSE状态\",\"主动关闭连接的，才有 TIME_WAIT 状态。\"]},\"256\":{\"h\":\"第一次挥手丢失：\",\"t\":[\"客户端向服务端发送FIN报文，之后进入FIN_WAIT_1状态\",\"第一次挥手丢失，客户端会触发超时重传，当重传次数超出上限，客户端就会直接进入CLOSE状态\"]},\"257\":{\"h\":\"第二次挥手丢失：\",\"t\":[\"服务端向客户端发送ACK报文，之后进入CLOSE_WAIT状态\",\"当第二次挥手丢失之后，由于ACK报文不会重传，于是会触发第一次挥手的重传机制，当重传次数超出上限，客户端就会直接进入CLOSE状态\",\"客户端接收到第二次挥手的时候，进入FIN_WAIT_2状态\",\"如果关闭方使用的是Close函数（无法再接收和发送数据），所以FIN_WAIT_2状态不能持续太久，一般在60s内不能接收到FIN报文，就会直接进入CLOSE状态\",\"如果关闭方使用的是shutdown函数（无法在发送数据，但是可以接受数据），如果一直没有接收到FIN报文就会一直死等\"]},\"258\":{\"h\":\"第三次挥手丢失：\",\"t\":[\"由于服务端超时间没有收到ACK报文，就会触发超时重传，达到最大次数之后服务端就直接进入CLOSE状态\",\"而客户端使用CKLOSE函数超过60s没有接收FIN报文，也会进入CLOSE状态\"]},\"259\":{\"h\":\"第四次挥手丢失\",\"t\":[\"客户端的ACK报文丢失，服务端长时间没有收到ACK就会触发第三次挥手的重传机制\",\"客户端在发送ACK之后进入TIME_WAIT状态，开启2MSL计时器，如果中途再次接收到FIN报文，就会重置计时器，当等待时间超过2MSL，客户端就直接进入CLOSE状态\",\"服务端超过最大重传次数之后，直接进入CLOSE状态\"]},\"260\":{\"h\":\"TCP四次挥手可以变成三次吗？\",\"t\":[\"FIN 报文一定得调用关闭连接的函数，才会发送吗？\",\"不一定。\",\"如果进程退出了，不管是不是正常退出，还是异常退出（如进程崩溃），内核都会发送 FIN 报文，与对方完成四次挥手\"]},\"261\":{\"h\":\"粗暴关闭VS优雅关闭：\",\"t\":[\"粗暴关闭（close）：\",\"close 函数，同时 socket 关闭发送方向和读取方向，也就是 socket 不再有发送和接收数据的能力。如果有多进程/多线程共享同一个 socket，如果有一个进程调用了 close 关闭只是让 socket 引用计数 -1，并不会导致 socket 不可用，同时也不会发出 FIN 报文，其他进程还是可以正常读写该 socket，直到引用计数变为 0，才会发出 FIN 报文。\",\"如果客户端是用 close 函数来关闭连接，那么在 TCP 四次挥手过程中，如果收到了服务端发送的数据，由于客户端已经不再具有发送和接收数据的能力，所以客户端的内核会回 RST 报文给服务端，然后内核会释放连接，这时就不会经历完成的 TCP 四次挥手，所以我们常说，调用 close 是粗暴的关闭。\",\"优雅关闭（shutdown）：\",\"shutdown 函数，可以指定 socket 只关闭发送方向而不关闭读取方向，也就是 socket 不再有发送数据的能力，但是还是具有接收数据的能力。如果有多进程/多线程共享同一个 socket，shutdown 则不管引用计数，直接使得该 socket 不可用，然后发出 FIN 报文，如果有别的进程企图使用该 socket，将会受到影响。\"]},\"262\":{\"h\":\"什么情况下会出现三次挥手？\",\"t\":[\"当被动关闭方在 TCP 挥手过程中，「没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。\",\"什么是 TCP 延迟确认机制？\",\"当发送没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报文。 为了解决 ACK 传输效率低问题，所以就衍生出了 TCP 延迟确认。 TCP 延迟确认的策略：\",\"当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方\",\"当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送\",\"如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK\"]},\"263\":{\"h\":\"四次挥手中收到乱序的FIN包怎么办\",\"t\":[\"如果FIN报文比数据包提前到达客户端，此时FIN是一个乱序的报文，客户端不会从FIN_WAIT_2状态变成TIME_WAIT状态\",\"而是把它放到乱序队列，等收到数据包之后才会从这个队列中找是否有可用的数据包，如果能找到这个数据包序列号保持顺序的报文，然后就会查看这个报文，如果有FIN字段就会进入TIME_WAIT状态\"]},\"264\":{\"h\":\"在TIME_WAIT状态的TCP接收到SYN报文会怎么样？\"},\"265\":{\"h\":\"SYN合法：\",\"t\":[\"针对开启了TCP时间戳的TCP：\",\"客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要大，并且 SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要大。\",\"此时如果收到相同四元组的SYN包就会跳过2MSL,直接跳到SYN_RECV状态继续建立连接\"]},\"266\":{\"h\":\"SYN非法：\",\"t\":[\"非法 SYN：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要小，或者 SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要小。\",\"收到非法的SYN包回发送一个第四次挥手的ACK，然后客户端发现不是自己的，就会回复RST\"]},\"267\":{\"h\":\"在 TIME_WAIT 状态，收到 RST 会断开连接吗？\",\"t\":[\"看这个内核参数net.ipv4.tcp_rfc1337为1就丢掉\"]},\"268\":{\"h\":\"如果已经建立了链接，客户端突然挂怎么办\",\"t\":[\"TCP的保活机制：\",\"定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡\"]},\"269\":{\"h\":\"如果已经建立了链接，服务端突然挂怎么办\",\"t\":[\"kill 掉进程后，服务端会（内核）发送 FIN 报文，与客户端进行四次挥手。\"]},\"270\":{\"h\":\"TCP连接，一端断电和进程崩溃有什么区别？\",\"t\":[\"主机崩溃：\",\"在没有开启 TCP keepalive，且双方一直没有数据交互的情况下，如果客户端的「主机崩溃」了，会发生什么。\",\"客户端主机崩溃了，服务端是无法感知到的，在加上服务端没有开启 TCP keepalive，又没有数据交互的情况下，服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态，直到服务端重启进程。\",\"那题目中的「进程崩溃」的情况呢？\",\"即使没有开启 TCP keepalive，且双方也没有数据交互的情况下，如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。\"]},\"271\":{\"h\":\"客户端主机宕机又重启？\",\"t\":[\"无论重启之后主机上是否还有这个进程的目标端口号，都会返回一个RST报文\"]},\"272\":{\"h\":\"QUIC协议\"},\"273\":{\"h\":\"\"},\"274\":{\"h\":\"QUIC是如何实现可靠传输的？\",\"t\":[\"在应用层下功夫，报文多加几个头部字段\"]},\"275\":{\"h\":\"Packet Header\",\"t\":[\"Packet Header 首次建立连接时和日常传输数据时使用的 Header 是不同的\",\"QUIC 也是需要三次握手来建立连接的，主要目的是为了协商连接 ID。\",\"Packet Number 是每个报文独一无二的编号，它是严格递增的，也就是说就算 Packet N 丢失了，重传的 Packet N 的 Packet Number 已经不是 N，而是一个比 N 大的值。\",\"这样做的好处，使重传没有歧义（歧义：是接受到上一次的数据包，还是重传之后的数据包），可以支持乱序确认\"]},\"276\":{\"h\":\"QUIC Frame Header\",\"t\":[\"stream类型的Fream:\",\"stream ID:用于区分不同的HTTP信息 Offset：用于标识数据，保证数据的顺序性和可靠 Length:指明数据的长度\",\"丢失的数据包和重传的数据包 Stream ID 与 Offset 都一致，说明这两个数据包的内容一致\"]},\"277\":{\"h\":\"QUIC 是如何解决 TCP 队头阻塞问题的？\",\"t\":[\"TCP 必须按序处理数据，也就是 TCP 层为了保证数据的有序性，只有在处理完有序的数据后，滑动窗口才能往前滑动，如果其中一个数据丢失，窗口停留直到丢失的数据包被重传接收\",\"HTTP/2 多个 Stream 请求都是在一条 TCP 连接上传输，这意味着多个 Stream 共用同一个 TCP 滑动窗口，那么当发生数据丢失，滑动窗口是无法往前移动的，此时就会阻塞住所有的 HTTP 请求，这属于 TCP 层队头阻塞。\",\"QUIC的解决办法：\",\"QUIC 给每一个 Stream 都分配了一个独立的滑动窗口，这样使得一个连接上的多个 Stream 之间没有依赖关系，都是相互独立的，各自控制的滑动窗口。\"]},\"278\":{\"h\":\"QUIC 是如何做流量控制的？\",\"t\":[\"QUIC 的滑动窗口滑动的条件跟 TCP 有一点差别，但是同一个 Stream 的数据也是要保证顺序的，不然无法实现可靠传输，因此某一个 Stream 的数据包丢失了，也会造成某一个Stream的窗口无法滑动。\",\"Stream 级别的流量控制：Stream 可以认为就是一条 HTTP 请求，每个 Stream 都有独立的滑动窗口，所以每个 Stream 都可以做流量控制，防止单个 Stream 消耗连接（Connection）的全部接收缓冲。 \",\"接受窗口的左侧边界取决于最大偏移数\",\"当已读取的数据大于最大接受窗口的一半时，将窗口向右移动当前已读取的数据字节数\",\"控制数据发送的唯一限制就是最大绝对字节偏移量，该值是接收方基于当前已经提交的偏移量（连续已确认并向上层应用提交的数据包offset）和发送方协商得出\",\"Connection 流量控制：限制连接中所有 Stream 相加起来的总字节数，防止发送方超过连接的缓冲容量 \",\"而对于 Connection 级别的流量窗口，其接收窗口大小就是各个 Stream 接收窗口大小之和\"]},\"279\":{\"h\":\"QUIC 对拥塞控制改进\",\"t\":[\"将TCP的拥塞控制算法搬过来，QUIC作为一个基于UDP的传输层协议，提供了在应用层实现拥塞控制的能力，QUIC 可以随浏览器更新，QUIC 的拥塞控制算法就可以有较快的迭代速度。可以针对不同的应用设置不同的拥塞控制算法\"]},\"280\":{\"h\":\"QUIC 更快的连接建立\",\"t\":[\"QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。\"]},\"281\":{\"h\":\"QUIC 是如何迁移连接的？\",\"t\":[\"通过连接 ID来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了连接迁移的功能\"]},\"282\":{\"h\":\"常见的网络分层模型\"},\"283\":{\"h\":\"网络模型：\",\"t\":[\"OSI网络模型：\",\"应用层，负责给应用程序提供统一的接口；\",\"表示层，负责把数据转换成兼容另一个系统能识别的格式；\",\"会话层，负责建立、管理和终止表示层实体之间的通信会话；\",\"传输层，负责端到端的数据传输；\",\"网络层，负责数据的路由、转发、分片；\",\"数据链路层，负责数据的封帧和差错检测，以及 MAC 寻址；\",\"物理层，负责在物理网络中传输数据帧；\",\"TCP/IP四层模型：\",\"应用层，负责向用户提供一组应用程序，比如 HTTP、DNS、FTP 等;\",\"传输层，负责端到端的通信，比如 TCP、UDP 等；\",\"网络层，负责网络包的封装、分片、路由、转发，比如 IP、ICMP 等；\",\"网络接口层，负责网络包在物理网络中的传输，比如网络包的封帧、 MAC 寻址、差错检测，以及通过网卡传输网络帧等；\",\"TCP/IP协议栈的五层模型：\",\"应用层：提供了用户与网络应用之间的接口，应用程序可以和网络进行通信和数据交换\",\"传输层：负责端到端之间的通信\",\"网络层（Internet Layer）：网络层负责在不同网络之间进行数据包的路由和转发，主要通过 IP（Internet Protocol）实现。IP 协议定义了数据包的格式和传输规则，以确保数据能够在不同网络间传输。\",\"数据链路层（Link Layer）：数据链路层负责在相邻节点之间传输数据帧，通常包括物理链路和数据链路两个子层。物理链路层负责将比特流转换为数据帧，而数据链路层则负责通过物理介质传输数据。\",\"物理层（Physical Layer）：物理层是网络通信的最底层，负责传输比特流，包括数据的编码、传输介质的传输特性等。\"]},\"284\":{\"h\":\"基础计网\",\"t\":[\"1.TCP/IP，网络模型\"]},\"285\":{\"h\":\"应用层：\",\"t\":[\"我们电脑或手机使用的应用软件都是在应用层实现。那么，当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。 应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态\"]},\"286\":{\"h\":\"用户态和内核态：\",\"t\":[\"用户态和内核态是操作系统中的两种运行模式，用来描述程序或进程执行时所处的不同权限级别或特权级别。\"]},\"287\":{\"h\":\"传输层：（作为传输媒介）\",\"t\":[\"在传输层有两种传输协议：TCP(传输控制协议),UDP\",\"TCP 比UDP多了很多特性，比如流量控制，超时重传，拥塞控制等，都是为了数据包能可靠的传输给对方（http应用层协议）；最大报文段长度MSS；传输时会加一个TCP头；传输单位是段\",\"当数据包大小大于MSS时要将数据包分块，每一个分块我们称为TCP段，这样在传输时如果丢了一小段，只需重新发送这一小段\",\"UDP就只是传输数据包，不保证数据包是否能够抵达对方，实时性相对较好，传输效率更高。也可以实现可靠传输，在应用层把TCP的特性全部实现（不容易）。\",\"每一个应用都有对应的端口号，以方便辨识数据包应该传输给哪一个应用 浏览器中每一个标签栏都是独立的进程，会分配暂时的端口号\"]},\"288\":{\"h\":\"网络层:(有着实际的传输功能)\",\"t\":[\"最常用的是IP协议，将传输层传来的数据再加上IP包头组转成IP报文;传输单位是包\",\"当报文长度超过MTU时，再进行分片\"]},\"289\":{\"h\":\"IP协议的寻址作用：\",\"t\":[\"将IP地址分成两部分：\",\"1.网络号，负责表示属于哪个子网 2.主机号，负责表示同一子网下的不同设备\",\"通过子网掩码，将ip地址与子网掩码进行按位与可以得到网络号 将子网掩码取反之后，与IP地址进行按位与可以获得主机号\"]},\"290\":{\"h\":\"IP协议还可以\",\"t\":[\"IP协议的寻址作用告诉我们要***往哪走，而路由则是跟据下一个目的地选择路径***\"]},\"291\":{\"h\":\"网络接口层：\",\"t\":[\"1.生成IP头部之后，交给网络接口层生成MAC头部，封装成数据帧发送到网络上；传输单位是帧 2.MAC头部是以太网使用的头部，包含了接收方和发送方的MAC地址等信息，可以通过ARP协议获取对方MAC地址 3.负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备\"]},\"292\":{\"h\":\"键入一个URL网络世界发生了什么？\"},\"293\":{\"h\":\"1.浏览器第一步工作是解析ULR，然后生产HTTP请求消息，然后会\"},\"294\":{\"h\":\"2.在发送之前， ，在委托操作系统发送消息时必须提供\"},\"295\":{\"h\":\"DNS服务器:专门保存了 服务器域名与 的对应关系\",\"t\":[\"www.server.com.，. 根域是在最顶层，它的下一层就是 .com 顶级域，再下面是 server.com。\",\"所以域名的层级关系类似一个树状结构：\",\"根 DNS 服务器（.）\",\"顶级域 DNS 服务器（.com）\",\"权威 DNS 服务器（server.com）\",\"根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。 户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。\"]},\"296\":{\"h\":\"只指路不带路\"},\"297\":{\"h\":\"3.通过DNS获取到IP后，把传输工作给操作系统中的协议栈\",\"t\":[\"应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。\",\"协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，这两个传输协议会接受应用层的委托执行收发数据的操作下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的\",\"此外 IP 中还包括 ICMP 协议和 ARP 协议。\",\"ICMP 用于告知网络包传送过程中产生的错误以及各种控制信息。\",\"ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。\",\"IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。\"]},\"298\":{\"h\":\"4.http协议是基于TCP协议传输的\",\"t\":[\"在 HTTP 传输数据之前，首先需要 TCP 建立连接，TCP 连接的建立，通常称为三次握手。\"]},\"299\":{\"h\":\"1.第一次握手\",\"t\":[\"首先双方都处于closed状态，客户端会发送一个带有SYN（同步序列编号）标志的TCP报文到服务器，表示客户端请求连接；并且在其中客户端还会选择一个ISN（初始序列号）放入SYN报文段中\",\"ISN：用于标识客户端到服务器的数据流\",\"SYN：SYN 标志用于指示一个 TCP 报文段是一个连接请求（SYN=1，ACK=0）或连接接受（SYN=1，ACK=1）\",\"第一次握手之后：客户端处于SYN_SENT状态（同步已发送），服务器处于LISTEN（监听状态）\"]},\"300\":{\"h\":\"2.第二次握手\",\"t\":[\"服务器同意建立连接，会回复一个带有SYN和ACK（确认号）标识的TCP报文；服务器也会选择一个初始序列号用于标识服务器到客户端的数据流\",\"ACK：ACK标识表示确认号表示服务器希望下一次接受的下一序列号，是 SYN 报文段的序列号加一\",\"第二次握手之后：客户端处于SYN_SENT状态，服务器处于SYN-RCVD（半连接状态）\"]},\"301\":{\"h\":\"3.第三次握手\",\"t\":[\"客户端在接收服务器的带有SYN和ACK（确认号）标识的TCP报文之后，会向服务器发送一个带有ACK标志的确认报文段;并且这个报文字段包含客户端收到的服务端的ISN，以及ACK（表示客户端希望下一次接受的序列号）\",\"第三次握手之后：客户端和服务器都进入ESTABLISHED\",\"三次握手的目的是确认双方都有发送和接受的能力\"]},\"302\":{\"h\":\"完整的TCP报文：\"},\"303\":{\"h\":\"4.IP\",\"t\":[\"TCP模块在执行链接，收发，断开等各阶段操作时，都需要委托IP模块将数据封装成网络包发送给通信对象\",\"IP协议需要源IP和目标地址IP：\",\"源地址IP，即是客户端输出的 IP 地址；\",\"目标地址，即通过 DNS 域名解析得到的 Web 服务器 IP。\",\"在IP包头的协议号要填写16进制的，表示协议为TCP 在客户端有多个网卡的时候，选择源IP时将目标地址的网络号（IP与子网掩码做与运算）与网卡的IP地址比较选择相同的那个网卡。 如果其它条目都无法匹配自动匹配默认网关（目标地址和子网掩码都是 0.0.0.0）\",\"一个完整的网络包：\",\"IP 层报文\"]},\"304\":{\"h\":\"5.MAC\",\"t\":[\"在生成IP包头之后，还需要在网络包前面加一个MAC头部 MAC头部是以太网使用的头部： 在MAC头里面要包含发送方MAC地址和接收方MAC地址，用于两点之间的传输\",\"在一般的TCP/IP通信里，MAC协议只有两种：\",\"0800 ： IP 协议（当以太网数据帧中的以太类型字段的值为0800，数据帧包含的是IP协议的数据）\",\"0806 ： ARP 协议（当以太网数据帧中的以太类型字段的值为0806，数据帧包含的是APR协议的数据）\",\"获取对方的MAC地址，首先根据路由表找到对方IP地址，再跟据APR协议找到对方MAC地址 APR协议：通过广播的形式从局域网中找到响应者的MAC地址然后保存到APR缓存中，下次先访问缓存\",\"通过0806以太类型字段值发送ARP请求来获取目标设备MAC地址与0800以太类型字段值发送ARP请求的方法类似，只是前者明确了数据帧中包含的是ARP协议的数据。\",\"MAC报文：\",\"MAC 层报文\"]},\"305\":{\"h\":\"5.网卡（真正的数据发送）\",\"t\":[\"网卡驱动程序获取网络包，将其复制到网卡的缓存区，在其开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列\",\"数据包\",\"起始帧分界符是一个用来表示包起始位置的标记\",\"末尾的 FCS（帧校验序列）用来检查包传输过程是否有损坏\",\"最后将数字信息（网络包中的二进制数据）转为电信号，通过网线发送出去\"]},\"306\":{\"h\":\"6.交换机\",\"t\":[\"交换机的设计是将网络包原样转发到目的地 交换机工作在MAC层，也称二层网络设备\",\"首先当电信号到达网线接口，交换机将电信号转变为数字信号，如果没问题则放到缓存区\",\"接下来，交换机通过查询MAC地址表，将信号发送到对应端口\",\"当在表中找不到的时候，交换机会将包转发到除了源端口之外的所有端口，确保设备可以接收**（这样做是没什么问题的，以太网的设计本身就是将包发送到整个网络，只有接收者才会接受，其他则会忽略这个包）**\",\"如果接受方MAC地址是一个广播地址，交换机会将包转发到除了源端口之外的所有端口\",\"网卡和交换机的区别：\",\"计算机的网卡本身具有MAC地址，通过核对收到的包的接收方的MAC地址判断是不是发送给自己的，如果不是就丢弃。\",\"交换机的端口不具有MAC地址，不核对收到的包的接收方的MAC地址，而是直接接受所有包并存在缓冲区\",\"MAC地址表：\",\"一个是设备的 MAC 地址，\",\"另一个是该设备连接在交换机的哪个端口上\",\"以下两个属于广播地址：\",\"MAC 地址中的 FF:FF:FF:FF:FF:FF\",\"IP 地址中的 255.255.255.255\"]},\"307\":{\"h\":\"7.路由器\",\"t\":[\"网络包经过交换机之后，现在到达了路由器，并在此被转发到下一个路由器或目标设备。 当转发包时，首先路由器端口会接收发给自己的以太网包，然后路由表查询转发目标，再由相应的端口作为发送方将以太网包发送出去。\",\"路由器接受包： 首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，检查 MAC 头部中的接收方 MAC 地址，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。\",\"在完成接收之后，路由器会去掉包MAC头部，跟据IP头部进行包的转发，跟据路由表\",\"路由器发送包：\",\"首先，我们需要根据路由表的网关列判断对方的地址。\",\"如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，还未抵达终点，还需继续需要路由器转发。\",\"如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明已抵达终点。\",\"知道对方的 IP 地址之后，接下来需要通过 ARP 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。\",\"路由器和交换机是有区别的：\",\"因为路由器是基于 IP 设计的，俗称三层网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；\",\"而交换机是基于以太网设计的，俗称二层网络设备，交换机的端口不具有 MAC 地址。\",\"在网络包传输的过程中，源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址，因为需要 MAC 地址在以太网内进行两个设备之间的包传输。\"]},\"308\":{\"h\":\"8.客户端&服务器\",\"t\":[\"四次挥手：\",\"第一次挥手：客户端向服务器发送连接释放请求（FIN）。\",\"第二次挥手：服务器收到客户端的连接释放请求后，向客户端发送确认（ACK）。\",\"第三次挥手：服务器准备好关闭连接时，向客户端发送连接释放请求（FIN）。\",\"第四次挥手：客户端收到服务器的连接释放请求后，向服务器发送确认（ACK），完成连接的关闭。\"]}},\"dirtCount\":0,\"index\":[[\"始终是不会变的\",{\"1\":{\"307\":1}}],[\"俗称二层网络设备\",{\"1\":{\"307\":1}}],[\"俗称三层网络设备\",{\"1\":{\"307\":1}}],[\"电信号到达网线接口部分\",{\"1\":{\"307\":1}}],[\"末尾的\",{\"1\":{\"305\":1}}],[\"起始帧分界符是一个用来表示包起始位置的标记\",{\"1\":{\"305\":1}}],[\"真正的数据发送\",{\"0\":{\"305\":1}}],[\"真是便捷到即插即用啊\",{\"1\":{\"159\":1}}],[\"域名解析得到的\",{\"1\":{\"303\":1}}],[\"断开等各阶段操作时\",{\"1\":{\"303\":1}}],[\"断网了还能ping通127\",{\"0\":{\"144\":1}}],[\"收发\",{\"1\":{\"303\":1}}],[\"收到非法的syn包回发送一个第四次挥手的ack\",{\"1\":{\"266\":1}}],[\"收到四元组相同的\",{\"1\":{\"250\":1}}],[\"收到syn会发生什么\",{\"0\":{\"249\":1}}],[\"收到syn报文时\",{\"1\":{\"169\":1}}],[\"收到之前发送数据的\",{\"1\":{\"230\":1}}],[\"收到的数据的序列号\",{\"1\":{\"201\":1,\"248\":1}}],[\"收到客户端的ack报文时\",{\"1\":{\"169\":1}}],[\"收到这个包的路由器\",{\"1\":{\"153\":1}}],[\"收到这个查询\",{\"1\":{\"139\":1}}],[\"收到\",{\"0\":{\"267\":1},\"1\":{\"143\":1}}],[\"收到该报文后\",{\"1\":{\"139\":1}}],[\"收到同一个组内的其他主机发送的成员关系报告报文\",{\"1\":{\"139\":1}}],[\"收到信号后自然进行响应\",{\"1\":{\"76\":1}}],[\"库\",{\"1\":{\"297\":1}}],[\"户端只要能够找到任意一台\",{\"1\":{\"295\":1}}],[\"权威\",{\"1\":{\"295\":1}}],[\"权重值就越大\",{\"1\":{\"62\":1}}],[\"权重值与\",{\"1\":{\"62\":1}}],[\"顶级域\",{\"1\":{\"295\":2}}],[\"专门保存了\",{\"0\":{\"295\":1}}],[\"专门处理软中断\",{\"1\":{\"147\":1}}],[\"键入一个url网络世界发生了什么\",{\"0\":{\"292\":1}}],[\"往哪走\",{\"1\":{\"290\":1}}],[\"往返时延\",{\"1\":{\"233\":1}}],[\"物理链路层负责将比特流转换为数据帧\",{\"1\":{\"283\":1}}],[\"物理层是网络通信的最底层\",{\"1\":{\"283\":1}}],[\"物理层\",{\"1\":{\"283\":2}}],[\"差错检测\",{\"1\":{\"283\":1}}],[\"差错报文时就减少包的大小\",{\"1\":{\"143\":1}}],[\"差错报文消息\",{\"1\":{\"143\":1}}],[\"差错报文数据包\",{\"1\":{\"143\":1}}],[\"差错报文网络包\",{\"1\":{\"143\":1}}],[\"差错报文类型\",{\"1\":{\"139\":1}}],[\"寻址\",{\"1\":{\"283\":2}}],[\"管理和终止表示层实体之间的通信会话\",{\"1\":{\"283\":1}}],[\"地复用原连接\",{\"1\":{\"281\":1}}],[\"地址在以太网内进行两个设备之间的包传输\",{\"1\":{\"307\":1}}],[\"地址在计算机是以二进制的方式处理的\",{\"1\":{\"151\":1}}],[\"地址查询\",{\"1\":{\"307\":1}}],[\"地址查询相应的以太网\",{\"1\":{\"297\":1}}],[\"地址之后\",{\"1\":{\"307\":1}}],[\"地址就是要转发到的目标地址\",{\"1\":{\"307\":1}}],[\"地址就是我们要转发到的目标地址\",{\"1\":{\"307\":1}}],[\"地址来标识网络上的设备\",{\"1\":{\"291\":1}}],[\"地址来寻找网络中互连的主机或路由器\",{\"1\":{\"187\":1}}],[\"地址来寻找局域网中的主机\",{\"1\":{\"187\":1}}],[\"地址变化了\",{\"1\":{\"281\":1}}],[\"地址不是正好\",{\"1\":{\"188\":1}}],[\"地址都绑定了\",{\"1\":{\"188\":1}}],[\"地址都转换\",{\"1\":{\"138\":1}}],[\"地址比较特殊\",{\"1\":{\"188\":1}}],[\"地址和\",{\"1\":{\"307\":1}}],[\"地址和端口号组成\",{\"1\":{\"204\":1}}],[\"地址和端口都相同\",{\"1\":{\"188\":1}}],[\"地址和端口\",{\"1\":{\"176\":1,\"180\":1}}],[\"地址和目标\",{\"1\":{\"136\":1,\"150\":1}}],[\"地址长度是\",{\"1\":{\"159\":1}}],[\"地址通常是内部的\",{\"1\":{\"156\":1}}],[\"地址基本上要在整个互联网范围内保持唯一\",{\"1\":{\"156\":1}}],[\"地址是由\",{\"1\":{\"156\":1}}],[\"地址是有个组织统一分配的\",{\"1\":{\"156\":1}}],[\"地址是xxxx\",{\"1\":{\"136\":1}}],[\"地址与路由控制\",{\"0\":{\"157\":1}}],[\"地址与私有\",{\"0\":{\"156\":1}}],[\"地址与自己的\",{\"1\":{\"136\":1}}],[\"地址按位计算\",{\"1\":{\"155\":1}}],[\"地址更加具有灵活性\",{\"1\":{\"155\":1}}],[\"地址被划分为两部分\",{\"1\":{\"155\":1}}],[\"地址中的\",{\"1\":{\"306\":2}}],[\"地址中只允许出现一次两个连续的冒号\",{\"1\":{\"159\":1}}],[\"地址中\",{\"1\":{\"153\":1}}],[\"地址类别\",{\"1\":{\"152\":1}}],[\"地址以每\",{\"1\":{\"151\":1}}],[\"地址有\",{\"1\":{\"145\":1}}],[\"地址为组播地址\",{\"1\":{\"139\":1}}],[\"地址为自己主机的\",{\"1\":{\"139\":1}}],[\"地址为公有地址\",{\"1\":{\"138\":1}}],[\"地址转换成公有\",{\"1\":{\"138\":1}}],[\"地址分配也可以由一个\",{\"1\":{\"137\":1}}],[\"地址快期后\",{\"1\":{\"137\":1}}],[\"地址租用期\",{\"1\":{\"137\":1}}],[\"地址及其\",{\"1\":{\"136\":1}}],[\"地址求\",{\"1\":{\"136\":2}}],[\"地址缓存起来\",{\"1\":{\"136\":1}}],[\"地址塞入\",{\"1\":{\"136\":1}}],[\"地址一致\",{\"1\":{\"136\":1}}],[\"地址的网络安全功能以及防止线路窃听的功能\",{\"1\":{\"159\":1}}],[\"地址的缓存是有一定期限的\",{\"1\":{\"136\":1}}],[\"地址的主机\",{\"1\":{\"136\":1}}],[\"地址的\",{\"1\":{\"136\":2}}],[\"地址的呢\",{\"1\":{\"136\":1}}],[\"地址后\",{\"1\":{\"136\":1}}],[\"地址或者端口变动了\",{\"1\":{\"111\":1}}],[\"地址\",{\"0\":{\"156\":1},\"1\":{\"111\":2,\"136\":9,\"137\":5,\"138\":4,\"139\":1,\"145\":1,\"151\":3,\"153\":1,\"155\":2,\"156\":1,\"157\":1,\"159\":1,\"188\":1,\"297\":1,\"303\":1,\"306\":1,\"307\":7}}],[\"地址总线\",{\"1\":{\"76\":2}}],[\"限制连接中所有\",{\"1\":{\"278\":1}}],[\"连续已确认并向上层应用提交的数据包offset\",{\"1\":{\"278\":1}}],[\"连接上传输\",{\"1\":{\"277\":1}}],[\"连接上的多个\",{\"1\":{\"113\":1}}],[\"连接将会一直处于\",{\"1\":{\"270\":1}}],[\"连接已经死亡\",{\"1\":{\"268\":1}}],[\"连接一方收到对方的零窗口通知\",{\"1\":{\"229\":1}}],[\"连接建立失败\",{\"1\":{\"213\":1}}],[\"连接数\",{\"1\":{\"205\":1}}],[\"连接中出现异常必须强制断开连接\",{\"1\":{\"201\":1}}],[\"连接中的所有请求\",{\"1\":{\"109\":1}}],[\"连接中的\",{\"1\":{\"109\":1}}],[\"连接发起方\",{\"1\":{\"193\":1}}],[\"连接的建立\",{\"1\":{\"298\":1}}],[\"连接的效果\",{\"1\":{\"251\":1}}],[\"连接的\",{\"1\":{\"191\":2}}],[\"连接的信息\",{\"1\":{\"181\":1}}],[\"连接是由内核维护的\",{\"1\":{\"198\":1}}],[\"连接是由四元组\",{\"1\":{\"111\":1,\"191\":1}}],[\"连接是断开的流程是什么\",{\"0\":{\"179\":1}}],[\"连接到来时\",{\"1\":{\"167\":1}}],[\"连接过多\",{\"1\":{\"164\":1}}],[\"连接都要占用一定内存\",{\"1\":{\"205\":1}}],[\"连接都要经过\",{\"1\":{\"106\":1}}],[\"连接都是一个文件\",{\"1\":{\"205\":1}}],[\"连接都将被重置\",{\"1\":{\"138\":1}}],[\"连接之后会一直保持这个连接\",{\"1\":{\"133\":1}}],[\"连接迁移\",{\"0\":{\"115\":1}}],[\"连接信息\",{\"1\":{\"114\":1,\"280\":1}}],[\"连接\",{\"0\":{\"174\":1,\"193\":1},\"1\":{\"106\":3,\"134\":1,\"204\":1}}],[\"连接状态\",{\"1\":{\"88\":1,\"238\":1,\"270\":1}}],[\"给每一个\",{\"1\":{\"277\":1}}],[\"给服务端加兼容逻辑就好了\",{\"1\":{\"213\":1}}],[\"歧义\",{\"1\":{\"275\":1}}],[\"掉进程后\",{\"1\":{\"269\":1}}],[\"看这个内核参数net\",{\"1\":{\"267\":1}}],[\"看看是不是发给自己的包\",{\"1\":{\"307\":1}}],[\"看看这个数字在\",{\"1\":{\"82\":1}}],[\"看看在实际项目中是用什么方式来避免伪共享的问题的\",{\"1\":{\"57\":1}}],[\"挥手过程中\",{\"1\":{\"262\":1}}],[\"引用计数\",{\"1\":{\"261\":1}}],[\"引入时间戳之后可以完全避免历史报文接收问题\",{\"1\":{\"246\":1}}],[\"引入第三方服务端就可以很方便的做各种鉴权校验\",{\"1\":{\"213\":1}}],[\"粗暴关闭\",{\"1\":{\"261\":1}}],[\"粗暴关闭vs优雅关闭\",{\"0\":{\"261\":1}}],[\"拿到对方下一次期望收到的序列号\",{\"1\":{\"251\":1}}],[\"累加\",{\"1\":{\"248\":1}}],[\"累计确认或者累计应答\",{\"1\":{\"221\":1}}],[\"万能公式\",{\"0\":{\"248\":1}}],[\"循环一次需要\",{\"1\":{\"246\":1}}],[\"微秒加\",{\"1\":{\"246\":1}}],[\"微信服务器在校验授权码有效性之后\",{\"1\":{\"45\":1}}],[\"微信服务器带着授权码回调到回调地址上\",{\"1\":{\"45\":1}}],[\"微信客户端将请求发送到微信服务器\",{\"1\":{\"45\":1}}],[\"尽最大可能避免历史报文被新的tcp连接接收到\",{\"1\":{\"246\":1}}],[\"丢失的数据包和重传的数据包\",{\"1\":{\"276\":1}}],[\"丢失了\",{\"1\":{\"245\":1,\"275\":1}}],[\"丢包时\",{\"1\":{\"109\":1}}],[\"倍\",{\"1\":{\"243\":1}}],[\"既然ip层会分片\",{\"0\":{\"242\":1}}],[\"既然这一位永远都是\",{\"1\":{\"82\":1}}],[\"哪些是已经被对方收到的\",{\"1\":{\"239\":1}}],[\"哪些数据没收到\",{\"1\":{\"235\":1}}],[\"知道对方的\",{\"1\":{\"307\":1}}],[\"知道\",{\"1\":{\"236\":1}}],[\"知道了这些信息\",{\"1\":{\"235\":1}}],[\"糊涂窗口综合症的现象是可以发生在发送方和接收方\",{\"1\":{\"230\":1}}],[\"糊涂窗口综合征\",{\"0\":{\"230\":1}}],[\"次过后接收窗口还是\",{\"1\":{\"229\":1}}],[\"次\",{\"1\":{\"229\":1}}],[\"次方\",{\"1\":{\"205\":3}}],[\"潜在的死锁现象\",{\"1\":{\"229\":1}}],[\"窗口停留直到丢失的数据包被重传接收\",{\"1\":{\"277\":1}}],[\"窗口探测的次数一般为\",{\"1\":{\"229\":1}}],[\"窗口关闭的潜在危险\",{\"1\":{\"229\":1}}],[\"窗口关闭\",{\"0\":{\"229\":1}}],[\"窗口大小由哪一方决定\",{\"0\":{\"222\":1}}],[\"窗口大小就是指无需等待确认应答\",{\"1\":{\"221\":1}}],[\"窗口大小\",{\"1\":{\"204\":1,\"230\":1}}],[\"变化如下\",{\"1\":{\"218\":1}}],[\"变量对应的\",{\"1\":{\"69\":1}}],[\"变量例子来说明总线嗅探的工作机制\",{\"1\":{\"68\":1}}],[\"变量的值\",{\"1\":{\"67\":1,\"68\":1,\"69\":2}}],[\"变量没有任何实际用途\",{\"1\":{\"57\":1}}],[\"变量就不会在同一个\",{\"1\":{\"57\":1}}],[\"变量\",{\"1\":{\"56\":2,\"82\":2}}],[\"认为这种情况不严重\",{\"1\":{\"218\":1}}],[\"认为数据报文经过\",{\"1\":{\"162\":1}}],[\"很容易产生各种兼容性问题\",{\"1\":{\"213\":1}}],[\"很容易把服务器资源耗尽\",{\"1\":{\"198\":1}}],[\"且双方也没有数据交互的情况下\",{\"1\":{\"270\":1}}],[\"且双方一直没有数据交互的情况下\",{\"1\":{\"270\":1}}],[\"且两端的软件版本跨度太大\",{\"1\":{\"213\":1}}],[\"且状态为\",{\"1\":{\"56\":1}}],[\"随机数是会基于时钟计时器递增的\",{\"1\":{\"246\":1}}],[\"随即生成一个随机数\",{\"1\":{\"241\":1}}],[\"随便一个人找你对账一下\",{\"1\":{\"213\":1}}],[\"随后\",{\"1\":{\"143\":1}}],[\"随后会启动\",{\"1\":{\"139\":1}}],[\"聊天软件消耗的资源越少\",{\"1\":{\"213\":1}}],[\"聊天软件还需要将数据从tcp的接收缓冲区里读出来\",{\"1\":{\"213\":1}}],[\"导致\",{\"1\":{\"281\":1}}],[\"导致整个ip报文被重传\",{\"1\":{\"242\":1}}],[\"导致服务端可能建立一个历史连接\",{\"1\":{\"239\":1}}],[\"导致更多的超时\",{\"1\":{\"233\":1}}],[\"导致没有丢包就会重传\",{\"1\":{\"233\":1}}],[\"导致软件崩溃闪退了\",{\"1\":{\"213\":1}}],[\"导致接收方无法正确解析数据边界\",{\"1\":{\"26\":1}}],[\"流控队列长度txqueuelen又不够大时\",{\"1\":{\"213\":1}}],[\"流量控制丢包\",{\"1\":{\"213\":1}}],[\"流量控制\",{\"0\":{\"227\":1},\"1\":{\"174\":1,\"278\":1}}],[\"流量控制的网络特性\",{\"1\":{\"112\":1}}],[\"历史连接\",{\"1\":{\"239\":1}}],[\"历史\",{\"1\":{\"212\":1}}],[\"拔掉网线之后\",{\"0\":{\"211\":1}}],[\"允许处于\",{\"1\":{\"210\":1}}],[\"小时\",{\"1\":{\"246\":1}}],[\"小于\",{\"1\":{\"209\":1,\"230\":1}}],[\"小数点右侧的数字\",{\"1\":{\"82\":1}}],[\"小数点后面的指数幂是负数\",{\"1\":{\"81\":1}}],[\"小数是一个特例\",{\"1\":{\"81\":1}}],[\"小数部分\",{\"1\":{\"81\":1}}],[\"小数部分的转换不同于整数部分\",{\"1\":{\"81\":1}}],[\"固定长度的消息\",{\"1\":{\"208\":1}}],[\"固定数据长度\",{\"1\":{\"26\":1}}],[\"单个进程可打开的最大数量\",{\"1\":{\"205\":1}}],[\"单播地址\",{\"1\":{\"159\":1}}],[\"非法\",{\"1\":{\"266\":1}}],[\"非冗余和按序的\",{\"1\":{\"202\":1}}],[\"非对称加密的用途主要在于通过\",{\"1\":{\"128\":1}}],[\"非对称加密\",{\"1\":{\"128\":1}}],[\"段\",{\"1\":{\"201\":1}}],[\"希望断开连接\",{\"1\":{\"201\":1}}],[\"期望下一个收到的序列号\",{\"1\":{\"265\":1,\"266\":1}}],[\"期望\",{\"1\":{\"201\":1,\"248\":1}}],[\"期间交互了什么\",{\"0\":{\"129\":1}}],[\"期间\",{\"1\":{\"77\":1,\"262\":1}}],[\"缓冲区的内存并不是越大越好\",{\"1\":{\"198\":1}}],[\"缓存大小中的最小值时\",{\"1\":{\"230\":1}}],[\"缓存空间\",{\"1\":{\"230\":1}}],[\"缓存的内容将被清除\",{\"1\":{\"136\":1}}],[\"缓存一致性\",{\"1\":{\"68\":1}}],[\"缓存一致性问题\",{\"0\":{\"67\":1}}],[\"缓存命中率高就意味着\",{\"1\":{\"53\":1}}],[\"缓存命中率越高的话\",{\"1\":{\"50\":1}}],[\"缓存块\",{\"1\":{\"49\":3}}],[\"操作各一次\",{\"1\":{\"197\":1}}],[\"操作系统缓冲区和滑动窗口的关系\",{\"0\":{\"228\":1}}],[\"操作系统在收到\",{\"1\":{\"207\":1}}],[\"操作系统不会对消息进行拆分\",{\"1\":{\"207\":1}}],[\"操作系统的内存是有限的\",{\"1\":{\"205\":1}}],[\"操作系统通常会把第一次通过\",{\"1\":{\"136\":1}}],[\"操作系统收到了中断请求\",{\"1\":{\"71\":1}}],[\"操作系统收到硬件的中断请求\",{\"1\":{\"71\":1}}],[\"半关闭\",{\"1\":{\"197\":1}}],[\"半连接队列的情况下成功建立连接\",{\"1\":{\"209\":1}}],[\"半连接队列满了\",{\"1\":{\"169\":1,\"210\":1}}],[\"半连接队列\",{\"1\":{\"169\":2,\"177\":1}}],[\"半连接状态\",{\"1\":{\"32\":1,\"238\":1,\"300\":1}}],[\"读\",{\"1\":{\"197\":1}}],[\"读取数据\",{\"1\":{\"176\":1}}],[\"读取数据的时候\",{\"1\":{\"49\":1,\"176\":1}}],[\"读取就好了\",{\"1\":{\"52\":1}}],[\"读取到指令\",{\"1\":{\"52\":1}}],[\"读取\",{\"1\":{\"49\":1,\"113\":1}}],[\"关闭只是让\",{\"1\":{\"261\":1}}],[\"关闭发送方向和读取方向\",{\"1\":{\"261\":1}}],[\"关闭套接字的读和写两个方向\",{\"1\":{\"197\":1}}],[\"关闭连接的\",{\"1\":{\"197\":2}}],[\"关闭它的套接字\",{\"1\":{\"179\":1}}],[\"孤儿连接\",{\"1\":{\"197\":1}}],[\"孤儿进程\",{\"1\":{\"20\":1}}],[\"跟据路由表\",{\"1\":{\"307\":1}}],[\"跟据ip头部进行包的转发\",{\"1\":{\"307\":1}}],[\"跟据源ip\",{\"1\":{\"241\":1}}],[\"跟据服务器的繁忙程度修改sny重传次数\",{\"1\":{\"196\":1}}],[\"跟据数据包的头部\",{\"1\":{\"187\":1}}],[\"唯一确认的\",{\"1\":{\"191\":1}}],[\"存在冲突\",{\"1\":{\"190\":1}}],[\"存储数据的基本单位是字节\",{\"1\":{\"74\":1}}],[\"存储的区域是线性的\",{\"1\":{\"74\":1}}],[\"存储器的层次结构\",{\"0\":{\"78\":1}}],[\"存储器\",{\"1\":{\"73\":1}}],[\"错误是\",{\"1\":{\"188\":1,\"192\":1}}],[\"受到攻击的服务器可能会因为cpu资源耗尽导致没能响应正经请求\",{\"1\":{\"185\":1}}],[\"叫ack攻击\",{\"1\":{\"185\":1}}],[\"耗cpu\",{\"1\":{\"185\":1}}],[\"憨憨地跑去解码\",{\"1\":{\"185\":1}}],[\"利用这一点\",{\"1\":{\"185\":1}}],[\"凡事皆有利弊\",{\"1\":{\"185\":1}}],[\"嗷嗷等待着第三次握手的到来\",{\"1\":{\"183\":1}}],[\"他本质是个链表\",{\"1\":{\"183\":1}}],[\"参数\",{\"1\":{\"209\":1}}],[\"参与\",{\"1\":{\"182\":1}}],[\"参考模型中处于第三层\",{\"1\":{\"150\":1}}],[\"了\",{\"0\":{\"179\":1},\"1\":{\"180\":1,\"183\":1,\"223\":1,\"270\":1}}],[\"成多个的\",{\"1\":{\"203\":1}}],[\"成功返回是在三次握手成功之后\",{\"1\":{\"178\":1}}],[\"成功返回是在第二次握手\",{\"1\":{\"178\":1}}],[\"成员关系报告报文\",{\"1\":{\"139\":1}}],[\"处于连接中的tcp连接\",{\"1\":{\"249\":1}}],[\"处于\",{\"1\":{\"177\":2}}],[\"处理客户端的授权请求\",{\"1\":{\"43\":1}}],[\"队列里的每一个元素就是一个\",{\"1\":{\"207\":1}}],[\"队列长度\",{\"1\":{\"177\":1}}],[\"队列\",{\"1\":{\"177\":3}}],[\"队头阻塞\",{\"0\":{\"109\":1},\"1\":{\"108\":1}}],[\"队头阻塞问题的\",{\"0\":{\"277\":1}}],[\"队头阻塞问题\",{\"1\":{\"100\":1}}],[\"待处理完数据后\",{\"1\":{\"176\":1}}],[\"返回一个新创建的用于传输的\",{\"1\":{\"176\":1}}],[\"返回证书的有效状态\",{\"1\":{\"121\":1}}],[\"绑定的\",{\"1\":{\"188\":1}}],[\"绑定的地址是其他地址和端口\",{\"1\":{\"188\":1}}],[\"绑定的地址是\",{\"1\":{\"188\":1}}],[\"绑定在指定的\",{\"1\":{\"176\":1}}],[\"绑定端口\",{\"1\":{\"167\":1}}],[\"针对开启了tcp时间戳的tcp\",{\"1\":{\"265\":1}}],[\"针对收到三次相同的报文\",{\"1\":{\"234\":1}}],[\"针对这个问题\",{\"1\":{\"193\":1}}],[\"针对tcp应该如何socket编程\",{\"0\":{\"176\":1}}],[\"针对在同一个\",{\"1\":{\"57\":1}}],[\"层报文\",{\"1\":{\"303\":1,\"304\":1}}],[\"层队头阻塞\",{\"1\":{\"277\":1}}],[\"层为了保证数据的有序性\",{\"1\":{\"277\":1}}],[\"层\",{\"1\":{\"252\":1}}],[\"层组装完数据\",{\"1\":{\"174\":1}}],[\"层进行分片\",{\"1\":{\"174\":1}}],[\"支持一对一\",{\"1\":{\"174\":1}}],[\"检查到即使\",{\"1\":{\"212\":1}}],[\"检查\",{\"1\":{\"210\":2,\"307\":1}}],[\"检查网络设备\",{\"1\":{\"170\":1}}],[\"检查防火墙设置\",{\"1\":{\"169\":1}}],[\"函数来关闭连接\",{\"1\":{\"261\":1}}],[\"函数来选择端口会比较好\",{\"1\":{\"192\":1}}],[\"函数读取数据\",{\"1\":{\"198\":1}}],[\"函数的一方的连接叫做\",{\"1\":{\"197\":1}}],[\"函数的时候\",{\"1\":{\"189\":1}}],[\"函数时才起作用\",{\"1\":{\"193\":1}}],[\"函数时\",{\"1\":{\"193\":1}}],[\"函数\",{\"1\":{\"192\":1,\"261\":2}}],[\"函数中的\",{\"1\":{\"169\":1}}],[\"函数关闭连接\",{\"1\":{\"167\":1}}],[\"攻击者在短时内向服务端发送大量的syn报文\",{\"1\":{\"169\":1}}],[\"​\",{\"1\":{\"169\":1,\"246\":2}}],[\"获取对方的mac地址\",{\"1\":{\"304\":1}}],[\"获取已连接的\",{\"1\":{\"167\":1}}],[\"获取的\",{\"1\":{\"136\":1}}],[\"注册到\",{\"1\":{\"167\":2}}],[\"注意这些都是\",{\"1\":{\"138\":1}}],[\"注意不是存储了下一条要执行的指令\",{\"1\":{\"75\":1}}],[\"注意权重值并不是优先级的值\",{\"1\":{\"60\":1}}],[\"注意前面的点号\",{\"1\":{\"46\":1}}],[\"灰常合理\",{\"1\":{\"166\":1}}],[\"谁是主动关闭方\",{\"1\":{\"166\":2}}],[\"释放连接\",{\"1\":{\"166\":1}}],[\"什么情况下会出现三次挥手\",{\"0\":{\"262\":1}}],[\"什么时syn超时\",{\"0\":{\"170\":1}}],[\"什么场景下服务端会主动断开连接呢\",{\"1\":{\"166\":1}}],[\"什么是\",{\"1\":{\"262\":1}}],[\"什么是拥塞窗口\",{\"1\":{\"215\":1}}],[\"什么是tcp连接\",{\"0\":{\"204\":1}}],[\"什么是tcp协议\",{\"0\":{\"203\":1}}],[\"什么是syn攻击\",{\"0\":{\"169\":1}}],[\"什么是d类\",{\"0\":{\"154\":1}}],[\"什么是a\",{\"0\":{\"153\":1}}],[\"什么是127\",{\"0\":{\"145\":1}}],[\"什么是中断\",{\"0\":{\"70\":1}}],[\"什么是oauth2\",{\"0\":{\"43\":1}}],[\"什么是restful风格\",{\"0\":{\"41\":1}}],[\"占满了所有端口资源\",{\"1\":{\"164\":1}}],[\"占用服务器的内存太多\",{\"1\":{\"122\":1}}],[\"占用了此位置\",{\"1\":{\"66\":1}}],[\"过段时间再减少缓存\",{\"1\":{\"228\":1}}],[\"过多有什么危害\",{\"0\":{\"164\":1}}],[\"过程就是\",{\"1\":{\"166\":1}}],[\"过程如下\",{\"1\":{\"81\":1,\"82\":1}}],[\"过程的时候\",{\"1\":{\"80\":1}}],[\"删除该选项字段使的\",{\"1\":{\"160\":1}}],[\"任播地址\",{\"1\":{\"159\":1}}],[\"任务永远都是普通任务\",{\"1\":{\"62\":1}}],[\"任务的优先级就越高\",{\"1\":{\"62\":1}}],[\"省略\",{\"1\":{\"159\":1}}],[\"省略了授权码的交换步骤\",{\"1\":{\"44\":1}}],[\"减轻了路由器负荷\",{\"1\":{\"159\":1}}],[\"减少\",{\"1\":{\"169\":1,\"209\":1}}],[\"减少了消息传递的次数\",{\"1\":{\"107\":1}}],[\"减少了数据写回内存的频率\",{\"1\":{\"66\":1}}],[\"减少重定向次数\",{\"1\":{\"98\":1}}],[\"减少整体响应时间\",{\"1\":{\"95\":1}}],[\"减少数据库访问次数\",{\"1\":{\"47\":1}}],[\"若要传输在以太网链路\",{\"1\":{\"158\":1}}],[\"经过分片之后的\",{\"1\":{\"158\":1}}],[\"环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址\",{\"1\":{\"157\":1}}],[\"互联网名称与数字地址分配机构\",{\"1\":{\"156\":1}}],[\"人员管理\",{\"1\":{\"156\":1}}],[\"私有\",{\"1\":{\"156\":1}}],[\"私钥加密\",{\"1\":{\"128\":2}}],[\"栋\",{\"1\":{\"156\":2}}],[\"做\",{\"1\":{\"210\":1}}],[\"做子网划分后的\",{\"1\":{\"155\":1}}],[\"做进一步分析该网络包的源头是不是非法地址\",{\"1\":{\"72\":1}}],[\"未做子网划分的\",{\"1\":{\"155\":1}}],[\"子网网络地址＋子网主机地址\",{\"1\":{\"155\":1}}],[\"子网网络地址和子网主机地址\",{\"1\":{\"155\":1}}],[\"子网划分实际上是将主机地址分为两个部分\",{\"1\":{\"155\":1}}],[\"子网掩码\",{\"1\":{\"137\":1,\"155\":1}}],[\"掩码的意思就是掩盖掉主机号\",{\"1\":{\"155\":1}}],[\"暂时未使用\",{\"1\":{\"154\":1}}],[\"隔开\",{\"1\":{\"151\":1,\"159\":2}}],[\"$$\",{\"1\":{\"215\":2}}],[\"$\",{\"1\":{\"148\":1}}],[\"执行accept\",{\"1\":{\"182\":1}}],[\"执行\",{\"1\":{\"148\":1}}],[\"执行该指令就只需要从\",{\"1\":{\"52\":1}}],[\"根域的\",{\"1\":{\"295\":1}}],[\"根域是在最顶层\",{\"1\":{\"295\":1}}],[\"根\",{\"1\":{\"295\":1}}],[\"根本就没有出网络\",{\"1\":{\"147\":1}}],[\"根据大多数\",{\"1\":{\"166\":1}}],[\"根据该记录将\",{\"1\":{\"157\":1}}],[\"根据这个标志位\",{\"1\":{\"143\":1}}],[\"根据请求负荷\",{\"1\":{\"90\":1}}],[\"根据任务的优先级以及响应要求\",{\"1\":{\"58\":1}}],[\"根据\",{\"1\":{\"57\":1,\"103\":1,\"227\":1}}],[\"链路和路由器等\",{\"1\":{\"170\":1}}],[\"链路层然后将帧广播到所有的网络中设备\",{\"1\":{\"137\":1}}],[\"链表\",{\"1\":{\"147\":1}}],[\"创建一个全连接队列\",{\"1\":{\"169\":1}}],[\"创建服务端\",{\"1\":{\"167\":1}}],[\"创建\",{\"1\":{\"146\":1}}],[\"创建好了\",{\"1\":{\"146\":1}}],[\"顺着网卡就发出去了\",{\"1\":{\"146\":1}}],[\"判断目的机器是否可达\",{\"1\":{\"145\":1}}],[\"判断所发送的数据包是否已经成功到达对端的一种消息\",{\"1\":{\"142\":1}}],[\"没办法保证双方的初始序列号都能被确认接收\",{\"1\":{\"239\":1}}],[\"没什么道理\",{\"1\":{\"145\":1}}],[\"没有丝毫卡顿感\",{\"1\":{\"281\":1}}],[\"没有数据要发送\",{\"1\":{\"262\":1}}],[\"没有效率\",{\"1\":{\"233\":1}}],[\"没有收到对方的\",{\"1\":{\"233\":1}}],[\"没有accpet\",{\"0\":{\"182\":1}}],[\"没有listen可以建立tcp连接吗\",{\"0\":{\"181\":1}}],[\"没有边界\",{\"1\":{\"174\":1}}],[\"没有广播地址\",{\"1\":{\"159\":1}}],[\"没有此类型\",{\"1\":{\"159\":1}}],[\"没有任何问题\",{\"1\":{\"156\":1}}],[\"没有使用长连接\",{\"1\":{\"166\":1}}],[\"没有使用\",{\"1\":{\"150\":1}}],[\"没有直连\",{\"1\":{\"150\":1}}],[\"没有人知道当某些应用程序监听此类端口时会发生什么\",{\"1\":{\"143\":1}}],[\"没有缓存该数据\",{\"1\":{\"69\":1}}],[\"没有该数据\",{\"1\":{\"69\":1}}],[\"没有特意去指定优先级的话\",{\"1\":{\"62\":1}}],[\"没有创建线程的进程\",{\"1\":{\"58\":1}}],[\"开销较小\",{\"1\":{\"174\":1}}],[\"开启2msl计时器\",{\"1\":{\"259\":1}}],[\"开启了\",{\"1\":{\"193\":1,\"262\":1}}],[\"开启\",{\"1\":{\"169\":1,\"209\":2}}],[\"开头的都属于回环地址\",{\"1\":{\"145\":1}}],[\"开始计时的\",{\"1\":{\"162\":1}}],[\"开始按照顺序递增的同时发送\",{\"1\":{\"143\":1}}],[\"开始\",{\"1\":{\"142\":1}}],[\"开始编号的\",{\"1\":{\"74\":1}}],[\"途中的路由器不会对大数据包进行分片\",{\"1\":{\"143\":1}}],[\"遇到第二个路由器也牺牲了\",{\"1\":{\"143\":1}}],[\"遇到遍历数组的情况时\",{\"1\":{\"51\":1}}],[\"作用是\",{\"1\":{\"190\":1}}],[\"作用二\",{\"1\":{\"143\":1}}],[\"作用一\",{\"1\":{\"143\":1}}],[\"作为传输媒介\",{\"0\":{\"287\":1}}],[\"作为环回地址\",{\"1\":{\"157\":1}}],[\"作为一个小软件\",{\"1\":{\"145\":1}}],[\"作为标识符\",{\"1\":{\"142\":1}}],[\"作为源\",{\"1\":{\"137\":1}}],[\"作为客户端椭圆曲线的私钥\",{\"1\":{\"129\":1}}],[\"作为服务端的私钥\",{\"1\":{\"129\":1}}],[\"作为例子\",{\"1\":{\"82\":1}}],[\"作为下一位\",{\"1\":{\"81\":1}}],[\"作为二进制的一位\",{\"1\":{\"81\":1}}],[\"序列号是一个\",{\"1\":{\"246\":1}}],[\"序列号在整个tcp连接的生命周期中都是递增的\",{\"1\":{\"246\":1}}],[\"序列号的作用\",{\"1\":{\"239\":1}}],[\"序列号和确认号是如何变化的\",{\"0\":{\"247\":1}}],[\"序列号和窗口大小称为连接\",{\"1\":{\"204\":1}}],[\"序列号和初始化序列号并不是无限递增的\",{\"1\":{\"163\":1,\"246\":1}}],[\"序列号\",{\"1\":{\"201\":2,\"204\":1,\"246\":1,\"248\":2,\"265\":1,\"266\":1}}],[\"序列号从\",{\"1\":{\"142\":1}}],[\"序号为接收到的请求数据包中的序号\",{\"1\":{\"142\":1}}],[\"序号\",{\"1\":{\"142\":1}}],[\"回包\",{\"1\":{\"230\":1}}],[\"回到\",{\"1\":{\"146\":1}}],[\"回送响应消息\",{\"1\":{\"142\":1}}],[\"回送响应消息数据包\",{\"1\":{\"142\":1}}],[\"回送响应数据包的类型字段为\",{\"1\":{\"142\":1}}],[\"回送请求消息数据包\",{\"1\":{\"142\":1}}],[\"回送消息用于进行通信的主机或路由器之间\",{\"1\":{\"142\":1}}],[\"回送消息\",{\"1\":{\"142\":1}}],[\"回显配置的参数\",{\"1\":{\"137\":1}}],[\"仍然被认为是一个有效的\",{\"1\":{\"189\":1}}],[\"仍然是组\",{\"1\":{\"139\":1}}],[\"仍然使用\",{\"1\":{\"101\":1}}],[\"离开组播组的情况二\",{\"1\":{\"139\":1}}],[\"离开组播组的情况一\",{\"1\":{\"139\":1}}],[\"离组报文\",{\"1\":{\"139\":2}}],[\"目的是确保每个tcp连接都具有唯一的起始序列号\",{\"1\":{\"246\":1}}],[\"目的是尽快将丢失的数据包发送给目标\",{\"1\":{\"219\":1}}],[\"目的ip\",{\"1\":{\"241\":1}}],[\"目的ip地址\",{\"1\":{\"191\":1}}],[\"目的地址\",{\"1\":{\"205\":1}}],[\"目的端口\",{\"1\":{\"191\":1,\"205\":1}}],[\"目的\",{\"1\":{\"139\":1,\"164\":2}}],[\"目标地址和子网掩码都是\",{\"1\":{\"303\":1}}],[\"目标地址\",{\"1\":{\"303\":1}}],[\"目标主机收到后\",{\"1\":{\"174\":2}}],[\"目标主机\",{\"1\":{\"142\":1}}],[\"目标端口号\",{\"1\":{\"143\":1}}],[\"目标端口\",{\"1\":{\"111\":1,\"241\":1}}],[\"目标\",{\"1\":{\"111\":1}}],[\"秒后\",{\"1\":{\"243\":4}}],[\"秒内都没有再发起新的请求\",{\"1\":{\"166\":1}}],[\"秒为间隔连续发送\",{\"1\":{\"139\":2}}],[\"秒\",{\"1\":{\"139\":1,\"162\":2,\"193\":1,\"229\":1,\"243\":1}}],[\"常规查询报文\",{\"1\":{\"139\":1}}],[\"常见的网络分层模型\",{\"0\":{\"282\":1}}],[\"常见的寄存器种类\",{\"1\":{\"75\":1}}],[\"常见的有寄存器\",{\"1\":{\"75\":1}}],[\"封装成数据帧发送到网络上\",{\"1\":{\"291\":1}}],[\"封装\",{\"1\":{\"139\":1}}],[\"查询报文类型\",{\"0\":{\"142\":1},\"1\":{\"139\":1}}],[\"报告延迟计时器\",{\"1\":{\"139\":1}}],[\"报告发送过程中\",{\"1\":{\"139\":1}}],[\"报文多加几个头部字段\",{\"1\":{\"274\":1}}],[\"报文给对方\",{\"1\":{\"270\":1}}],[\"报文给对端\",{\"1\":{\"197\":1}}],[\"报文给服务端\",{\"1\":{\"261\":1}}],[\"报文一定得调用关闭连接的函数\",{\"1\":{\"260\":1}}],[\"报文里的序列号是合法的\",{\"1\":{\"250\":1}}],[\"报文里的\",{\"1\":{\"250\":1}}],[\"报文等\",{\"1\":{\"248\":1}}],[\"报文传给接收端主机\",{\"1\":{\"248\":1}}],[\"报文或者\",{\"1\":{\"248\":2}}],[\"报文来中断连接\",{\"1\":{\"229\":1}}],[\"报文中的序列号知道\",{\"1\":{\"239\":1}}],[\"报文中的\",{\"1\":{\"226\":1}}],[\"报文丢失了\",{\"1\":{\"212\":1}}],[\"报文可能会终止后面相同四元组的连接\",{\"1\":{\"212\":1}}],[\"报文可以加密传输\",{\"1\":{\"126\":1}}],[\"报文进行传输\",{\"1\":{\"208\":1}}],[\"报文进行应答\",{\"1\":{\"137\":1}}],[\"报文后\",{\"1\":{\"207\":1,\"250\":1}}],[\"报文就是一个用户消息的边界\",{\"1\":{\"207\":1}}],[\"报文就会丢弃\",{\"1\":{\"169\":1}}],[\"报文会自动丢弃\",{\"1\":{\"203\":1}}],[\"报文没有收到的时候\",{\"1\":{\"203\":1}}],[\"报文是什么类型的报文\",{\"1\":{\"248\":1}}],[\"报文是不会有重传的\",{\"1\":{\"245\":1}}],[\"报文是\",{\"1\":{\"203\":1}}],[\"报文的序列号\",{\"1\":{\"250\":1}}],[\"报文的序列号在对方的接收窗口内\",{\"1\":{\"212\":1}}],[\"报文的时间戳即使过期了\",{\"1\":{\"212\":1}}],[\"报文的过程中\",{\"1\":{\"197\":1}}],[\"报文的目的地址是\",{\"1\":{\"139\":1}}],[\"报文段的序列号加一\",{\"1\":{\"300\":1}}],[\"报文段是一个连接请求\",{\"1\":{\"299\":1}}],[\"报文段确认连接建立\",{\"1\":{\"170\":1}}],[\"报文段\",{\"1\":{\"170\":1}}],[\"报文段到服务器\",{\"1\":{\"170\":1}}],[\"报文数量\",{\"1\":{\"139\":1}}],[\"报文采用\",{\"1\":{\"139\":1}}],[\"报文向路由器申请加入和退出组播组\",{\"1\":{\"139\":1}}],[\"报文\",{\"1\":{\"137\":1,\"179\":2,\"180\":1,\"197\":1,\"203\":2,\"207\":1,\"208\":1,\"248\":5,\"249\":1,\"250\":1,\"251\":1,\"260\":1,\"261\":3,\"269\":1}}],[\"报文对\",{\"1\":{\"137\":1}}],[\"报文构成\",{\"1\":{\"106\":1}}],[\"报文主体\",{\"1\":{\"91\":1}}],[\"报文body\",{\"1\":{\"90\":1}}],[\"穿越技术拥有这样的功能\",{\"1\":{\"138\":1}}],[\"穿透技术中\",{\"1\":{\"138\":1}}],[\"穿透技术\",{\"1\":{\"138\":1}}],[\"普及率比较慢的一个原因\",{\"1\":{\"159\":1}}],[\"普及速度还需要一些时间\",{\"1\":{\"138\":1}}],[\"普通任务的调度类是\",{\"1\":{\"62\":1}}],[\"普通任务使用的调度策略\",{\"1\":{\"59\":1}}],[\"普通任务\",{\"1\":{\"58\":1}}],[\"外部无法主动与\",{\"1\":{\"138\":1}}],[\"令客户端\",{\"1\":{\"138\":1}}],[\"生成ip头部之后\",{\"1\":{\"291\":1}}],[\"生成一个\",{\"1\":{\"138\":1}}],[\"生成客户端的椭圆曲线公钥\",{\"1\":{\"129\":1}}],[\"路由\",{\"1\":{\"283\":1}}],[\"路由控制表中记录着网络地址与下一步应该发送至路由器的地址\",{\"1\":{\"157\":1}}],[\"路由器的各个端口都具有\",{\"1\":{\"307\":1}}],[\"路由器的转换表\",{\"1\":{\"138\":1}}],[\"路由器和交换机是有区别的\",{\"1\":{\"307\":1}}],[\"路由器发送包\",{\"1\":{\"307\":1}}],[\"路由器中的模块会将电信号转成数字信号\",{\"1\":{\"307\":1}}],[\"路由器接受包\",{\"1\":{\"307\":1}}],[\"路由器会去掉包mac头部\",{\"1\":{\"307\":1}}],[\"路由器会直接丢弃这些报文\",{\"1\":{\"198\":1}}],[\"路由器会周期性发送目的地址为\",{\"1\":{\"139\":1}}],[\"路由器是不会进行重组的\",{\"1\":{\"158\":1}}],[\"路由器认为该网段中已经没有\",{\"1\":{\"139\":1}}],[\"路由器收到该报文后\",{\"1\":{\"139\":1}}],[\"路由器收到主机的成员关系报文后\",{\"1\":{\"139\":1}}],[\"路由器知道该网络中仍然存在该组播组的成员\",{\"1\":{\"139\":1}}],[\"路由器\",{\"0\":{\"307\":1},\"1\":{\"139\":1}}],[\"路由器后续就会转发组播包到对应的主机了\",{\"1\":{\"139\":1}}],[\"路由器表\",{\"1\":{\"139\":1}}],[\"路由器就会记录\",{\"1\":{\"139\":1}}],[\"路由器重启了\",{\"1\":{\"138\":1}}],[\"路由器又不会转发广播包\",{\"1\":{\"137\":1}}],[\"路由表中加入该组播组\",{\"1\":{\"139\":1}}],[\"路由表\",{\"1\":{\"136\":1}}],[\"全部\",{\"1\":{\"223\":1}}],[\"全连接里队列\",{\"1\":{\"183\":1}}],[\"全连接队列满了\",{\"1\":{\"210\":1}}],[\"全连接队列溢出被丢弃\",{\"1\":{\"209\":1}}],[\"全连接队列被设计成链表\",{\"1\":{\"183\":1}}],[\"全连接队列\",{\"1\":{\"169\":1,\"177\":1}}],[\"全为\",{\"1\":{\"153\":1}}],[\"全称是\",{\"1\":{\"139\":1}}],[\"全程都是使用\",{\"1\":{\"137\":1}}],[\"全栈开发\",{\"1\":{\"10\":1}}],[\"广播地址是\",{\"1\":{\"153\":1}}],[\"广播地址\",{\"1\":{\"137\":1,\"153\":1}}],[\"广播通信\",{\"1\":{\"137\":2}}],[\"端口时\",{\"1\":{\"188\":1}}],[\"端口信息\",{\"1\":{\"181\":1}}],[\"端口不可达\",{\"1\":{\"143\":1}}],[\"端口号一起进行转换\",{\"1\":{\"138\":1}}],[\"端口\",{\"1\":{\"137\":2,\"210\":1}}],[\"端口的过程\",{\"1\":{\"133\":1}}],[\"求得下一跳的\",{\"1\":{\"136\":1}}],[\"然会向服务端发送一个带有自己初始化的随机序列号\",{\"1\":{\"238\":1}}],[\"然而\",{\"1\":{\"136\":1}}],[\"然后路由表查询转发目标\",{\"1\":{\"307\":1}}],[\"然后会\",{\"0\":{\"293\":1}}],[\"然后生产http请求消息\",{\"0\":{\"293\":1}}],[\"然后与对方进行\",{\"1\":{\"270\":1}}],[\"然后客户端发现不是自己的\",{\"1\":{\"266\":1}}],[\"然后客户端对服务端发起了连接建立\",{\"1\":{\"180\":1}}],[\"然后就会查看这个报文\",{\"1\":{\"263\":1}}],[\"然后就可以正常使用该端口了\",{\"1\":{\"193\":1}}],[\"然后发出\",{\"1\":{\"261\":1}}],[\"然后发送方就可以根据接收端和本端窗口大小继续发送数据\",{\"1\":{\"27\":1}}],[\"然后内核会释放连接\",{\"1\":{\"261\":1}}],[\"然后用这个确认号作为\",{\"1\":{\"250\":1}}],[\"然后用这个条目对外通信\",{\"1\":{\"138\":1}}],[\"然后服务端处于syn\",{\"1\":{\"238\":1}}],[\"然后悄悄地丢弃\",{\"1\":{\"197\":1}}],[\"然后模块处理之后跟据端口号发送给对应的应用程序\",{\"1\":{\"187\":1}}],[\"然后将序列号填充到伪造的\",{\"1\":{\"251\":1}}],[\"然后将信息发出\",{\"1\":{\"181\":1}}],[\"然后将这个cookie值返回给客户端\",{\"1\":{\"169\":1}}],[\"然后添加到accept队列\",{\"1\":{\"169\":1}}],[\"然后顺着数据链路层\",{\"1\":{\"147\":1}}],[\"然后进入传输层\",{\"1\":{\"146\":1}}],[\"然后对于每个下一个探针\",{\"1\":{\"143\":1}}],[\"然后自己建立端口映射条目\",{\"1\":{\"138\":1}}],[\"然后自增排列\",{\"1\":{\"74\":1}}],[\"然后使用它加密报文\",{\"1\":{\"129\":2}}],[\"然后在计算时会自动把这个\",{\"1\":{\"82\":1}}],[\"然后继续取小数部分乘以\",{\"1\":{\"81\":1}}],[\"然后通过\",{\"1\":{\"76\":1}}],[\"然后立即执行中断处理程序\",{\"1\":{\"72\":1}}],[\"然后调用内核中的中断处理程序来响应请求\",{\"1\":{\"71\":1}}],[\"然后每个\",{\"1\":{\"68\":1}}],[\"然后把小数点\",{\"1\":{\"82\":1}}],[\"然后把\",{\"1\":{\"67\":1}}],[\"然后再一路顺藤摸瓜找到位于下层的某台目标\",{\"1\":{\"295\":1}}],[\"然后再发送出去给源主机\",{\"1\":{\"142\":1}}],[\"然后再将这个设备接入到网络\",{\"1\":{\"136\":1}}],[\"然后再将结果返回给客户端\",{\"1\":{\"46\":1}}],[\"然后再更新当前\",{\"1\":{\"69\":1}}],[\"然后再把这个\",{\"1\":{\"66\":1}}],[\"然后再把当前要写入的数据写入到\",{\"1\":{\"66\":1}}],[\"然后再把当前要写入的数据\",{\"1\":{\"66\":1}}],[\"然后从\",{\"1\":{\"61\":1}}],[\"然后\",{\"1\":{\"56\":2,\"69\":2,\"244\":1}}],[\"然后第三方网站或应用程序带着这个授权码向微信服务器请求令牌\",{\"1\":{\"45\":1}}],[\"反过来将二进制数组复原成结构体的过程叫反序列化\",{\"1\":{\"133\":1}}],[\"长链接进行数据交互\",{\"1\":{\"133\":1}}],[\"长连接上最大能处理的请求数量\",{\"1\":{\"166\":1}}],[\"长连接的请求数量达到上限\",{\"1\":{\"166\":1}}],[\"长连接的特点是\",{\"1\":{\"88\":1}}],[\"长连接超时\",{\"1\":{\"166\":1}}],[\"长连接\",{\"1\":{\"88\":1,\"95\":1,\"252\":1}}],[\"底层连接形式\",{\"1\":{\"133\":1}}],[\"去掉了包头校验和\",{\"1\":{\"159\":1}}],[\"去保存服务名和ip信息\",{\"1\":{\"133\":1}}],[\"去做\",{\"1\":{\"72\":1}}],[\"找到服务对应的\",{\"1\":{\"133\":1}}],[\"三个材料生成的\",{\"1\":{\"129\":1}}],[\"三次握手时\",{\"1\":{\"213\":1}}],[\"三次握手过程\",{\"1\":{\"177\":1}}],[\"三次握手建立连接之后\",{\"1\":{\"134\":1}}],[\"三次握手的目的是确认双方都有发送和接受的能力\",{\"1\":{\"33\":1,\"301\":1}}],[\"三次握手\",{\"0\":{\"30\":1}}],[\"签名算法使用\",{\"1\":{\"129\":1}}],[\"签名算法\",{\"1\":{\"129\":2}}],[\"条件二\",{\"1\":{\"230\":1}}],[\"条件一\",{\"1\":{\"230\":1}}],[\"条件之一\",{\"1\":{\"129\":3}}],[\"条件语句\",{\"1\":{\"52\":1}}],[\"版本\",{\"1\":{\"129\":2}}],[\"摘要算法\",{\"1\":{\"128\":1,\"129\":2}}],[\"摘要算法+数字签名\",{\"1\":{\"128\":1}}],[\"公式二\",{\"1\":{\"248\":1}}],[\"公式一\",{\"1\":{\"248\":1}}],[\"公网\",{\"1\":{\"156\":1}}],[\"公有ip\",{\"1\":{\"156\":1}}],[\"公有\",{\"0\":{\"156\":1},\"1\":{\"156\":2}}],[\"公钥解密\",{\"1\":{\"128\":2}}],[\"公钥和私钥可以双向解密\",{\"1\":{\"128\":1}}],[\"公钥加密私钥解密\",{\"1\":{\"128\":1}}],[\"公平性最重要\",{\"1\":{\"60\":1}}],[\"加强服务器性能\",{\"1\":{\"170\":1}}],[\"加入到组播组\",{\"1\":{\"139\":1}}],[\"加密算法\",{\"1\":{\"129\":4}}],[\"加密通信算法改变通知\",{\"1\":{\"129\":4}}],[\"加密通信\",{\"1\":{\"129\":6}}],[\"加密的不是内容而是哈希值\",{\"1\":{\"128\":1}}],[\"加密和解密过程慢\",{\"1\":{\"128\":1}}],[\"加密和解密使用相同的密钥\",{\"1\":{\"128\":1}}],[\"加密速度非常快\",{\"1\":{\"128\":1}}],[\"加上\",{\"1\":{\"82\":1}}],[\"混合加密\",{\"1\":{\"128\":1}}],[\"身份验证\",{\"1\":{\"127\":1}}],[\"校验机制\",{\"1\":{\"127\":1}}],[\"建立一个tcp连接需要\",{\"1\":{\"204\":1}}],[\"建立了连接\",{\"1\":{\"191\":1}}],[\"建立连接\",{\"1\":{\"191\":1,\"298\":1}}],[\"建立连接的过程中根本不需要accept\",{\"1\":{\"182\":1}}],[\"建立连接的复杂程度上\",{\"1\":{\"126\":1}}],[\"建立连接请求\",{\"1\":{\"177\":1}}],[\"建立\",{\"1\":{\"166\":1}}],[\"建立完善的监控系统\",{\"1\":{\"47\":1}}],[\"功能就可以在不使用\",{\"1\":{\"209\":1}}],[\"功能\",{\"1\":{\"123\":1,\"209\":1}}],[\"弊端\",{\"1\":{\"122\":1}}],[\"让他进行分片\",{\"1\":{\"242\":1}}],[\"让发送方避免发送小数据\",{\"1\":{\"230\":1}}],[\"让发送方知道时丢包还是网络延迟\",{\"1\":{\"24\":1}}],[\"让接收方不通告小窗口给发送方\",{\"1\":{\"230\":1}}],[\"让客户端去断开\",{\"1\":{\"165\":1}}],[\"让\",{\"1\":{\"121\":1}}],[\"名为在线证书状态协议\",{\"1\":{\"121\":1}}],[\"名字里的\",{\"1\":{\"82\":1}}],[\"名字通常为\",{\"1\":{\"72\":1}}],[\"短的多\",{\"1\":{\"121\":1}}],[\"曲线\",{\"1\":{\"120\":1}}],[\"椭圆曲线基点\",{\"1\":{\"129\":1}}],[\"椭圆曲线特性\",{\"1\":{\"129\":1}}],[\"椭圆\",{\"1\":{\"120\":1}}],[\"密钥等\",{\"1\":{\"281\":1}}],[\"密钥协商算法使用\",{\"1\":{\"129\":1}}],[\"密钥交换算法\",{\"1\":{\"129\":2}}],[\"密钥交换算法尽量不要选择rsa密钥交换算法\",{\"1\":{\"120\":1}}],[\"密钥长度比\",{\"1\":{\"121\":1}}],[\"密钥算法优化\",{\"1\":{\"120\":1}}],[\"密码模式\",{\"1\":{\"44\":1}}],[\"软件更不更新就是由用户说了算了\",{\"1\":{\"213\":1}}],[\"软件装到用户手机之后\",{\"1\":{\"213\":1}}],[\"软件升级存在一定风险\",{\"1\":{\"120\":1}}],[\"软件升级\",{\"1\":{\"120\":1}}],[\"软件的优化方向可以分成两种\",{\"1\":{\"120\":1}}],[\"软件优化\",{\"0\":{\"120\":1}}],[\"软中断不只是包括硬件设备中断处理程序的下半部\",{\"1\":{\"72\":1}}],[\"软中断处理程序\",{\"1\":{\"72\":1}}],[\"软中断\",{\"0\":{\"72\":1},\"1\":{\"72\":1}}],[\"双全功\",{\"1\":{\"134\":1}}],[\"双方在等待\",{\"1\":{\"197\":1}}],[\"双方都不能发送或者接受消息\",{\"1\":{\"197\":1}}],[\"双方都可以主动向对方发送数据\",{\"1\":{\"134\":1}}],[\"双方采用\",{\"1\":{\"129\":1}}],[\"双方协商生产\",{\"1\":{\"129\":1}}],[\"双方协商缓冲区大小\",{\"1\":{\"27\":1}}],[\"双方会在内存缓存会话密钥\",{\"1\":{\"122\":1}}],[\"双向则指两端都可以发送消息\",{\"1\":{\"116\":1}}],[\"达到了连接迁移的功能\",{\"1\":{\"281\":1}}],[\"达到最大次数之后服务端就直接进入close状态\",{\"1\":{\"258\":1}}],[\"达到关闭\",{\"1\":{\"251\":1}}],[\"达到\",{\"1\":{\"114\":1,\"280\":1}}],[\"甚至在第二次连接的时候\",{\"1\":{\"114\":1,\"280\":1}}],[\"记录协议负责保护应用程序数据并验证其完整性和来源\",{\"1\":{\"130\":1}}],[\"记录\",{\"1\":{\"114\":1,\"280\":1}}],[\"记录日志以便追踪和排查问题\",{\"1\":{\"47\":1}}],[\"源地址ip\",{\"1\":{\"303\":1}}],[\"源地址和目的地址在ip头部\",{\"1\":{\"205\":1}}],[\"源地址\",{\"1\":{\"205\":1}}],[\"源ip地址\",{\"1\":{\"191\":1}}],[\"源ip地址和目标ip地址在传输过程中是不会变化的\",{\"1\":{\"150\":1}}],[\"源主机会检查\",{\"1\":{\"142\":1}}],[\"源主机如果没有接到\",{\"1\":{\"142\":1}}],[\"源主机首先会构建一个\",{\"1\":{\"142\":1}}],[\"源端口和目的端口在tcp头部\",{\"1\":{\"205\":1}}],[\"源端口\",{\"1\":{\"111\":1,\"191\":1,\"205\":1,\"241\":1}}],[\"源\",{\"1\":{\"111\":1,\"139\":1,\"307\":1}}],[\"与网卡的ip地址比较选择相同的那个网卡\",{\"1\":{\"303\":1}}],[\"与ip地址进行按位与可以获得主机号\",{\"1\":{\"289\":1}}],[\"与客户端进行四次挥手\",{\"1\":{\"269\":1}}],[\"与对方完成四次挥手\",{\"1\":{\"260\":1}}],[\"与服务端\",{\"1\":{\"191\":1}}],[\"与处于time\",{\"1\":{\"190\":1}}],[\"与该地址具有相同意义的是一个叫做\",{\"1\":{\"157\":1}}],[\"与\",{\"1\":{\"108\":1,\"111\":1,\"230\":1,\"276\":1}}],[\"握手协议就是我们前面说的\",{\"1\":{\"130\":1}}],[\"握手时密钥交换算法和签名算法都是使用\",{\"1\":{\"129\":1}}],[\"握手连接后\",{\"1\":{\"122\":1}}],[\"握手后的对称加密报文传输\",{\"1\":{\"118\":1}}],[\"握手信息\",{\"1\":{\"114\":1,\"280\":1}}],[\"握手过程\",{\"1\":{\"106\":1,\"129\":1}}],[\"握手\",{\"1\":{\"106\":1,\"120\":1}}],[\"握手耗时\",{\"1\":{\"100\":1}}],[\"信息就泄露了\",{\"1\":{\"213\":1}}],[\"信息\",{\"1\":{\"106\":1,\"114\":1,\"280\":1}}],[\"信息与计算科学\",{\"1\":{\"12\":1}}],[\"构成\",{\"1\":{\"106\":1}}],[\"跑在一条\",{\"1\":{\"106\":1}}],[\"跑得更快的代码\",{\"0\":{\"50\":1}}],[\"属于哪个\",{\"1\":{\"105\":1}}],[\"帧校验序列\",{\"1\":{\"305\":1}}],[\"帧头的最后\",{\"1\":{\"105\":1}}],[\"帧类型后面的一个字节是标志位\",{\"1\":{\"105\":1}}],[\"帧长度后面的一个字节为帧类型\",{\"1\":{\"105\":1}}],[\"首次建立连接时和日常传输数据时使用的\",{\"1\":{\"275\":1}}],[\"首要目的是\",{\"1\":{\"240\":1}}],[\"首部只有\",{\"1\":{\"174\":1}}],[\"首部在没有使用\",{\"1\":{\"174\":1}}],[\"首部长度较长\",{\"1\":{\"174\":1}}],[\"首部开销\",{\"1\":{\"174\":1}}],[\"首部中的\",{\"1\":{\"160\":1}}],[\"首部的一部分了\",{\"1\":{\"160\":1}}],[\"首部\",{\"1\":{\"105\":1}}],[\"首先路由器端口会接收发给自己的以太网包\",{\"1\":{\"307\":1}}],[\"首先当电信号到达网线接口\",{\"1\":{\"306\":1}}],[\"首先根据路由表找到对方ip地址\",{\"1\":{\"304\":1}}],[\"首先需要\",{\"1\":{\"298\":1}}],[\"首先要确定\",{\"1\":{\"157\":1}}],[\"首先要判断是否处于同一个广播域内\",{\"1\":{\"155\":1}}],[\"首先要通过\",{\"1\":{\"76\":1}}],[\"首先在发送端主机发送\",{\"1\":{\"143\":1}}],[\"首先客户端发送clienthello\",{\"1\":{\"129\":2}}],[\"首先\",{\"1\":{\"82\":1,\"145\":1,\"307\":2}}],[\"首先用户点击微信登陆\",{\"1\":{\"45\":1}}],[\"首先双方都处于closed状态\",{\"1\":{\"31\":1,\"299\":1}}],[\"动态表是具有时序性的\",{\"1\":{\"104\":1}}],[\"动态编码表\",{\"0\":{\"104\":1}}],[\"动态字典\",{\"1\":{\"102\":1}}],[\"较短\",{\"1\":{\"103\":1}}],[\"静态表更大\",{\"1\":{\"116\":1}}],[\"静态表编码\",{\"0\":{\"103\":1}}],[\"静态字典\",{\"1\":{\"102\":1}}],[\"压缩算法\",{\"1\":{\"102\":1}}],[\"算法复杂度就是o\",{\"1\":{\"183\":1}}],[\"算法算出的共享密钥\",{\"1\":{\"129\":1}}],[\"算法分为两种实现\",{\"1\":{\"129\":1}}],[\"算法\",{\"1\":{\"102\":1,\"129\":2,\"230\":1}}],[\"算法调度的时候\",{\"1\":{\"60\":1,\"62\":1}}],[\"太大了需要压缩\",{\"1\":{\"102\":1}}],[\"基础计网\",{\"0\":{\"284\":1}}],[\"基础ip\",{\"0\":{\"149\":1}}],[\"基本不可能会随机成一样的初始化序列号\",{\"1\":{\"246\":1}}],[\"基本认识\",{\"0\":{\"159\":1}}],[\"基本改变了http报文的传输格式\",{\"1\":{\"101\":1}}],[\"基于\",{\"0\":{\"132\":1}}],[\"基于字节流的传输层通信协议\",{\"1\":{\"203\":1}}],[\"基于字节流的\",{\"1\":{\"21\":1}}],[\"基点\",{\"1\":{\"129\":1}}],[\"兼容http1\",{\"0\":{\"101\":1}}],[\"特殊情况\",{\"1\":{\"248\":2}}],[\"特殊字符作为边界\",{\"1\":{\"208\":1}}],[\"特定组查询报文\",{\"1\":{\"139\":2}}],[\"特性的\",{\"1\":{\"119\":1}}],[\"特别是对于有携带\",{\"1\":{\"100\":1}}],[\"特点是延迟执行\",{\"1\":{\"72\":1}}],[\"特点是快速执行\",{\"1\":{\"72\":1}}],[\"事务\",{\"1\":{\"100\":1}}],[\"事实上\",{\"1\":{\"61\":1,\"62\":1,\"64\":1,\"69\":1}}],[\"谷歌浏览器最大并发连接数是\",{\"1\":{\"100\":1}}],[\"说白了\",{\"1\":{\"250\":1}}],[\"说白了就是到达了延迟的下限\",{\"1\":{\"100\":1}}],[\"说它是个队列也没毛病\",{\"1\":{\"183\":1}}],[\"说个段子\",{\"1\":{\"159\":1}}],[\"说明已抵达终点\",{\"1\":{\"307\":1}}],[\"说明这两个数据包的内容一致\",{\"1\":{\"276\":1}}],[\"说明服务端的程序没有调用\",{\"1\":{\"167\":1}}],[\"说明发送方发出的\",{\"1\":{\"143\":1}}],[\"说明路程的长短\",{\"1\":{\"142\":1}}],[\"说明从\",{\"1\":{\"28\":1,\"219\":1}}],[\"延迟确认的策略\",{\"1\":{\"262\":1}}],[\"延迟确认\",{\"1\":{\"262\":1}}],[\"延迟确认机制\",{\"1\":{\"262\":2}}],[\"延迟难以下降\",{\"1\":{\"100\":1}}],[\"延迟高的问题来源\",{\"1\":{\"100\":1}}],[\"延迟发送请求\",{\"1\":{\"98\":1}}],[\"造成资源浪费\",{\"1\":{\"239\":1}}],[\"造成http1\",{\"1\":{\"100\":1}}],[\"造成数据处理错误\",{\"1\":{\"26\":1}}],[\"页面资源变多了内容形式变多样了实时性要求变高了\",{\"1\":{\"100\":1}}],[\"消除重连的成本\",{\"1\":{\"281\":1}}],[\"消耗连接\",{\"1\":{\"278\":1}}],[\"消耗为\",{\"1\":{\"162\":1}}],[\"消息的边界\",{\"1\":{\"203\":1}}],[\"消息的大小变大了\",{\"1\":{\"100\":1}}],[\"消息可能会被操作系统分组成多个的\",{\"1\":{\"208\":1}}],[\"消息可能会被操作系统\",{\"1\":{\"203\":1}}],[\"消息可以由多个\",{\"1\":{\"106\":1}}],[\"消息在经过回环地址重新回到\",{\"1\":{\"181\":1}}],[\"消息被发送到这个链表后\",{\"1\":{\"147\":1}}],[\"消息时用的是双向流\",{\"1\":{\"116\":1}}],[\"消息\",{\"1\":{\"106\":1,\"129\":1}}],[\"消息负载\",{\"1\":{\"105\":1}}],[\"消失了\",{\"1\":{\"82\":1}}],[\"解决\",{\"1\":{\"188\":1}}],[\"解决方法\",{\"1\":{\"26\":1}}],[\"解压之后和原来数据一模一样\",{\"1\":{\"99\":1}}],[\"合法\",{\"1\":{\"250\":1}}],[\"合并请求的方式就是合并资源\",{\"1\":{\"98\":1}}],[\"合并请求\",{\"1\":{\"98\":1}}],[\"合理的访问限制\",{\"1\":{\"47\":1}}],[\"带上tcp头\",{\"1\":{\"146\":1}}],[\"带上etag头\",{\"1\":{\"97\":1}}],[\"带宽时延积\",{\"1\":{\"209\":3}}],[\"带宽\",{\"1\":{\"100\":1}}],[\"带来的好处\",{\"1\":{\"51\":1}}],[\"影响性能\",{\"1\":{\"95\":1}}],[\"性能\",{\"1\":{\"95\":1}}],[\"性能的关键在这两点\",{\"1\":{\"95\":1}}],[\"性能指标和异常情况\",{\"1\":{\"47\":1}}],[\"明文传输\",{\"1\":{\"95\":2}}],[\"缺点\",{\"1\":{\"95\":1}}],[\"跨平台\",{\"1\":{\"95\":1}}],[\"应用程序\",{\"1\":{\"297\":1}}],[\"应用程序可以和网络进行通信和数据交换\",{\"1\":{\"283\":1}}],[\"应用程序可以通过\",{\"1\":{\"179\":1}}],[\"应用就把应用数据传给下一层\",{\"1\":{\"285\":1}}],[\"应用层是工作在操作系统中的用户态\",{\"1\":{\"285\":1}}],[\"应用层\",{\"0\":{\"285\":1},\"1\":{\"283\":3}}],[\"应用层的协议\",{\"0\":{\"131\":1}}],[\"应用数据包可以和\",{\"1\":{\"114\":1,\"280\":1}}],[\"应用广泛\",{\"1\":{\"95\":1}}],[\"应答所要求的参数\",{\"1\":{\"137\":1}}],[\"应答\",{\"1\":{\"95\":1}}],[\"应该交由\",{\"1\":{\"192\":1}}],[\"应该要大于等于\",{\"1\":{\"162\":1}}],[\"应该要尽量简化这个运算过程\",{\"1\":{\"80\":1}}],[\"应该选择可以支持\",{\"1\":{\"119\":1}}],[\"应该买cup\",{\"1\":{\"119\":1}}],[\"应该避免这些数据刚好在同一个\",{\"1\":{\"57\":1}}],[\"应该怎么处理\",{\"0\":{\"46\":1}}],[\"灵活和易于扩展\",{\"1\":{\"95\":1}}],[\"优雅关闭\",{\"1\":{\"261\":1}}],[\"优化网络连接\",{\"1\":{\"170\":1}}],[\"优点\",{\"1\":{\"95\":1}}],[\"优先级\",{\"1\":{\"62\":1}}],[\"优先级如下\",{\"1\":{\"61\":1}}],[\"优先级在\",{\"1\":{\"58\":2}}],[\"优先级越高\",{\"1\":{\"58\":1,\"62\":1}}],[\"协商缓存这两个字段都需要配合强制缓存中\",{\"1\":{\"94\":1}}],[\"协商缓存\",{\"0\":{\"94\":1}}],[\"协议根据\",{\"1\":{\"307\":1}}],[\"协议和\",{\"1\":{\"297\":1}}],[\"协议控制网络包收发操作\",{\"1\":{\"297\":1}}],[\"协议栈的上半部分有两块\",{\"1\":{\"297\":1}}],[\"协议栈会为\",{\"1\":{\"179\":1}}],[\"协议定义了数据包的格式和传输规则\",{\"1\":{\"283\":1}}],[\"协议在建立连接的时候通常要协商双方的\",{\"1\":{\"242\":1}}],[\"协议传输时\",{\"1\":{\"203\":1}}],[\"协议可以一个主机同时向多个主机发送消息\",{\"1\":{\"203\":1}}],[\"协议正好相反\",{\"1\":{\"136\":1}}],[\"协议你知道是什么吗\",{\"1\":{\"136\":1}}],[\"协议进行交互\",{\"1\":{\"134\":1}}],[\"协议进行通信\",{\"1\":{\"47\":1}}],[\"协议先进行一次通信\",{\"1\":{\"134\":1}}],[\"协议一般还会再建个连接池\",{\"1\":{\"133\":1}}],[\"协议本身到目前为止还是没有任何漏洞的\",{\"1\":{\"130\":1}}],[\"协议版本\",{\"1\":{\"129\":4}}],[\"协议基本流程\",{\"1\":{\"129\":1}}],[\"协议优化\",{\"1\":{\"120\":1}}],[\"协议握手过程\",{\"1\":{\"118\":1}}],[\"协议是已知\",{\"1\":{\"136\":1}}],[\"协议是无状态的\",{\"1\":{\"100\":1}}],[\"协议是一个双向协议\",{\"1\":{\"86\":1}}],[\"协议通过设置回车符\",{\"1\":{\"88\":1}}],[\"协议的全双工能力\",{\"1\":{\"134\":1}}],[\"协议的四种状态之间的流转过程\",{\"1\":{\"69\":1}}],[\"协议的状态图\",{\"1\":{\"69\":1}}],[\"协议的第二个版本\",{\"1\":{\"43\":1}}],[\"协议其实是\",{\"1\":{\"69\":1}}],[\"协议\",{\"0\":{\"69\":1},\"1\":{\"41\":1,\"68\":1,\"136\":1,\"146\":1,\"297\":2,\"304\":2}}],[\"否则就丢弃这个包\",{\"1\":{\"307\":1}}],[\"否则就会出现为伪共享的问题\",{\"1\":{\"57\":1}}],[\"否则不能使用软件\",{\"1\":{\"213\":1}}],[\"否则无法实现正常的通信\",{\"1\":{\"151\":1}}],[\"否则重新请求服务器\",{\"1\":{\"93\":1}}],[\"具体的实现流程如下\",{\"1\":{\"93\":1}}],[\"具体的处理方式视资源类型而不同\",{\"1\":{\"91\":1}}],[\"选择源ip时将目标地址的网络号\",{\"1\":{\"303\":1}}],[\"选择性确认\",{\"1\":{\"235\":1}}],[\"选择下一个任务执行的时候\",{\"1\":{\"61\":1}}],[\"选项情况下\",{\"1\":{\"210\":1}}],[\"选项\",{\"1\":{\"174\":2,\"190\":1,\"210\":1}}],[\"选项字段不再是标准\",{\"1\":{\"160\":1}}],[\"选项更多一些\",{\"1\":{\"93\":1}}],[\"响应后\",{\"1\":{\"166\":1}}],[\"响应资源\",{\"1\":{\"166\":1}}],[\"响应包返回给主机\",{\"1\":{\"136\":1}}],[\"响应两种类型的包确定\",{\"1\":{\"136\":1}}],[\"响应作为value\",{\"1\":{\"97\":1}}],[\"响应头部\",{\"1\":{\"93\":1}}],[\"响应时间没有很高的要求\",{\"1\":{\"58\":1}}],[\"决定是否使用缓存的主动性在于浏览器这边\",{\"1\":{\"93\":1}}],[\"强制接收\",{\"1\":{\"143\":1}}],[\"强制缓存和协商缓存\",{\"1\":{\"92\":1}}],[\"强缓存是利用下面这两个\",{\"1\":{\"93\":1}}],[\"强缓存\",{\"0\":{\"93\":1}}],[\"强调了资源的标识\",{\"1\":{\"41\":1}}],[\"浏览器\",{\"1\":{\"297\":1}}],[\"浏览器第一步工作是解析ulr\",{\"0\":{\"293\":1}}],[\"浏览器中每一个标签栏都是独立的进程\",{\"1\":{\"287\":1}}],[\"浏览器在\",{\"1\":{\"134\":1}}],[\"浏览器再次请求访问服务器中的该资源时\",{\"1\":{\"93\":1}}],[\"浏览器上可被缓存的\",{\"1\":{\"91\":1}}],[\"浏览器会对url的长度进行限制\",{\"1\":{\"90\":1}}],[\"方法时\",{\"1\":{\"181\":2}}],[\"方法\",{\"1\":{\"146\":2}}],[\"方法是安全\",{\"1\":{\"91\":1}}],[\"方式将接收到的数据写入内存\",{\"1\":{\"72\":1}}],[\"幂等\",{\"1\":{\"91\":2}}],[\"请告诉我\",{\"1\":{\"136\":1}}],[\"请求都是在一条\",{\"1\":{\"277\":1}}],[\"请求后\",{\"1\":{\"166\":1}}],[\"请求资源\",{\"1\":{\"166\":1}}],[\"请求报文进行响应\",{\"1\":{\"137\":1}}],[\"请求报文\",{\"1\":{\"137\":2}}],[\"请求包\",{\"1\":{\"137\":1}}],[\"请求包中的目标\",{\"1\":{\"136\":1}}],[\"请求包里的内容\",{\"1\":{\"136\":1}}],[\"请求时\",{\"1\":{\"136\":1}}],[\"请求与\",{\"1\":{\"136\":1}}],[\"请求与响应是跑在同一个\",{\"1\":{\"106\":1}}],[\"请求升级\",{\"1\":{\"134\":1}}],[\"请求里带上一些特殊的header\",{\"1\":{\"134\":1}}],[\"请求一同发送给服务端\",{\"1\":{\"122\":1}}],[\"请求头部\",{\"1\":{\"116\":1}}],[\"请求从服务器那获取到了\",{\"1\":{\"107\":1}}],[\"请求中大量字段重复需要避免重复性\",{\"1\":{\"102\":1}}],[\"请求和响应\",{\"1\":{\"100\":1}}],[\"请求\",{\"1\":{\"95\":1,\"129\":2,\"134\":1,\"136\":1,\"277\":1,\"278\":1}}],[\"请求方法不会破坏服务器上的资源\",{\"1\":{\"91\":1}}],[\"请随时联系我\",{\"1\":{\"15\":1}}],[\"安全上\",{\"1\":{\"127\":1}}],[\"安全\",{\"1\":{\"91\":1}}],[\"安全性\",{\"1\":{\"47\":1,\"126\":1}}],[\"安全性和性能等因素\",{\"1\":{\"47\":1}}],[\"规定是不允许同时减少缓存又收缩窗口的\",{\"1\":{\"228\":1}}],[\"规定除了最初建立连接时的\",{\"1\":{\"201\":1}}],[\"规定只能支持\",{\"1\":{\"90\":1}}],[\"规范\",{\"1\":{\"103\":1}}],[\"规格化表示成\",{\"1\":{\"82\":1}}],[\"unacknoleged\",{\"1\":{\"224\":1}}],[\"una\",{\"1\":{\"224\":3}}],[\"use\",{\"0\":{\"190\":1},\"1\":{\"188\":1,\"189\":1,\"192\":1}}],[\"udp就只是传输数据包\",{\"1\":{\"287\":1}}],[\"udp不需要连接\",{\"1\":{\"174\":1}}],[\"udp和tcp的区别和应用场景\",{\"0\":{\"172\":1}}],[\"udp\",{\"0\":{\"207\":1},\"1\":{\"137\":2,\"143\":6,\"158\":1,\"174\":7,\"203\":1,\"207\":3,\"283\":1,\"287\":1,\"297\":1}}],[\"udp的特点是\",{\"1\":{\"21\":1}}],[\"url\",{\"1\":{\"90\":1}}],[\"本地网卡会把数据推到一个叫\",{\"1\":{\"147\":1}}],[\"本质上是利用了客户端的漏洞\",{\"1\":{\"130\":1}}],[\"本次数据是什么格式\",{\"1\":{\"88\":1}}],[\"本科\",{\"1\":{\"12\":1}}],[\"告诉它刚发的字典已经更新到自己的本地动态表了\",{\"1\":{\"116\":1}}],[\"告诉客户端\",{\"1\":{\"88\":1}}],[\"告知对方接收了哪些数据\",{\"1\":{\"24\":1}}],[\"机制\",{\"1\":{\"88\":1,\"210\":1}}],[\"粘包\",{\"1\":{\"88\":1}}],[\"粘包问题\",{\"0\":{\"26\":1}}],[\"换行符作为\",{\"1\":{\"88\":1}}],[\"字典累计越来越大\",{\"1\":{\"104\":1}}],[\"字段来告诉发送方\",{\"1\":{\"226\":1}}],[\"字段来使用\",{\"1\":{\"94\":1}}],[\"字段则会变长的\",{\"1\":{\"174\":1}}],[\"字段时是\",{\"1\":{\"174\":1}}],[\"字段值通常为\",{\"1\":{\"139\":1}}],[\"字段需要改成二进制编码\",{\"1\":{\"102\":1}}],[\"字段实现的\",{\"1\":{\"93\":1}}],[\"字段说明数据的压缩方法\",{\"1\":{\"88\":1}}],[\"字段用于服务器回应时\",{\"1\":{\"88\":1}}],[\"字段最常用于客户端要求服务器使用\",{\"1\":{\"88\":1}}],[\"字段作为\",{\"1\":{\"88\":1}}],[\"字段\",{\"1\":{\"88\":6}}],[\"字节又变成了可用窗口\",{\"1\":{\"223\":1}}],[\"字节的\",{\"1\":{\"223\":1}}],[\"字节的大数据报\",{\"1\":{\"158\":1}}],[\"字节流\",{\"1\":{\"203\":1}}],[\"字节等\",{\"1\":{\"158\":1}}],[\"字节等于\",{\"1\":{\"74\":1}}],[\"字节填充\",{\"1\":{\"57\":1}}],[\"字节\",{\"1\":{\"56\":1,\"143\":1,\"158\":1,\"159\":1,\"160\":1,\"223\":2}}],[\"hash等\",{\"1\":{\"181\":1}}],[\"hash\",{\"1\":{\"181\":5}}],[\"handshake\",{\"1\":{\"129\":3}}],[\"hello\",{\"1\":{\"120\":1,\"129\":2}}],[\"headers\",{\"1\":{\"105\":1}}],[\"header\",{\"0\":{\"275\":1,\"276\":1},\"1\":{\"88\":1,\"93\":1,\"275\":2}}],[\"hpack\",{\"1\":{\"104\":1}}],[\"huffman\",{\"1\":{\"102\":1,\"103\":1}}],[\"host\",{\"1\":{\"88\":1,\"146\":1,\"148\":2,\"210\":2}}],[\"html\",{\"1\":{\"107\":3}}],[\"html5\",{\"1\":{\"5\":1}}],[\"http协议是基于tcp协议传输的\",{\"0\":{\"298\":1}}],[\"http应用层协议\",{\"1\":{\"287\":1}}],[\"http连接超时时间的限制\",{\"1\":{\"252\":1}}],[\"http连接简单三次握手之后就可以进行报文的传输\",{\"1\":{\"126\":1}}],[\"http中使用dns服务\",{\"1\":{\"133\":1}}],[\"http和rpc的区别\",{\"0\":{\"133\":1}}],[\"http和https\",{\"0\":{\"125\":1}}],[\"http和https的区别\",{\"0\":{\"124\":1,\"126\":1}}],[\"http是80\",{\"1\":{\"126\":1}}],[\"http是明文传输不安全\",{\"1\":{\"126\":1}}],[\"http是什么\",{\"0\":{\"86\":1}}],[\"http3在头部压缩升级到了qpack\",{\"1\":{\"116\":1}}],[\"http3协议\",{\"0\":{\"116\":1}}],[\"http1\",{\"1\":{\"102\":1}}],[\"http2是基于tcp协议实现的\",{\"1\":{\"108\":1}}],[\"http2的问题\",{\"0\":{\"108\":1}}],[\"http2把报文从文本改成了二进制格式\",{\"1\":{\"105\":1}}],[\"http2没有在url中引入新的协议名\",{\"1\":{\"101\":1}}],[\"http2可以兼容http1\",{\"1\":{\"101\":1}}],[\"http的性能问题\",{\"0\":{\"100\":1}}],[\"http的更迭\",{\"0\":{\"96\":1}}],[\"http特性\",{\"0\":{\"95\":1}}],[\"http缓存技术\",{\"0\":{\"92\":1}}],[\"http常见字段有哪些\",{\"0\":{\"88\":1}}],[\"http常见的状态码\",{\"0\":{\"87\":1}}],[\"http基本概念\",{\"0\":{\"85\":1}}],[\"https的应用数据时如保证完整性的\",{\"0\":{\"130\":1}}],[\"https是如何建立连接的\",{\"0\":{\"129\":1}}],[\"https是443\",{\"1\":{\"126\":1}}],[\"https解决了http的那些问题\",{\"0\":{\"127\":1}}],[\"https需要向ca申请数字证书\",{\"1\":{\"126\":1}}],[\"https在tcp和htttp网络层之间加入了ssl\",{\"1\":{\"126\":1}}],[\"https协议是计算密集型\",{\"1\":{\"119\":1}}],[\"https如何优化\",{\"0\":{\"117\":1}}],[\"https\",{\"1\":{\"46\":1,\"47\":1,\"95\":1,\"101\":1,\"130\":2}}],[\"http\",{\"0\":{\"84\":1},\"1\":{\"41\":1,\"86\":4,\"88\":5,\"93\":1,\"95\":1,\"100\":4,\"101\":1,\"103\":2,\"104\":1,\"105\":1,\"106\":5,\"107\":2,\"109\":1,\"113\":2,\"116\":3,\"122\":1,\"129\":1,\"130\":2,\"133\":2,\"134\":4,\"166\":12,\"252\":2,\"277\":2,\"278\":1,\"283\":1,\"298\":1}}],[\"约为\",{\"1\":{\"205\":1}}],[\"约定和规范\",{\"1\":{\"86\":1}}],[\"约等于\",{\"1\":{\"82\":2}}],[\"超出的部分就没办法有效的网络传输\",{\"1\":{\"209\":1}}],[\"超过\",{\"1\":{\"209\":1}}],[\"超过这个时间就会丢弃这个报文\",{\"1\":{\"162\":1}}],[\"超过这个期限\",{\"1\":{\"136\":1}}],[\"超时时间应该设置为多少呢\",{\"1\":{\"233\":1}}],[\"超时消息的一种方法\",{\"1\":{\"143\":1}}],[\"超时重传的周期可能时间过长\",{\"1\":{\"233\":1}}],[\"超时重传\",{\"0\":{\"233\":1},\"1\":{\"24\":1,\"218\":1,\"287\":1}}],[\"超文本\",{\"1\":{\"86\":1}}],[\"视频等\",{\"1\":{\"86\":1}}],[\"音频\",{\"1\":{\"86\":1}}],[\"音乐\",{\"1\":{\"14\":1}}],[\"图片\",{\"1\":{\"86\":1}}],[\"文件描述符限制\",{\"1\":{\"205\":1}}],[\"文件描述符等\",{\"1\":{\"58\":1}}],[\"文件的请求\",{\"1\":{\"107\":1}}],[\"文件\",{\"1\":{\"107\":2}}],[\"文字\",{\"1\":{\"86\":1}}],[\"传递给对方\",{\"1\":{\"116\":1}}],[\"传输数据之前\",{\"1\":{\"298\":1}}],[\"传输单位是帧\",{\"1\":{\"291\":1}}],[\"传输单位是包\",{\"1\":{\"288\":1}}],[\"传输单位是段\",{\"1\":{\"287\":1}}],[\"传输时会加一个tcp头\",{\"1\":{\"287\":1}}],[\"传输控制协议\",{\"1\":{\"287\":1}}],[\"传输介质的传输特性等\",{\"1\":{\"283\":1}}],[\"传输层及以下则工作在内核态\",{\"1\":{\"285\":1}}],[\"传输层\",{\"0\":{\"287\":1},\"1\":{\"283\":3}}],[\"传输层的时候\",{\"1\":{\"181\":1}}],[\"传输效率更高\",{\"1\":{\"287\":1}}],[\"传输效率低问题\",{\"1\":{\"262\":1}}],[\"传输效率就会降低\",{\"1\":{\"198\":1}}],[\"传输方式\",{\"1\":{\"174\":1}}],[\"传输中创建的方式是\",{\"1\":{\"146\":1}}],[\"传输的内容这个将结构体转为二进制数组的过程就叫序列化\",{\"1\":{\"133\":1}}],[\"传输\",{\"1\":{\"86\":1,\"116\":1}}],[\"传播\",{\"1\":{\"67\":1}}],[\"行为约定和规范\",{\"1\":{\"86\":1}}],[\"两个条件满足一个\",{\"1\":{\"230\":1}}],[\"两个\",{\"1\":{\"176\":1}}],[\"两个私有\",{\"1\":{\"138\":1}}],[\"两个以上的参与者\",{\"1\":{\"86\":1}}],[\"两方的密钥全部随机\",{\"1\":{\"129\":1}}],[\"两者间映射\",{\"1\":{\"97\":1}}],[\"两点\",{\"1\":{\"86\":1}}],[\"两次握手只保证了一方的初始序列号能被对方成功接收\",{\"1\":{\"239\":1}}],[\"两次超时\",{\"1\":{\"233\":1}}],[\"两次\",{\"0\":{\"40\":1}}],[\"除非主机通过\",{\"1\":{\"139\":1}}],[\"除尽的数字\",{\"1\":{\"83\":1}}],[\"除了组标记信息外\",{\"1\":{\"49\":1}}],[\"得到文件描述符\",{\"1\":{\"176\":1}}],[\"得到的必然也是一个近似数\",{\"1\":{\"83\":1}}],[\"得名\",{\"1\":{\"58\":1}}],[\"完成连接的关闭\",{\"1\":{\"308\":1}}],[\"完成建立连接与密钥协商\",{\"1\":{\"114\":1,\"280\":1}}],[\"完整的tcp报文\",{\"0\":{\"302\":1}}],[\"完整\",{\"1\":{\"83\":1}}],[\"完全公平调度\",{\"0\":{\"60\":1}}],[\"移动后的小数点左侧的有效位\",{\"1\":{\"82\":1}}],[\"移动到第一个有效数字后面\",{\"1\":{\"82\":1}}],[\"细心的朋友肯定发现\",{\"1\":{\"82\":1}}],[\"~\",{\"1\":{\"82\":1,\"155\":1}}],[\"十进制\",{\"1\":{\"82\":1}}],[\"十进制小数与二进制的转换\",{\"0\":{\"81\":1}}],[\"偏移量\",{\"1\":{\"82\":3}}],[\"偏移量这三种信息\",{\"1\":{\"49\":1}}],[\"左移\",{\"1\":{\"82\":1}}],[\"左半部分就是读操作的流程\",{\"1\":{\"66\":1}}],[\"右移\",{\"1\":{\"82\":2}}],[\"右半部分就是写操作的流程\",{\"1\":{\"66\":1}}],[\"尾数就能多存一位小数\",{\"1\":{\"82\":1}}],[\"尾数部分就是\",{\"1\":{\"82\":1}}],[\"尾数位\",{\"1\":{\"82\":2}}],[\"符号位\",{\"1\":{\"82\":1}}],[\"符号标志位\",{\"1\":{\"80\":1}}],[\"制定的国际标准\",{\"1\":{\"82\":1}}],[\"指明数据的长度\",{\"1\":{\"276\":1}}],[\"指针加上\",{\"1\":{\"224\":1,\"225\":1}}],[\"指向\",{\"1\":{\"224\":1,\"225\":1}}],[\"指下一次\",{\"1\":{\"201\":1,\"248\":1}}],[\"指出的位置上\",{\"1\":{\"160\":1}}],[\"指定用户可打开的最大数量\",{\"1\":{\"205\":1}}],[\"指定某个网络\",{\"1\":{\"153\":1}}],[\"指定某个网络下的所有主机\",{\"1\":{\"153\":1}}],[\"指定了小数点在数据中的位置\",{\"1\":{\"82\":2}}],[\"指的是只要浏览器判断缓存没有过期\",{\"1\":{\"93\":1}}],[\"指数如果是\",{\"1\":{\"82\":1}}],[\"指数可能是正数\",{\"1\":{\"82\":1}}],[\"指数可以是负数\",{\"1\":{\"82\":1}}],[\"指数位的长度越长则数值的表达范围就越大\",{\"1\":{\"82\":1}}],[\"指数位\",{\"1\":{\"82\":3}}],[\"指令都存储在这里\",{\"1\":{\"75\":1}}],[\"指令被执行完成之前\",{\"1\":{\"75\":1}}],[\"指令寄存器\",{\"1\":{\"75\":1}}],[\"指令到\",{\"1\":{\"52\":1}}],[\"指令的话\",{\"1\":{\"52\":1}}],[\"指令缓存\",{\"0\":{\"52\":1},\"1\":{\"49\":1}}],[\"xxxx\",{\"1\":{\"136\":2}}],[\"x25519\",{\"1\":{\"120\":1}}],[\"x\",{\"1\":{\"82\":6,\"129\":1,\"155\":4}}],[\"浮点\",{\"1\":{\"82\":1}}],[\"二进制帧\",{\"0\":{\"105\":1}}],[\"二进制浮点数的小数点左侧只能有\",{\"1\":{\"82\":1}}],[\"二进制\",{\"1\":{\"81\":1}}],[\"近似值\",{\"1\":{\"81\":1}}],[\"转为电信号\",{\"1\":{\"305\":1}}],[\"转发\",{\"1\":{\"283\":2}}],[\"转换表的生成与转换操作都会产生性能开销\",{\"1\":{\"138\":1}}],[\"转换表没有转换记录\",{\"1\":{\"138\":1}}],[\"转换公式如下\",{\"1\":{\"82\":1}}],[\"转换为二进制之后再存储\",{\"1\":{\"82\":1}}],[\"转换成二进制\",{\"1\":{\"81\":1}}],[\"转十进制的过程\",{\"1\":{\"81\":1}}],[\"转二进制作为例子\",{\"1\":{\"81\":1}}],[\"刚好通过乘\",{\"1\":{\"81\":1}}],[\"结束\",{\"1\":{\"129\":2}}],[\"结构都是相同的\",{\"1\":{\"91\":1}}],[\"结构体里部分资源是共享了进程已创建的资源\",{\"1\":{\"58\":1}}],[\"结构体里的两个成员变量\",{\"1\":{\"57\":1}}],[\"结构体表示的\",{\"1\":{\"58\":1}}],[\"结合在一起后\",{\"1\":{\"81\":1}}],[\"整数部分\",{\"1\":{\"81\":1}}],[\"整个\",{\"1\":{\"69\":1,\"109\":1}}],[\"取消选项字段\",{\"1\":{\"160\":1}}],[\"取消了分片\",{\"1\":{\"160\":1}}],[\"取消了首部校验和字段\",{\"1\":{\"160\":1}}],[\"取整法的方式完整的转换成二进制\",{\"1\":{\"81\":1}}],[\"取整法\",{\"1\":{\"81\":1}}],[\"取模运算的结果就是内存块地址对应的\",{\"1\":{\"49\":1}}],[\"取模运算\",{\"1\":{\"49\":1}}],[\"毕竟加减法运算在计算机里是很常使用的\",{\"1\":{\"80\":1}}],[\"试想一下\",{\"1\":{\"80\":1}}],[\"补码\",{\"1\":{\"80\":1}}],[\"剩余的就是网络号\",{\"1\":{\"155\":1}}],[\"剩余的\",{\"1\":{\"80\":1}}],[\"负责的\",{\"1\":{\"297\":1}}],[\"负责在以太网\",{\"1\":{\"291\":1}}],[\"负责在物理网络中传输数据帧\",{\"1\":{\"283\":1}}],[\"负责表示同一子网下的不同设备\",{\"1\":{\"289\":1}}],[\"负责表示属于哪个子网\",{\"1\":{\"289\":1}}],[\"负责传输比特流\",{\"1\":{\"283\":1}}],[\"负责端到端之间的通信\",{\"1\":{\"283\":1}}],[\"负责端到端的通信\",{\"1\":{\"283\":1}}],[\"负责端到端的数据传输\",{\"1\":{\"283\":1}}],[\"负责网络包在物理网络中的传输\",{\"1\":{\"283\":1}}],[\"负责网络包的封装\",{\"1\":{\"283\":1}}],[\"负责向用户提供一组应用程序\",{\"1\":{\"283\":1}}],[\"负责数据的封帧和差错检测\",{\"1\":{\"283\":1}}],[\"负责数据的路由\",{\"1\":{\"283\":1}}],[\"负责建立\",{\"1\":{\"283\":1}}],[\"负责把数据转换成兼容另一个系统能识别的格式\",{\"1\":{\"283\":1}}],[\"负责给应用程序提供统一的接口\",{\"1\":{\"283\":1}}],[\"负责通知\",{\"1\":{\"139\":1}}],[\"负责协商加密算法和生成对称密钥\",{\"1\":{\"130\":1}}],[\"负数为什么要用补码方式来表示\",{\"1\":{\"80\":1}}],[\"负数在计算机中是以\",{\"1\":{\"80\":1}}],[\"负数的符号位是\",{\"1\":{\"80\":1}}],[\"负载均衡\",{\"1\":{\"47\":1}}],[\"正好是服务端下一次想要接收的序列号\",{\"1\":{\"250\":1}}],[\"正如我们最开始学到的\",{\"1\":{\"250\":1}}],[\"正数的符号位是\",{\"1\":{\"80\":1}}],[\"正在执行的任务\",{\"1\":{\"72\":1}}],[\"硬件优化\",{\"0\":{\"119\":1}}],[\"硬盘则可用更大的容量\",{\"1\":{\"78\":1}}],[\"硬中断\",{\"1\":{\"72\":2}}],[\"种\",{\"1\":{\"76\":1}}],[\"总线可分为\",{\"1\":{\"76\":1}}],[\"总线是用于\",{\"1\":{\"76\":1}}],[\"总线\",{\"0\":{\"76\":1}}],[\"总线嗅探只是保证了某个\",{\"1\":{\"68\":1}}],[\"总线嗅探方法很简单\",{\"1\":{\"68\":1}}],[\"总线嗅探\",{\"0\":{\"68\":1}}],[\"程序如何表示发送方的四个部分呢\",{\"0\":{\"224\":1}}],[\"程序计数器只是存储了下一条指令\",{\"1\":{\"75\":1}}],[\"程序计数器\",{\"1\":{\"75\":1}}],[\"程序执行时\",{\"1\":{\"49\":1}}],[\"逻辑运算单元负责计算\",{\"1\":{\"75\":1}}],[\"工作在网卡这个层次\",{\"1\":{\"291\":1}}],[\"工作在网络层\",{\"1\":{\"146\":1}}],[\"工作在传输层\",{\"1\":{\"146\":1}}],[\"工作在主机\",{\"1\":{\"139\":1}}],[\"工作\",{\"1\":{\"75\":1}}],[\"工具是在双方进行\",{\"1\":{\"251\":1}}],[\"工具\",{\"0\":{\"8\":1}}],[\"控制数据发送的唯一限制就是最大绝对字节偏移量\",{\"1\":{\"278\":1}}],[\"控制位\",{\"1\":{\"248\":1}}],[\"控制是读或写命令\",{\"1\":{\"76\":1}}],[\"控制总线\",{\"1\":{\"76\":2}}],[\"控制单元负责控制\",{\"1\":{\"75\":1}}],[\"控制单元和逻辑运算单元等\",{\"1\":{\"75\":1}}],[\"控制器\",{\"1\":{\"73\":1}}],[\"能建立tcp连接吗\",{\"0\":{\"182\":1}}],[\"能让被动关闭方接收\",{\"1\":{\"163\":1}}],[\"能同时与服务器之间进行通信\",{\"1\":{\"138\":1}}],[\"能表示更大的数值范围\",{\"1\":{\"82\":1}}],[\"能计算的最大整数是\",{\"1\":{\"75\":1}}],[\"能被正确的关闭\",{\"1\":{\"39\":1,\"163\":1}}],[\"输入\",{\"0\":{\"77\":1}}],[\"输入设备向计算机输入数据\",{\"1\":{\"77\":1}}],[\"输入设备\",{\"1\":{\"73\":1}}],[\"输出设备\",{\"0\":{\"77\":1},\"1\":{\"73\":1}}],[\"运算\",{\"1\":{\"75\":1}}],[\"运算器\",{\"1\":{\"73\":1}}],[\"运行队列\",{\"0\":{\"61\":1},\"1\":{\"61\":2}}],[\"冯诺依曼模型\",{\"0\":{\"73\":1}}],[\"抓网络包\",{\"1\":{\"72\":1}}],[\"命令执行的时候\",{\"1\":{\"142\":1}}],[\"命令就是利用这个消息实现的\",{\"1\":{\"142\":1}}],[\"命令查看是哪个网卡的有大量的网络包接收\",{\"1\":{\"72\":1}}],[\"命令发现\",{\"1\":{\"72\":1}}],[\"编码解码cookies\",{\"1\":{\"185\":1}}],[\"编码方收到解码方更新确认的通知后\",{\"1\":{\"116\":1}}],[\"编码的原理是将高频出现的信息用\",{\"1\":{\"103\":1}}],[\"编码\",{\"1\":{\"102\":1}}],[\"编号\",{\"1\":{\"72\":1}}],[\"编程\",{\"1\":{\"14\":1}}],[\"编程语言\",{\"0\":{\"4\":1}}],[\"kill\",{\"1\":{\"269\":1}}],[\"killcx\",{\"0\":{\"250\":1}}],[\"keepalive\",{\"1\":{\"252\":1,\"270\":3}}],[\"keep\",{\"1\":{\"133\":1,\"166\":6,\"252\":1}}],[\"key\",{\"1\":{\"116\":1,\"122\":1,\"129\":7}}],[\"ksoftirqd\",{\"1\":{\"72\":3,\"147\":1}}],[\"kubernetes\",{\"1\":{\"8\":1}}],[\"交换机的端口不具有\",{\"1\":{\"307\":1}}],[\"交换机的端口不具有mac地址\",{\"1\":{\"306\":1}}],[\"交换机的设计是将网络包原样转发到目的地\",{\"1\":{\"306\":1}}],[\"交换机会将包转发到除了源端口之外的所有端口\",{\"1\":{\"306\":2}}],[\"交换机通过查询mac地址表\",{\"1\":{\"306\":1}}],[\"交换机将电信号转变为数字信号\",{\"1\":{\"306\":1}}],[\"交换机工作在mac层\",{\"1\":{\"306\":1}}],[\"交换机\",{\"0\":{\"306\":1}}],[\"交换访问令牌\",{\"1\":{\"43\":1}}],[\"交互中\",{\"1\":{\"137\":1}}],[\"交互便完成了\",{\"1\":{\"137\":1}}],[\"交给网络接口层生成mac头部\",{\"1\":{\"291\":1}}],[\"交给\",{\"1\":{\"72\":1}}],[\"下次先访问缓存\",{\"1\":{\"304\":1}}],[\"下面的网卡驱动程序负责控制网卡硬件\",{\"1\":{\"297\":1}}],[\"下一个首部\",{\"1\":{\"160\":1}}],[\"下一跳\",{\"1\":{\"136\":1}}],[\"下半部\",{\"1\":{\"72\":1}}],[\"下半部是由内核触发\",{\"1\":{\"72\":1}}],[\"下半部用来延迟处理上半部未完成的工作\",{\"1\":{\"72\":1}}],[\"下图即是\",{\"1\":{\"69\":1}}],[\"临时关闭中断\",{\"1\":{\"71\":1}}],[\"替换\",{\"1\":{\"69\":1}}],[\"继续\",{\"1\":{\"69\":1}}],[\"继承\",{\"1\":{\"57\":1}}],[\"上一次收到的报文中的序列号\",{\"1\":{\"248\":1}}],[\"上一次发送的序列号\",{\"1\":{\"248\":2}}],[\"上一次超时的二倍\",{\"1\":{\"243\":1}}],[\"上图中黄色部分为分类号\",{\"1\":{\"152\":1}}],[\"上面挂着发给本机的各种消息\",{\"1\":{\"147\":1}}],[\"上面的运算过程中得到结果是\",{\"1\":{\"80\":1}}],[\"上部分要做的事情很少\",{\"1\":{\"72\":1}}],[\"上半部\",{\"1\":{\"72\":1}}],[\"上半部直接处理硬件请求\",{\"1\":{\"72\":1}}],[\"上半部用来快速处理中断\",{\"1\":{\"72\":1}}],[\"上半部和下半部分\",{\"1\":{\"72\":1}}],[\"上的数据已经被更新过\",{\"1\":{\"69\":1}}],[\"上所运行的所有进程\",{\"1\":{\"61\":1}}],[\"代表任意地址\",{\"1\":{\"188\":1}}],[\"代表的是\",{\"1\":{\"75\":1}}],[\"代表该\",{\"1\":{\"69\":1}}],[\"代码段\",{\"1\":{\"58\":1}}],[\"代码如下\",{\"1\":{\"57\":1}}],[\"代码的性能就会越好\",{\"1\":{\"50\":1}}],[\"四元组做\",{\"1\":{\"210\":1}}],[\"四元组包括如下\",{\"1\":{\"205\":1}}],[\"四元组可以唯一的确定一个连接\",{\"1\":{\"205\":1}}],[\"四次握手的过程\",{\"1\":{\"130\":1}}],[\"四次握手\",{\"1\":{\"129\":1}}],[\"四次挥手中收到乱序的fin包怎么办\",{\"0\":{\"263\":1}}],[\"四次挥手过程中\",{\"1\":{\"261\":1}}],[\"四次挥手\",{\"0\":{\"34\":1},\"1\":{\"261\":1,\"270\":1,\"308\":1}}],[\"四个不同的状态\",{\"1\":{\"69\":1}}],[\"才会发出\",{\"1\":{\"261\":1}}],[\"才会发送吗\",{\"1\":{\"260\":1}}],[\"才使用动态表编码\",{\"1\":{\"116\":1}}],[\"才能确保双方的初始序列号能被可靠的同步\",{\"1\":{\"239\":1}}],[\"才能避免糊涂窗口综合症\",{\"1\":{\"230\":1}}],[\"才能连接\",{\"1\":{\"203\":1}}],[\"才能拿到我们想要的那个连接\",{\"1\":{\"183\":1}}],[\"才能传输应用数据\",{\"1\":{\"129\":1}}],[\"才能处理下一个事务\",{\"1\":{\"100\":1}}],[\"才能发起带有协商缓存字段的请求\",{\"1\":{\"94\":1}}],[\"才能进行对应的数据更新\",{\"1\":{\"67\":1}}],[\"才有\",{\"1\":{\"38\":1,\"255\":1}}],[\"锁\",{\"1\":{\"67\":2,\"72\":1}}],[\"点\",{\"1\":{\"67\":1}}],[\"点赞等功能\",{\"1\":{\"11\":1}}],[\"再由相应的端口作为发送方将以太网包发送出去\",{\"1\":{\"307\":1}}],[\"再跟据apr协议找到对方mac地址\",{\"1\":{\"304\":1}}],[\"再下面是\",{\"1\":{\"295\":1}}],[\"再进行分片\",{\"1\":{\"288\":1}}],[\"再收缩窗口\",{\"1\":{\"228\":1}}],[\"再收到\",{\"1\":{\"67\":1}}],[\"再来说说为什么\",{\"0\":{\"208\":1}}],[\"再一次从这个全局\",{\"1\":{\"181\":1}}],[\"再出现的数据包一定都是新建立连接所产生的\",{\"1\":{\"163\":2}}],[\"再交由接收方重组成大数据报\",{\"1\":{\"158\":1}}],[\"再从路由控制表中找到与该地址具有相同网络地址的记录\",{\"1\":{\"157\":1}}],[\"再将每组转换成十进制\",{\"1\":{\"151\":1}}],[\"再以单播的形式发给\",{\"1\":{\"137\":1}}],[\"再加上\",{\"1\":{\"114\":1,\"280\":1}}],[\"再加载到每个核心独有的\",{\"1\":{\"49\":1}}],[\"再把指数减去\",{\"1\":{\"82\":1}}],[\"再用\",{\"1\":{\"72\":1}}],[\"再按照网络协议栈\",{\"1\":{\"72\":1}}],[\"再变成\",{\"1\":{\"67\":2}}],[\"到接收缓冲区中\",{\"1\":{\"179\":1}}],[\"到这里\",{\"1\":{\"80\":1}}],[\"到\",{\"1\":{\"67\":1}}],[\"必须按序处理数据\",{\"1\":{\"277\":1}}],[\"必须要完成\",{\"1\":{\"129\":1}}],[\"必须要传播到其他核心的\",{\"1\":{\"67\":1}}],[\"必须同一个连接上\",{\"1\":{\"104\":1}}],[\"必须在其他核心看起来顺序是一样的\",{\"1\":{\"67\":1}}],[\"某个流发生丢包了\",{\"1\":{\"113\":1}}],[\"某个流中的一个数据包丢失了\",{\"1\":{\"113\":1}}],[\"某个\",{\"1\":{\"67\":2}}],[\"要小\",{\"1\":{\"266\":2}}],[\"要大\",{\"1\":{\"265\":2}}],[\"要阻止掉历史连接\",{\"1\":{\"239\":1}}],[\"要等到窗口大小\",{\"1\":{\"230\":1}}],[\"要解决这种现象\",{\"1\":{\"239\":1}}],[\"要解决这一问题\",{\"1\":{\"67\":1}}],[\"要解决糊涂窗口综合症\",{\"1\":{\"230\":1}}],[\"要求连接双方维护最近一次收到的数据包的时间戳\",{\"1\":{\"210\":1}}],[\"要求先把其他核心的\",{\"1\":{\"69\":2}}],[\"要使得这个选项生效\",{\"1\":{\"210\":1}}],[\"要看多个客户端绑定的\",{\"1\":{\"192\":1}}],[\"要离开组播组\",{\"1\":{\"139\":1}}],[\"要离开组\",{\"1\":{\"139\":1}}],[\"要让证书更便于传输\",{\"1\":{\"121\":1}}],[\"要自行构建动态表\",{\"1\":{\"104\":1}}],[\"要考虑到这个隐含的\",{\"1\":{\"82\":1}}],[\"要先判断数字是否为负数\",{\"1\":{\"80\":1}}],[\"要读写内存数据的时候\",{\"1\":{\"76\":1}}],[\"要执行下一条指令\",{\"1\":{\"75\":1}}],[\"要这样设计\",{\"1\":{\"75\":1}}],[\"要尽可能快的执行完\",{\"1\":{\"71\":1}}],[\"要被\",{\"1\":{\"69\":1}}],[\"要被替换的时候\",{\"1\":{\"67\":1}}],[\"要把该事件广播通知到其他核心\",{\"1\":{\"68\":1}}],[\"要引入\",{\"1\":{\"67\":1}}],[\"要做到\",{\"1\":{\"67\":1}}],[\"要实现事务串行化\",{\"1\":{\"67\":1}}],[\"语句的时候\",{\"1\":{\"67\":1}}],[\"初始化序列号可被视为一个\",{\"1\":{\"246\":1}}],[\"初始化序列号\",{\"1\":{\"246\":1}}],[\"初始化序列号都要不一样\",{\"0\":{\"246\":1}}],[\"初始化序列号的都要求不一样\",{\"0\":{\"240\":1}}],[\"初始化了连接\",{\"1\":{\"239\":1}}],[\"初始化值\",{\"1\":{\"218\":2}}],[\"初始值为\",{\"1\":{\"67\":2}}],[\"初始序列号isn是如何随机产生的\",{\"0\":{\"241\":1}}],[\"初始序列号\",{\"1\":{\"31\":1,\"299\":1}}],[\"现在到达了路由器\",{\"1\":{\"307\":1}}],[\"现在常用的\",{\"1\":{\"129\":1}}],[\"现在绝大多数计算机使用的浮点数\",{\"1\":{\"82\":1}}],[\"现在\",{\"1\":{\"67\":1}}],[\"现在假设有一个双核心的\",{\"1\":{\"56\":1}}],[\"先减少缓存\",{\"1\":{\"228\":1}}],[\"先来说说为什么\",{\"0\":{\"207\":1}}],[\"先变成\",{\"1\":{\"67\":1}}],[\"先把值为\",{\"1\":{\"67\":1}}],[\"先从内存读入到\",{\"1\":{\"66\":1}}],[\"先排序再遍历速度会更快\",{\"1\":{\"52\":1}}],[\"别的内存地址的数据\",{\"1\":{\"66\":1}}],[\"新的数据仅仅被写入\",{\"1\":{\"66\":1}}],[\"写\",{\"1\":{\"197\":1}}],[\"写入数据\",{\"1\":{\"176\":1}}],[\"写数据\",{\"1\":{\"69\":1}}],[\"写传播的原则就是当某个\",{\"1\":{\"68\":1}}],[\"写回\",{\"0\":{\"66\":1},\"1\":{\"64\":1}}],[\"写回到内存\",{\"1\":{\"56\":1}}],[\"写直达法很直观\",{\"1\":{\"65\":1}}],[\"写直达\",{\"0\":{\"65\":1},\"1\":{\"64\":1}}],[\"范围是提供给实时任务使用的\",{\"1\":{\"62\":1}}],[\"范围内的数值\",{\"1\":{\"75\":1}}],[\"范围内的就算实时任务\",{\"1\":{\"58\":1}}],[\"范围内都是普通任务级别\",{\"1\":{\"58\":1}}],[\"默认即为\",{\"1\":{\"210\":1}}],[\"默认情况下路由器是不会转发组播包到连接中的主机\",{\"1\":{\"139\":1}}],[\"默认情况下都是普通任务\",{\"1\":{\"62\":1}}],[\"默认网关\",{\"1\":{\"137\":1}}],[\"默认端口\",{\"1\":{\"126\":1}}],[\"默认优先级是\",{\"1\":{\"62\":1}}],[\"表中\",{\"1\":{\"181\":1}}],[\"表其实还细分为\",{\"1\":{\"181\":1}}],[\"表\",{\"1\":{\"181\":1}}],[\"表明客户端没有数据需要发送了\",{\"1\":{\"179\":1}}],[\"表明接受方在本网络上\",{\"1\":{\"155\":1}}],[\"表明本次回应的数据长度\",{\"1\":{\"88\":1}}],[\"表明优先级越高\",{\"1\":{\"62\":1}}],[\"表示协议为tcp\",{\"1\":{\"303\":1}}],[\"表示层\",{\"1\":{\"283\":1}}],[\"表示接收窗口的大小\",{\"1\":{\"225\":1}}],[\"表示发送窗口的大小\",{\"1\":{\"224\":1}}],[\"表示发向网段内的所有路由器\",{\"1\":{\"139\":1}}],[\"表示今后不会再有数据发送\",{\"1\":{\"201\":1}}],[\"表示希望建立连接\",{\"1\":{\"201\":1}}],[\"表示\",{\"1\":{\"201\":1}}],[\"表示在该连接上再无额外数据到达\",{\"1\":{\"179\":1}}],[\"表示连接关闭\",{\"1\":{\"176\":1}}],[\"表示前\",{\"1\":{\"155\":1}}],[\"表示形式\",{\"1\":{\"155\":1}}],[\"表示将使用\",{\"1\":{\"146\":1}}],[\"表示同一网段内所有主机和路由器\",{\"1\":{\"139\":1}}],[\"表示服务器的握手阶段已经结束\",{\"1\":{\"129\":2}}],[\"表示服务器返回的数据使用了什么压缩格式\",{\"1\":{\"88\":1}}],[\"表示随后的信息都将用\",{\"1\":{\"129\":4}}],[\"表示加密协议\",{\"1\":{\"101\":1}}],[\"表示明文协议\",{\"1\":{\"101\":1}}],[\"表示正数\",{\"1\":{\"82\":1}}],[\"表示数字是正数还是负数\",{\"1\":{\"82\":1}}],[\"表示数据在数据流中的位置\",{\"1\":{\"25\":1}}],[\"表示小数点是可以浮动的\",{\"1\":{\"82\":1}}],[\"表示负数\",{\"1\":{\"80\":1,\"82\":1}}],[\"表示的\",{\"1\":{\"80\":1}}],[\"表示的是这个\",{\"1\":{\"69\":1}}],[\"表示客户端的握手阶段已经结束\",{\"1\":{\"129\":2}}],[\"表示客户端希望下一次接受的序列号\",{\"1\":{\"33\":1,\"301\":1}}],[\"表示客户端请求连接\",{\"1\":{\"31\":1,\"299\":1}}],[\"值做比较\",{\"1\":{\"210\":1,\"246\":1}}],[\"值就不一样了\",{\"1\":{\"143\":1}}],[\"值变为\",{\"1\":{\"67\":2}}],[\"值还没写入到内存中\",{\"1\":{\"67\":1}}],[\"值的关系的\",{\"1\":{\"62\":1}}],[\"值的范围很诡异\",{\"1\":{\"62\":1}}],[\"值调整的是普通任务的优先级\",{\"1\":{\"62\":1}}],[\"值是映射到\",{\"1\":{\"62\":1}}],[\"值并不是表示优先级\",{\"1\":{\"62\":1}}],[\"值越低\",{\"1\":{\"62\":4}}],[\"值\",{\"1\":{\"62\":3,\"143\":1,\"242\":1}}],[\"调节所要发送数据的量\",{\"1\":{\"215\":1}}],[\"调大\",{\"1\":{\"169\":1}}],[\"调用了\",{\"1\":{\"197\":1}}],[\"调用来感知这个\",{\"1\":{\"179\":1}}],[\"调用\",{\"1\":{\"146\":1,\"167\":1,\"261\":1}}],[\"调整半连接队列的大小\",{\"1\":{\"196\":1}}],[\"调整服务器的syn超时时间\",{\"1\":{\"170\":1}}],[\"调整的是普通任务的优先级\",{\"1\":{\"62\":1}}],[\"调整优先级\",{\"0\":{\"62\":1}}],[\"调度器的目的是实现任务运行的公平性\",{\"1\":{\"62\":1}}],[\"调度器来进行管理\",{\"1\":{\"62\":1}}],[\"调度器管理的\",{\"1\":{\"59\":1}}],[\"调度类是应用于普通任务\",{\"1\":{\"59\":1}}],[\"调度类\",{\"0\":{\"59\":1}}],[\"调度的对象就是\",{\"1\":{\"58\":1}}],[\">=\",{\"1\":{\"216\":1,\"230\":3}}],[\">\",{\"1\":{\"61\":2,\"166\":3}}],[\"qpack\",{\"1\":{\"116\":2}}],[\"quic作为一个基于udp的传输层协议\",{\"1\":{\"279\":1}}],[\"quic的解决办法\",{\"1\":{\"277\":1}}],[\"quic是如何实现可靠传输的\",{\"0\":{\"274\":1}}],[\"quic协议\",{\"0\":{\"272\":1}}],[\"quic协议的特点\",{\"0\":{\"112\":1}}],[\"quic\",{\"0\":{\"276\":1,\"277\":1,\"278\":1,\"279\":1,\"280\":1,\"281\":1},\"1\":{\"113\":2,\"114\":3,\"116\":1,\"275\":1,\"277\":1,\"278\":1,\"279\":2,\"280\":3}}],[\"queue\",{\"1\":{\"61\":1,\"147\":1}}],[\"qq\",{\"1\":{\"1\":1}}],[\"多线程共享同一个\",{\"1\":{\"261\":2}}],[\"多对多的交互通信\",{\"1\":{\"174\":1}}],[\"多播\",{\"1\":{\"154\":1}}],[\"多数情况下会在路由器上设置为不转发\",{\"1\":{\"153\":1}}],[\"多个请求是跑在一个\",{\"1\":{\"109\":1}}],[\"多个\",{\"1\":{\"106\":1,\"277\":1}}],[\"多次执行相同的操作\",{\"1\":{\"91\":1}}],[\"多任务的数量基本都是远超\",{\"1\":{\"61\":1}}],[\"多核\",{\"0\":{\"53\":1}}],[\"少\",{\"1\":{\"60\":1}}],[\"少的任务进行执行\",{\"1\":{\"62\":1}}],[\"少的任务\",{\"1\":{\"60\":1}}],[\"高权重任务的\",{\"1\":{\"60\":1}}],[\"高性能\",{\"1\":{\"47\":1}}],[\"级别的流量窗口\",{\"1\":{\"278\":1}}],[\"级别的流量控制\",{\"1\":{\"278\":1}}],[\"级别越低的权重值就越大\",{\"1\":{\"60\":1}}],[\"级别与权重值的转换表\",{\"1\":{\"60\":1}}],[\"自连接的情况中\",{\"1\":{\"181\":1}}],[\"自然就会读到\",{\"1\":{\"179\":1}}],[\"自然就会越大\",{\"1\":{\"60\":1}}],[\"自然性能相比写直达会高很多\",{\"1\":{\"66\":1}}],[\"自定义消息结构\",{\"1\":{\"26\":1,\"208\":1}}],[\"轮流着运行\",{\"1\":{\"59\":1}}],[\"插队\",{\"1\":{\"59\":1}}],[\"按序到达\",{\"1\":{\"174\":1}}],[\"按需获取\",{\"1\":{\"98\":1}}],[\"按下按键时是需要和\",{\"1\":{\"77\":1}}],[\"按\",{\"1\":{\"61\":1}}],[\"按先来先服务的原则\",{\"1\":{\"59\":1}}],[\"按照内存布局顺序访问\",{\"1\":{\"51\":1}}],[\"距离当前时间点最近的\",{\"1\":{\"59\":1}}],[\"系统级\",{\"1\":{\"205\":1}}],[\"系统为了解决中断处理程序执行过长和中断丢失的问题\",{\"1\":{\"72\":1}}],[\"系统为了保障高优先级的任务能够尽可能早的被执行\",{\"1\":{\"59\":1}}],[\"系统中其他的中断请求都无法被响应\",{\"1\":{\"71\":1}}],[\"系统中\",{\"1\":{\"58\":1}}],[\"系统里\",{\"1\":{\"57\":1,\"72\":1}}],[\"轻\",{\"1\":{\"58\":1}}],[\"承载的\",{\"1\":{\"58\":1}}],[\"区别在于线程的\",{\"1\":{\"58\":1}}],[\"各自控制的滑动窗口\",{\"1\":{\"277\":1}}],[\"各填充了\",{\"1\":{\"57\":1}}],[\"各个核心的缓存命中率就会受到影响\",{\"1\":{\"53\":1}}],[\"修改更新其数据不需要发送广播给其他\",{\"1\":{\"69\":1}}],[\"修改\",{\"1\":{\"69\":1}}],[\"修改到\",{\"1\":{\"56\":1}}],[\"修饰的\",{\"1\":{\"57\":1}}],[\"更快的连接建立\",{\"0\":{\"280\":1}}],[\"更快连接建立\",{\"0\":{\"114\":1}}],[\"更安全\",{\"1\":{\"126\":1}}],[\"更新数据这个事件能被其他\",{\"1\":{\"68\":1}}],[\"更新了数据\",{\"1\":{\"67\":1}}],[\"更新日期\",{\"1\":{\"15\":1}}],[\"更不会对它们进行读写操作\",{\"1\":{\"57\":1}}],[\"前两次不可以携带数据\",{\"1\":{\"238\":1}}],[\"前一个\",{\"1\":{\"203\":1}}],[\"前提\",{\"1\":{\"150\":1}}],[\"前三个字节为帧长度\",{\"1\":{\"105\":1}}],[\"前面是网络号\",{\"1\":{\"155\":1}}],[\"前面也提到\",{\"1\":{\"82\":1}}],[\"前面提到的\",{\"1\":{\"81\":1}}],[\"前后\",{\"1\":{\"57\":1}}],[\"前置填充\",{\"1\":{\"57\":1}}],[\"前端开发\",{\"1\":{\"11\":1}}],[\"前端技术\",{\"0\":{\"5\":1}}],[\"位为\",{\"1\":{\"201\":1}}],[\"位为组\",{\"1\":{\"151\":1}}],[\"位作为一组\",{\"1\":{\"159\":1}}],[\"位属于网络号\",{\"1\":{\"155\":1}}],[\"位正整数来表示\",{\"1\":{\"151\":1}}],[\"位固定为\",{\"1\":{\"103\":1}}],[\"位尾数只存储小数部分\",{\"1\":{\"82\":1}}],[\"位存的是\",{\"1\":{\"82\":1}}],[\"位就是\",{\"1\":{\"82\":1}}],[\"位就代表\",{\"1\":{\"82\":1}}],[\"位成\",{\"1\":{\"82\":1}}],[\"位来表示的浮点数\",{\"1\":{\"82\":2}}],[\"位则表示二进制数据\",{\"1\":{\"80\":1}}],[\"位宽越大\",{\"1\":{\"75\":1}}],[\"位的计数器\",{\"1\":{\"246\":1}}],[\"位的无符号数\",{\"1\":{\"246\":1}}],[\"位的空间\",{\"1\":{\"82\":1}}],[\"位的\",{\"1\":{\"75\":1,\"80\":1,\"159\":1}}],[\"位和\",{\"1\":{\"75\":2}}],[\"位\",{\"1\":{\"57\":1,\"74\":1,\"75\":5,\"82\":11,\"145\":2,\"151\":1,\"159\":1}}],[\"类是预留的分类\",{\"1\":{\"154\":1}}],[\"类常被用于多播\",{\"1\":{\"154\":1}}],[\"类地址是没有主机号的\",{\"1\":{\"154\":1}}],[\"类和\",{\"1\":{\"154\":1}}],[\"类主要分为两个部分\",{\"1\":{\"153\":1}}],[\"类似于数学上的科学记数法\",{\"1\":{\"82\":1}}],[\"类型\",{\"1\":{\"142\":3}}],[\"类型是时间超时\",{\"1\":{\"143\":1}}],[\"类型是\",{\"1\":{\"80\":1}}],[\"类型变量\",{\"1\":{\"57\":1}}],[\"类型数据则作为\",{\"1\":{\"57\":1}}],[\"类型数据作为\",{\"1\":{\"57\":1}}],[\"类型的数字\",{\"1\":{\"80\":1}}],[\"类型的数字作为例子\",{\"1\":{\"80\":1}}],[\"类型的数据\",{\"1\":{\"57\":1}}],[\"类型的数据是\",{\"1\":{\"57\":1}}],[\"类型的名字很奇怪\",{\"1\":{\"57\":1}}],[\"类里\",{\"1\":{\"57\":1}}],[\"类会经常被多个线程使用\",{\"1\":{\"57\":1}}],[\"空间\",{\"1\":{\"57\":1}}],[\"浪费一部分\",{\"1\":{\"57\":1}}],[\"伪共享实际上是用空间换时间的思想\",{\"1\":{\"57\":1}}],[\"伪共享问题\",{\"1\":{\"57\":1}}],[\"伪共享是什么\",{\"0\":{\"56\":1}}],[\"宏定义\",{\"1\":{\"57\":1}}],[\"内部服务器建立连接\",{\"1\":{\"138\":1}}],[\"内部包含了\",{\"1\":{\"114\":1,\"280\":1}}],[\"内部的帧必须是严格有序的\",{\"1\":{\"106\":1}}],[\"内部的寄存器\",{\"1\":{\"78\":1}}],[\"内部还有一些组件\",{\"1\":{\"75\":1}}],[\"内容来知晓\",{\"1\":{\"72\":2}}],[\"内核\",{\"1\":{\"269\":1}}],[\"内核都会发送\",{\"1\":{\"260\":1}}],[\"内核态\",{\"1\":{\"252\":1}}],[\"内核参数\",{\"1\":{\"193\":1}}],[\"内核自动创建的\",{\"1\":{\"181\":1}}],[\"内核从syn队列取出一条半连接队列\",{\"1\":{\"169\":1}}],[\"内核会为每个连接建立内存缓冲区\",{\"1\":{\"198\":1}}],[\"内核会把该链接放到syn队列\",{\"1\":{\"169\":1}}],[\"内核会触发一个软中断\",{\"1\":{\"72\":1}}],[\"内核里常用的一种锁\",{\"1\":{\"72\":1}}],[\"内核里的调度器\",{\"1\":{\"58\":1}}],[\"内核线程\",{\"1\":{\"72\":1}}],[\"内核中会有一个\",{\"1\":{\"60\":1}}],[\"内核中\",{\"1\":{\"58\":1,\"62\":1}}],[\"内核中存在\",{\"1\":{\"57\":1}}],[\"内存限制\",{\"1\":{\"205\":1}}],[\"内存资源\",{\"1\":{\"164\":1}}],[\"内存的地址是从\",{\"1\":{\"74\":1}}],[\"内存的频率\",{\"1\":{\"53\":1}}],[\"内存\",{\"0\":{\"74\":1}}],[\"内存中的值还依然是\",{\"1\":{\"67\":1}}],[\"内存与\",{\"1\":{\"64\":1}}],[\"内存地址是连续排列布局的\",{\"1\":{\"57\":1}}],[\"内存共被划分为\",{\"1\":{\"49\":1}}],[\"内存等\",{\"1\":{\"20\":1}}],[\"避免频繁硬中断\",{\"1\":{\"72\":1}}],[\"避免\",{\"1\":{\"57\":1,\"215\":1}}],[\"避免伪共享的方法\",{\"0\":{\"57\":1}}],[\"避免在服务端存储用户的敏感信息\",{\"1\":{\"47\":1}}],[\"失效的现象称为伪共享\",{\"1\":{\"56\":1}}],[\"之间没有依赖关系\",{\"1\":{\"277\":1}}],[\"之间并没有依赖\",{\"1\":{\"113\":1}}],[\"之间\",{\"1\":{\"86\":1}}],[\"之间其实并没有任何的关系\",{\"1\":{\"56\":1}}],[\"之所以不同\",{\"1\":{\"158\":1}}],[\"之所以\",{\"1\":{\"75\":1}}],[\"之后进入close\",{\"1\":{\"257\":1}}],[\"之后进入close状态\",{\"1\":{\"38\":1,\"255\":1}}],[\"之后进入fin\",{\"1\":{\"256\":1}}],[\"之后再循环回到\",{\"1\":{\"246\":1}}],[\"之后还没有\",{\"1\":{\"243\":1}}],[\"之后客户端处于established\",{\"1\":{\"238\":1}}],[\"之后客户端处于syn\",{\"1\":{\"238\":1}}],[\"之后客户端进入fin\",{\"1\":{\"35\":1,\"255\":1}}],[\"之后建立连接就不需要握手了\",{\"1\":{\"196\":1}}],[\"之后处于\",{\"1\":{\"179\":1}}],[\"之后的请求和响应都会复用这条连接\",{\"1\":{\"133\":1}}],[\"之后\",{\"1\":{\"56\":1,\"64\":1,\"129\":2,\"146\":1}}],[\"之后才会被\",{\"1\":{\"49\":1}}],[\"之后服务端进入last\",{\"1\":{\"37\":1,\"255\":1}}],[\"另一个tcp\",{\"1\":{\"188\":1}}],[\"另一个是该设备连接在交换机的哪个端口上\",{\"1\":{\"306\":1}}],[\"另一个是能防止序列号回绕\",{\"1\":{\"246\":1}}],[\"另一个是\",{\"1\":{\"49\":1}}],[\"另一类是通知出错原因的错误消息\",{\"1\":{\"139\":1}}],[\"另外一个是序号\",{\"1\":{\"142\":1}}],[\"另外\",{\"1\":{\"57\":1,\"68\":1,\"69\":1,\"185\":1}}],[\"另外由于\",{\"1\":{\"56\":1}}],[\"⑤\",{\"1\":{\"56\":3}}],[\"已建立的tcp连接\",{\"0\":{\"249\":1}}],[\"已建立连接或者正在建立连接的两方\",{\"1\":{\"24\":2}}],[\"已经不是\",{\"1\":{\"275\":1}}],[\"已经被相同四元组的连接占用的时候\",{\"1\":{\"193\":1}}],[\"已经没有其他成员了\",{\"1\":{\"139\":1}}],[\"已完成\",{\"1\":{\"177\":1}}],[\"已完成的\",{\"1\":{\"176\":1}}],[\"已修改\",{\"1\":{\"56\":3,\"69\":6}}],[\"已失效\",{\"1\":{\"56\":1,\"69\":2}}],[\"④\",{\"1\":{\"56\":3}}],[\"共用同一个\",{\"1\":{\"277\":1}}],[\"共分为\",{\"1\":{\"151\":1}}],[\"共\",{\"1\":{\"145\":1}}],[\"共计发送\",{\"1\":{\"139\":2}}],[\"共享\",{\"1\":{\"56\":2,\"69\":5}}],[\"共有\",{\"1\":{\"49\":1}}],[\"此外\",{\"1\":{\"297\":1}}],[\"此时就会阻塞住所有的\",{\"1\":{\"277\":1}}],[\"此时如果收到相同四元组的syn包就会跳过2msl\",{\"1\":{\"265\":1}}],[\"此时fin是一个乱序的报文\",{\"1\":{\"263\":1}}],[\"此时服务端会认为这个\",{\"1\":{\"250\":1}}],[\"此时在该网段内\",{\"1\":{\"139\":1}}],[\"此时指令还在内存中\",{\"1\":{\"75\":1}}],[\"此时会发送消息给其他\",{\"1\":{\"69\":1}}],[\"此时其\",{\"1\":{\"69\":1}}],[\"此时其他\",{\"1\":{\"69\":1}}],[\"此时\",{\"1\":{\"56\":2,\"69\":1,\"138\":1,\"142\":1,\"179\":1,\"197\":1}}],[\"此时他发送数据的能力呈线性增长\",{\"1\":{\"28\":1}}],[\"此\",{\"1\":{\"56\":1}}],[\"大的值\",{\"1\":{\"275\":1}}],[\"大家理解成有一个全局\",{\"1\":{\"181\":1}}],[\"大大提升了安全性\",{\"1\":{\"159\":1}}],[\"大大提高了传输的性能\",{\"1\":{\"159\":1}}],[\"大致可以分为两大类\",{\"1\":{\"139\":1}}],[\"大部分实现\",{\"1\":{\"91\":1}}],[\"大小的偏移量\",{\"1\":{\"224\":1,\"225\":1}}],[\"大小的数据到\",{\"1\":{\"56\":2}}],[\"大小是由接收方指定的\",{\"1\":{\"224\":1}}],[\"大小\",{\"1\":{\"143\":1,\"174\":2}}],[\"大小来排序的\",{\"1\":{\"61\":1}}],[\"大约\",{\"1\":{\"49\":2}}],[\"③\",{\"1\":{\"56\":1}}],[\"独占状态下的数据就会变成共享状态\",{\"1\":{\"69\":1}}],[\"独占状态的时候\",{\"1\":{\"69\":1}}],[\"独占\",{\"1\":{\"56\":1,\"69\":6}}],[\"②\",{\"1\":{\"56\":1}}],[\"只是前者明确了数据帧中包含的是arp协议的数据\",{\"1\":{\"304\":1}}],[\"只是为了从全连接队列里取出一条连接\",{\"1\":{\"182\":1}}],[\"只指路不带路\",{\"0\":{\"296\":1}}],[\"只需重新发送这一小段\",{\"1\":{\"287\":1}}],[\"只需要传输丢失的这个分片\",{\"1\":{\"174\":1}}],[\"只需要建立一次\",{\"1\":{\"106\":1}}],[\"只需要\",{\"1\":{\"49\":1}}],[\"只关闭发送方向而不关闭读取方向\",{\"1\":{\"261\":1}}],[\"只用重发丢失片\",{\"1\":{\"242\":1}}],[\"只丢了一小部分\",{\"1\":{\"218\":1}}],[\"只要仍保有上下文信息\",{\"1\":{\"281\":1}}],[\"只要一端没有明确的提出断开连接\",{\"1\":{\"252\":1}}],[\"只要发生超时重传就会认为网络出现了拥塞\",{\"1\":{\"215\":1}}],[\"只要定时跟服务端的内容对账一下\",{\"1\":{\"213\":1}}],[\"只要进程能及时地调用\",{\"1\":{\"198\":1}}],[\"只要\",{\"1\":{\"188\":1,\"212\":1,\"229\":1}}],[\"只要是个连接就行\",{\"1\":{\"183\":1}}],[\"只要任意一端没有明确提出断开连接\",{\"1\":{\"88\":1}}],[\"只支持ecdhe算法\",{\"1\":{\"120\":1}}],[\"只会影响该流\",{\"1\":{\"113\":1}}],[\"只会读写变量\",{\"1\":{\"56\":2}}],[\"只在应用层做了改变\",{\"1\":{\"101\":1}}],[\"只能由目标主机进行\",{\"1\":{\"158\":1}}],[\"只能通过定时器不断地拉取消息\",{\"1\":{\"100\":1}}],[\"只能用\",{\"1\":{\"81\":1}}],[\"只好用较小的容量\",{\"1\":{\"78\":1}}],[\"只有接收者才会接受\",{\"1\":{\"306\":1}}],[\"只有源\",{\"1\":{\"150\":1}}],[\"只有拿到了\",{\"1\":{\"67\":1}}],[\"只有在处理完有序的数据后\",{\"1\":{\"277\":1}}],[\"只有在未能命中强制缓存的时候\",{\"1\":{\"94\":1}}],[\"只有在\",{\"1\":{\"67\":1}}],[\"只有当修改过的\",{\"1\":{\"66\":1}}],[\"里是如何存储的\",{\"1\":{\"82\":1}}],[\"里是对齐的\",{\"1\":{\"57\":1}}],[\"里都有\",{\"1\":{\"69\":1}}],[\"里都没有会发生更新操作的数据\",{\"1\":{\"57\":1}}],[\"里存放的是\",{\"1\":{\"66\":1}}],[\"里选择任务\",{\"1\":{\"61\":3}}],[\"里\",{\"1\":{\"60\":1,\"66\":5,\"67\":1,\"69\":1,\"82\":1,\"146\":1}}],[\"里面的数据\",{\"1\":{\"69\":2}}],[\"里面的数据的时候\",{\"1\":{\"69\":1}}],[\"里面的数据还是不一致的\",{\"1\":{\"67\":1}}],[\"里面的这个\",{\"1\":{\"66\":1}}],[\"里面定义的这些变量都是\",{\"1\":{\"57\":1}}],[\"里面\",{\"1\":{\"56\":1,\"60\":1,\"65\":1,\"68\":1,\"69\":1}}],[\"里的位置\",{\"1\":{\"66\":1}}],[\"里的数据和内存里面的数据是一致性的\",{\"1\":{\"69\":1}}],[\"里的数据是干净的\",{\"1\":{\"69\":1}}],[\"里的数据已经失效了\",{\"1\":{\"69\":1}}],[\"里的数据写回到内存\",{\"1\":{\"66\":1}}],[\"里的数据有没有被标记为脏的\",{\"1\":{\"66\":1}}],[\"里的数据结构\",{\"1\":{\"49\":1}}],[\"里的这个\",{\"1\":{\"66\":1}}],[\"里的话\",{\"1\":{\"66\":1}}],[\"里的\",{\"1\":{\"52\":1,\"69\":1,\"82\":1,\"114\":1,\"280\":1}}],[\"里的指令\",{\"1\":{\"52\":1}}],[\"①\",{\"1\":{\"56\":1}}],[\"又没有数据交互的情况下\",{\"1\":{\"270\":1}}],[\"又是怎么知道当前网络出现了拥塞\",{\"1\":{\"215\":1}}],[\"又是如何知道对方\",{\"1\":{\"136\":1}}],[\"又叫做远程过程调用\",{\"1\":{\"132\":1}}],[\"又由于\",{\"1\":{\"57\":1}}],[\"又因为\",{\"1\":{\"56\":1}}],[\"又称d\",{\"1\":{\"24\":1}}],[\"线程资源等\",{\"1\":{\"164\":1}}],[\"线程\",{\"1\":{\"56\":2}}],[\"线程绑定在某一个\",{\"1\":{\"53\":1}}],[\"线程可能在不同\",{\"1\":{\"53\":1}}],[\"相加起来的总字节数\",{\"1\":{\"278\":1}}],[\"相加后就是指数位的值了\",{\"1\":{\"82\":1}}],[\"相同机器上不能够在该\",{\"1\":{\"189\":1}}],[\"相同\",{\"1\":{\"188\":1}}],[\"相当于把主机上的所有\",{\"1\":{\"188\":1}}],[\"相当于\",{\"1\":{\"159\":2,\"197\":1}}],[\"相当于指明了小数点在数据中的位置\",{\"1\":{\"82\":1}}],[\"相比原生的\",{\"1\":{\"142\":1}}],[\"相比以前变多了\",{\"1\":{\"100\":1}}],[\"相比\",{\"1\":{\"82\":1}}],[\"相比进程的\",{\"1\":{\"58\":1}}],[\"相反内存\",{\"1\":{\"78\":1}}],[\"相反如果线程都在同一个核心上执行\",{\"1\":{\"53\":1}}],[\"相对应的数据将会不同\",{\"1\":{\"64\":1}}],[\"相应的精度就更高了一点\",{\"1\":{\"82\":1}}],[\"相应的缓冲区就会被释放\",{\"1\":{\"27\":1}}],[\"相应改变本端的窗口大小\",{\"1\":{\"27\":1}}],[\"虽然现在网络的\",{\"1\":{\"100\":1}}],[\"虽然是做到了写传播\",{\"1\":{\"67\":1}}],[\"虽然是普通任务\",{\"1\":{\"60\":1}}],[\"虽然变量\",{\"1\":{\"56\":1}}],[\"虽然\",{\"1\":{\"53\":1}}],[\"虽然只能执行一个线程\",{\"1\":{\"53\":1}}],[\"从指数增长变成线性增长\",{\"1\":{\"217\":1}}],[\"从客户端接收到\",{\"1\":{\"162\":1}}],[\"从\",{\"1\":{\"143\":1}}],[\"从中选择一个服务器\",{\"1\":{\"137\":1}}],[\"从数字证书中取出服务器的公钥\",{\"1\":{\"129\":2}}],[\"从服务器获取指定的资源\",{\"1\":{\"90\":1}}],[\"从而帮助其正常关闭\",{\"1\":{\"163\":1}}],[\"从而使得所有\",{\"1\":{\"153\":1}}],[\"从而控制发送的包大小\",{\"1\":{\"143\":1}}],[\"从而确定路径的\",{\"1\":{\"143\":1}}],[\"从而缩减字符串长度\",{\"1\":{\"103\":1}}],[\"从而会导致执行结果的错误\",{\"1\":{\"67\":1}}],[\"从而让优先级高一些的任务执行更多时间\",{\"1\":{\"62\":1}}],[\"从而换来性能的提升\",{\"1\":{\"57\":1}}],[\"从而出现\",{\"1\":{\"56\":1}}],[\"从上面的宏定义\",{\"1\":{\"57\":1}}],[\"从内存读取数据的单位是\",{\"1\":{\"57\":1}}],[\"从内存读取数据到\",{\"1\":{\"56\":2}}],[\"从内存加载过来的实际存放数据\",{\"1\":{\"49\":1}}],[\"从宏观上看起来各个线程同时在执行\",{\"1\":{\"53\":1}}],[\"<\",{\"1\":{\"52\":1,\"216\":1}}],[\"数最多为\",{\"1\":{\"205\":1}}],[\"数字证书\",{\"1\":{\"128\":1}}],[\"数字签名\",{\"1\":{\"128\":1}}],[\"数字是从小到大的\",{\"1\":{\"52\":1}}],[\"数据帧包含的是apr协议的数据\",{\"1\":{\"304\":1}}],[\"数据帧包含的是ip协议的数据\",{\"1\":{\"304\":1}}],[\"数据会被切分成一块块的网络包\",{\"1\":{\"297\":1}}],[\"数据字节数\",{\"1\":{\"248\":1}}],[\"数据长度\",{\"1\":{\"248\":2}}],[\"数据发送时刻到接收到确认的时刻的差值\",{\"1\":{\"233\":1}}],[\"数据大小\",{\"1\":{\"230\":1}}],[\"数据可以无差错\",{\"1\":{\"174\":1}}],[\"数据链路\",{\"1\":{\"158\":1}}],[\"数据链路层负责在相邻节点之间传输数据帧\",{\"1\":{\"283\":1}}],[\"数据链路层\",{\"1\":{\"283\":2}}],[\"数据链路层加上mac头\",{\"1\":{\"146\":1}}],[\"数据链路层带上\",{\"1\":{\"146\":1}}],[\"数据报文\",{\"1\":{\"248\":1}}],[\"数据报作废\",{\"1\":{\"158\":1}}],[\"数据报在被重组的时候\",{\"1\":{\"158\":1}}],[\"数据报时\",{\"1\":{\"143\":1}}],[\"数据报传递给链路层\",{\"1\":{\"137\":1}}],[\"数据报\",{\"1\":{\"137\":1}}],[\"数据报的时候\",{\"1\":{\"136\":1}}],[\"数据包\",{\"1\":{\"174\":1,\"305\":1}}],[\"数据包就会被分片\",{\"1\":{\"158\":1}}],[\"数据包大小大于\",{\"1\":{\"158\":1}}],[\"数据包不会流向网络\",{\"1\":{\"157\":1}}],[\"数据包的时间延迟\",{\"1\":{\"142\":1}}],[\"数据包内包含多个字段\",{\"1\":{\"142\":1}}],[\"数据包下一跳\",{\"1\":{\"136\":1}}],[\"数据包在经过传输层时可能会被拆分成多个小数据包\",{\"1\":{\"25\":1}}],[\"数据加密是使用记录协议\",{\"1\":{\"130\":1}}],[\"数据\",{\"1\":{\"129\":1,\"130\":1}}],[\"数据才会交给\",{\"1\":{\"113\":1}}],[\"数据才会写入到内存里\",{\"1\":{\"67\":1}}],[\"数据也无法被\",{\"1\":{\"113\":1}}],[\"数据的\",{\"1\":{\"86\":1}}],[\"数据的更新\",{\"1\":{\"67\":1}}],[\"数据总线\",{\"1\":{\"76\":2}}],[\"数据被缓存在\",{\"1\":{\"69\":1}}],[\"数据只存储在一个\",{\"1\":{\"69\":1}}],[\"数据更新时\",{\"1\":{\"67\":1}}],[\"数据所对应的\",{\"1\":{\"66\":1}}],[\"数据已经在\",{\"1\":{\"66\":1}}],[\"数据不光是只有读操作\",{\"1\":{\"64\":1}}],[\"数据块组成\",{\"1\":{\"49\":1}}],[\"数据块\",{\"1\":{\"49\":1}}],[\"数据缓存\",{\"0\":{\"51\":1},\"1\":{\"49\":1}}],[\"数据库\",{\"0\":{\"7\":1},\"1\":{\"47\":1}}],[\"你只需要跟服务器建立1个连接就够了\",{\"1\":{\"213\":1}}],[\"你就把聊天记录给同步过去了\",{\"1\":{\"213\":1}}],[\"你就得建立1000个连接\",{\"1\":{\"213\":1}}],[\"你就认为它是一个常量\",{\"1\":{\"60\":1}}],[\"你聊天软件里有1000个好友\",{\"1\":{\"213\":1}}],[\"你小区家可以叫\",{\"1\":{\"156\":1}}],[\"你会得到下面这个结果\",{\"1\":{\"83\":1}}],[\"你可能会有疑问为什么要加上偏移量呢\",{\"1\":{\"82\":1}}],[\"你可能会觉得\",{\"1\":{\"57\":1}}],[\"你可以看到下图\",{\"1\":{\"80\":1}}],[\"你可以不用管\",{\"1\":{\"60\":1}}],[\"你觉得先遍历再排序速度快\",{\"1\":{\"52\":1}}],[\"你好\",{\"1\":{\"2\":1}}],[\"还需继续需要路由器转发\",{\"1\":{\"307\":1}}],[\"还需要在网络包前面加一个mac头部\",{\"1\":{\"304\":1}}],[\"还需要网络运营商对现有的设备进行升级\",{\"1\":{\"159\":1}}],[\"还需要多一步操作来判断是否为负数\",{\"1\":{\"80\":1}}],[\"还未抵达终点\",{\"1\":{\"307\":1}}],[\"还会存放发送请求的时间值\",{\"1\":{\"142\":1}}],[\"还可以拥有前向安全性\",{\"1\":{\"120\":1}}],[\"还得把加法反转成减法\",{\"1\":{\"80\":1}}],[\"还要保证小数点左侧只有\",{\"1\":{\"82\":1}}],[\"还要定位\",{\"1\":{\"66\":1}}],[\"还要考虑普通任务的权重值\",{\"1\":{\"60\":1}}],[\"还有一个作用是故意设置不分片\",{\"1\":{\"143\":1}}],[\"还有一个区别\",{\"1\":{\"72\":1}}],[\"还有写操作\",{\"1\":{\"64\":1}}],[\"还有两个信息\",{\"1\":{\"49\":1}}],[\"还是重传之后的数据包\",{\"1\":{\"275\":1}}],[\"还是重传所有的问题\",{\"1\":{\"234\":1}}],[\"还是异常退出\",{\"1\":{\"260\":1}}],[\"还是接收方回应的\",{\"1\":{\"236\":1}}],[\"还是可以使用端口\",{\"1\":{\"191\":1}}],[\"还是会造成内容的篡改\",{\"1\":{\"128\":1}}],[\"还是先排序再遍历速度快呢\",{\"1\":{\"52\":1}}],[\"还是\",{\"1\":{\"52\":2}}],[\"意味着绑定了\",{\"1\":{\"188\":1}}],[\"意味着\",{\"1\":{\"82\":1,\"162\":1}}],[\"意味着第一次加载之后不会再修改\",{\"1\":{\"57\":1}}],[\"意味着此时至少可以选择跳转到两段不同的指令执行\",{\"1\":{\"52\":1}}],[\"意味着缓存命中\",{\"1\":{\"50\":1}}],[\"组合上进行绑定\",{\"1\":{\"189\":1}}],[\"组合\",{\"1\":{\"189\":1}}],[\"组织管理\",{\"1\":{\"156\":1}}],[\"组播地址\",{\"1\":{\"159\":1}}],[\"组播组成员了\",{\"1\":{\"139\":1}}],[\"组播成员\",{\"1\":{\"139\":1}}],[\"组\",{\"1\":{\"139\":1,\"151\":1}}],[\"组的其他成员\",{\"1\":{\"139\":1}}],[\"组标记\",{\"1\":{\"49\":1}}],[\"组成\",{\"1\":{\"49\":1}}],[\"组成的\",{\"1\":{\"49\":1}}],[\"于是会触发第一次挥手的重传机制\",{\"1\":{\"257\":1}}],[\"于是发送端就可以根据这个接收端的处理能力来发送数据\",{\"1\":{\"222\":1}}],[\"于是握手包一来一回\",{\"1\":{\"181\":1}}],[\"于是也调用\",{\"1\":{\"179\":1}}],[\"于是继续向该网络转发\",{\"1\":{\"139\":1}}],[\"于是这样就减少到只需\",{\"1\":{\"120\":1}}],[\"于是为了把指数转换成无符号整数\",{\"1\":{\"82\":1}}],[\"于是为了能一次计算大数的运算\",{\"1\":{\"75\":1}}],[\"于是内核就会调用对应的中断处理程序来处理该事件\",{\"1\":{\"72\":1}}],[\"于是标记\",{\"1\":{\"69\":1}}],[\"于是就会发送\",{\"1\":{\"270\":1}}],[\"于是就会释放连接\",{\"1\":{\"250\":1}}],[\"于是就会回\",{\"1\":{\"249\":1}}],[\"于是就会造成精度缺失的情况\",{\"1\":{\"81\":1}}],[\"于是就让\",{\"1\":{\"82\":1}}],[\"于是就可以随便操作该数据\",{\"1\":{\"69\":1}}],[\"于是就有了以下这个公式\",{\"1\":{\"60\":1}}],[\"于是我们肯定是要把\",{\"1\":{\"64\":1}}],[\"于是高权重的获得的实际运行时间自然就多了\",{\"1\":{\"60\":1}}],[\"于是它主动配合\",{\"1\":{\"138\":1}}],[\"于是它为每个任务安排一个虚拟运行时间\",{\"1\":{\"60\":1}}],[\"于是它们可能会位于同一个\",{\"1\":{\"57\":1}}],[\"于是分为了这几种调度类\",{\"1\":{\"59\":1}}],[\"于是分支预测就会缓存\",{\"1\":{\"52\":1}}],[\"于是只要数据被频繁地读取访问\",{\"1\":{\"57\":1}}],[\"于是各个线程就按时间片交替地占用\",{\"1\":{\"53\":1}}],[\"于是执行速度就会很快\",{\"1\":{\"52\":1}}],[\"于是\",{\"1\":{\"49\":1,\"68\":1,\"138\":1,\"230\":1}}],[\"索引\",{\"1\":{\"49\":1}}],[\"包头里的目标地址了\",{\"1\":{\"307\":1}}],[\"包头包首部长度采用固定的值\",{\"1\":{\"159\":1}}],[\"包含了接收方和发送方的mac地址等信息\",{\"1\":{\"291\":1}}],[\"包含了授权码的获取和交换流程\",{\"1\":{\"44\":1}}],[\"包丢了\",{\"1\":{\"236\":1}}],[\"包都会带上发送时的时间戳\",{\"1\":{\"210\":1}}],[\"包括数据的编码\",{\"1\":{\"283\":1}}],[\"包括\",{\"1\":{\"204\":1}}],[\"包括组标记\",{\"1\":{\"49\":1}}],[\"包之外该位必须设置为\",{\"1\":{\"201\":1}}],[\"包插入一个文件结束符\",{\"1\":{\"179\":1}}],[\"包转发给相应的下一个路由器\",{\"1\":{\"157\":1}}],[\"包首部中的目标地址\",{\"1\":{\"157\":1}}],[\"包首部的分片禁止标志位设置为\",{\"1\":{\"143\":1}}],[\"包会被路由器屏蔽\",{\"1\":{\"153\":1}}],[\"包到达了目的主机\",{\"1\":{\"143\":1}}],[\"包后\",{\"1\":{\"143\":1}}],[\"包时\",{\"1\":{\"143\":1,\"157\":1}}],[\"包是否到达了目的主机呢\",{\"1\":{\"143\":1}}],[\"包是否成功送达目标地址\",{\"1\":{\"139\":1}}],[\"包的生存期限\",{\"1\":{\"143\":1}}],[\"包\",{\"1\":{\"142\":1,\"143\":1,\"153\":1,\"179\":2}}],[\"包因为某种原因未能达到目标地址\",{\"1\":{\"139\":1}}],[\"包被废弃的原因和改善网络设置等\",{\"1\":{\"139\":1}}],[\"需要两方都支持sack\",{\"1\":{\"235\":1}}],[\"需要两次消息往返\",{\"1\":{\"107\":1}}],[\"需要双方同时打开才能有效\",{\"1\":{\"196\":1}}],[\"需要通过端口进行寻址\",{\"1\":{\"187\":1}}],[\"需要在传输之前建立连接\",{\"1\":{\"174\":1}}],[\"需要在服务器端设置适当的\",{\"1\":{\"46\":1}}],[\"需要进行分片但设置了不分片位\",{\"1\":{\"143\":1}}],[\"需要建立\",{\"1\":{\"106\":1}}],[\"需要根据精度舍入\",{\"1\":{\"83\":1}}],[\"需要把指数转换成无符号整数\",{\"1\":{\"82\":1}}],[\"需要注意一点\",{\"1\":{\"81\":1}}],[\"需要支持多个\",{\"1\":{\"75\":1}}],[\"需要每时每刻监听总线上的一切活动\",{\"1\":{\"68\":1}}],[\"需要同步给其他\",{\"1\":{\"67\":1}}],[\"需要一个偏移量\",{\"1\":{\"49\":1}}],[\"答案是\",{\"1\":{\"49\":1}}],[\"那题目中的\",{\"1\":{\"270\":1}}],[\"那就是打开\",{\"1\":{\"193\":1}}],[\"那就可以不用存起来了\",{\"1\":{\"82\":1}}],[\"那我们就需要依次遍历\",{\"1\":{\"183\":1}}],[\"那不是每个网络都要配一个\",{\"1\":{\"137\":1}}],[\"那如果\",{\"1\":{\"137\":1}}],[\"那\",{\"1\":{\"136\":1}}],[\"那后续双方就还是老样子继续用普通\",{\"1\":{\"134\":1}}],[\"那必然是减少证书的大小\",{\"1\":{\"121\":1}}],[\"那两个近似数相加\",{\"1\":{\"83\":1}}],[\"那二进制小数\",{\"1\":{\"82\":1}}],[\"那怎么在对应的\",{\"1\":{\"49\":1}}],[\"那么第二和第三次挥手就会合并传输\",{\"1\":{\"262\":1}}],[\"那么新的接收窗口大小\",{\"1\":{\"226\":1}}],[\"那么可用窗口大小的计算就可以是\",{\"1\":{\"224\":1}}],[\"那么可以把数据包直接发送到目标主机\",{\"1\":{\"155\":1}}],[\"那么后续也就可以发送\",{\"1\":{\"223\":1}}],[\"那么也不能扔给应用层去处理\",{\"1\":{\"203\":1}}],[\"那么也需要把该数据更新到自己的\",{\"1\":{\"68\":1}}],[\"那么接收窗口就可以无限地放大\",{\"1\":{\"198\":1}}],[\"那么客户端要与服务端\",{\"1\":{\"191\":1}}],[\"那么只要四元组中其中一个元素发生了变化\",{\"1\":{\"191\":1}}],[\"那么该进程就可以绑定成功\",{\"1\":{\"190\":1}}],[\"那么允许绑定\",{\"1\":{\"188\":1}}],[\"那么执行\",{\"1\":{\"188\":2,\"189\":1}}],[\"那么查找半连接的算法复杂度就回到o\",{\"1\":{\"183\":1}}],[\"那么现在有一个第三次握手来了\",{\"1\":{\"183\":1}}],[\"那么服务端\",{\"1\":{\"176\":1}}],[\"那么此时服务端上就会出现\",{\"1\":{\"166\":1}}],[\"那么对于\",{\"1\":{\"158\":1}}],[\"那么对于这个\",{\"1\":{\"67\":1}}],[\"那么你就需要去申请购买一个公有\",{\"1\":{\"156\":1}}],[\"那么你可以考虑改变任务的优先级以及调度策略\",{\"1\":{\"62\":1}}],[\"那么它会发送一个确认报文\",{\"1\":{\"221\":1}}],[\"那么它表示本机上的所有ipv4地址\",{\"1\":{\"148\":1}}],[\"那么它的\",{\"1\":{\"103\":1}}],[\"那么就会重用这个连接\",{\"1\":{\"193\":1}}],[\"那么就会阻塞该\",{\"1\":{\"109\":1}}],[\"那么就表示不同的\",{\"1\":{\"191\":1}}],[\"那么就无法对\",{\"1\":{\"164\":1}}],[\"那么就要帮忙把它写回到内存\",{\"1\":{\"66\":1}}],[\"那么当发生数据丢失\",{\"1\":{\"277\":1}}],[\"那么当\",{\"1\":{\"109\":1,\"158\":1}}],[\"那么不仅要保证基数为\",{\"1\":{\"82\":1}}],[\"那么一次只能计算\",{\"1\":{\"75\":1}}],[\"那么问题就来了\",{\"1\":{\"67\":1}}],[\"那么会带来多核心的缓存一致性\",{\"1\":{\"67\":1}}],[\"那么大部分时间里\",{\"1\":{\"66\":1}}],[\"那么如果数据写入\",{\"1\":{\"64\":1}}],[\"那么在执行\",{\"1\":{\"192\":1}}],[\"那么在完成首次通信过程后\",{\"1\":{\"123\":1}}],[\"那么在\",{\"1\":{\"60\":1,\"261\":1}}],[\"那么这个传输过程是存在时延的\",{\"1\":{\"226\":1}}],[\"那么这个具体的原因将由\",{\"1\":{\"139\":1}}],[\"那么这个设备就将自己的\",{\"1\":{\"136\":1}}],[\"那么这个时候\",{\"1\":{\"69\":1}}],[\"那么这两个数据是位于同一个\",{\"1\":{\"56\":1}}],[\"那么这一方就会认为数据包丢失\",{\"1\":{\"24\":1}}],[\"那么这一方就会认定出现丢包现象\",{\"1\":{\"24\":1}}],[\"那么其数据的\",{\"1\":{\"53\":1}}],[\"那么前几次循环命中\",{\"1\":{\"52\":1}}],[\"那么\",{\"1\":{\"28\":1,\"52\":1,\"60\":1,\"67\":1,\"69\":1,\"80\":1,\"82\":1,\"136\":1,\"219\":1,\"285\":1}}],[\"都需要委托ip模块将数据封装成网络包发送给通信对象\",{\"1\":{\"303\":1}}],[\"都需要发出一个广播事件\",{\"1\":{\"68\":1}}],[\"都可以做流量控制\",{\"1\":{\"278\":1}}],[\"都可以保证一个报文一定能够到达接收端\",{\"1\":{\"203\":1}}],[\"都有独立的滑动窗口\",{\"1\":{\"278\":1}}],[\"都有自己的运行队列\",{\"1\":{\"61\":1}}],[\"都分配了一个独立的滑动窗口\",{\"1\":{\"277\":1}}],[\"都一致\",{\"1\":{\"276\":1}}],[\"都一下发送出去后\",{\"1\":{\"223\":1}}],[\"都一样的服务端发起连接了\",{\"1\":{\"164\":1}}],[\"都等来了\",{\"1\":{\"197\":1}}],[\"都依赖于自己的转换表\",{\"1\":{\"138\":1}}],[\"都统一使用\",{\"1\":{\"134\":1}}],[\"都不具备前向安全性\",{\"1\":{\"122\":1}}],[\"都不需要读写内存\",{\"1\":{\"66\":1}}],[\"都要等待重传\",{\"1\":{\"109\":1}}],[\"都对应一个软中断内核线程\",{\"1\":{\"72\":1}}],[\"都操作共同的变量\",{\"1\":{\"67\":1}}],[\"都会返回一个rst报文\",{\"1\":{\"271\":1}}],[\"都会将下一次超时时间间隔设为先前值的两倍\",{\"1\":{\"233\":1}}],[\"都会\",{\"1\":{\"67\":1}}],[\"都会相互影响\",{\"1\":{\"56\":1}}],[\"都会直接访问内存\",{\"1\":{\"49\":1}}],[\"都还不在\",{\"1\":{\"56\":1}}],[\"都是为了数据包能可靠的传输给对方\",{\"1\":{\"287\":1}}],[\"都是相互独立的\",{\"1\":{\"277\":1}}],[\"都是放在操作系统内存缓冲区中的\",{\"1\":{\"228\":1}}],[\"都是比较耗cpu的\",{\"1\":{\"185\":1}}],[\"都是不相同的\",{\"1\":{\"158\":1}}],[\"都是独立的\",{\"1\":{\"113\":1}}],[\"都是先变成\",{\"1\":{\"67\":1}}],[\"都是多核的\",{\"1\":{\"67\":1}}],[\"都是多核心的\",{\"1\":{\"53\":1}}],[\"都是由服务端主动关闭连接\",{\"1\":{\"166\":1}}],[\"都是由\",{\"1\":{\"59\":1}}],[\"都是应用于实时任务的\",{\"1\":{\"59\":1}}],[\"都是每个核心独有的\",{\"1\":{\"53\":1}}],[\"都是每个\",{\"1\":{\"49\":1}}],[\"value\",{\"1\":{\"103\":1,\"116\":1}}],[\"valid\",{\"1\":{\"49\":1}}],[\"vruntime\",{\"1\":{\"60\":7,\"61\":1,\"62\":2}}],[\"vue\",{\"1\":{\"5\":1,\"11\":1}}],[\"有着实际的传输功能\",{\"0\":{\"288\":1}}],[\"有一点差别\",{\"1\":{\"278\":1}}],[\"有一个叫慢启动门限\",{\"1\":{\"216\":1}}],[\"有一个前提条件\",{\"1\":{\"210\":1}}],[\"有一个协议基于总线嗅探机制实现了事务串行化\",{\"1\":{\"68\":1}}],[\"有一个\",{\"1\":{\"57\":1,\"205\":1}}],[\"有哪些数据被重复接收了\",{\"1\":{\"236\":1}}],[\"有的\",{\"1\":{\"229\":1}}],[\"有可能被动关闭连接的一方不能被正常的关闭\",{\"1\":{\"212\":1}}],[\"有序的\",{\"1\":{\"203\":1}}],[\"有序组装成\",{\"1\":{\"106\":1}}],[\"有拥塞控制和流量控制机制\",{\"1\":{\"174\":1}}],[\"有时防火墙或者网络设备的设置会导致tcp连接建立失败\",{\"1\":{\"169\":1}}],[\"有应对伪造\",{\"1\":{\"159\":1}}],[\"有了\",{\"1\":{\"137\":1}}],[\"有损压缩\",{\"1\":{\"99\":1}}],[\"有两个\",{\"1\":{\"153\":1}}],[\"有两个客户端\",{\"1\":{\"138\":1}}],[\"有两种实现方式\",{\"1\":{\"94\":1}}],[\"有两点作用\",{\"1\":{\"39\":1}}],[\"有\",{\"1\":{\"82\":2}}],[\"有下面这个结构体\",{\"1\":{\"57\":1}}],[\"有效位\",{\"1\":{\"49\":2}}],[\"为止\",{\"1\":{\"229\":1}}],[\"为高频出现在头部的字符串和字段建立了一张静态表\",{\"1\":{\"103\":1}}],[\"为\",{\"1\":{\"69\":1,\"82\":2,\"143\":1}}],[\"为什么每次建立tcp连接\",{\"0\":{\"246\":1}}],[\"为什么每次建立tcp链接的时候\",{\"0\":{\"240\":1}}],[\"为什么tcp层还需要mss\",{\"0\":{\"242\":1}}],[\"为什么是三次握手\",{\"0\":{\"239\":1}}],[\"为什么半连接队列要设计成哈希表\",{\"0\":{\"183\":1}}],[\"为什么需要\",{\"0\":{\"163\":1}}],[\"为什么需要三次握手而不是四次\",{\"0\":{\"40\":1}}],[\"为什么\",{\"0\":{\"162\":1}}],[\"为什么断网了还能ping通127\",{\"0\":{\"147\":1}}],[\"为什么计算机要用补码的方式来表示负数\",{\"1\":{\"80\":1}}],[\"为什么缓存没命中时\",{\"1\":{\"66\":1}}],[\"为脏\",{\"1\":{\"66\":1}}],[\"为了解决\",{\"1\":{\"262\":1}}],[\"为了解决这一问题\",{\"1\":{\"137\":1}}],[\"为了适应不同链路的mut不同\",{\"1\":{\"242\":1}}],[\"为了达到最佳的传输效能\",{\"1\":{\"242\":1}}],[\"为了安全性\",{\"1\":{\"240\":1}}],[\"为了在\",{\"1\":{\"215\":1}}],[\"为了保证能正常通信\",{\"1\":{\"151\":1}}],[\"为了兼容这些使用场景\",{\"1\":{\"134\":1}}],[\"为了考虑性能\",{\"1\":{\"67\":1}}],[\"为了防止这种情况发生\",{\"1\":{\"228\":1}}],[\"为了防止前面提到的\",{\"1\":{\"57\":1}}],[\"为了防止伪共享现象的发生\",{\"1\":{\"57\":1}}],[\"为了区别不同的内存块\",{\"1\":{\"49\":1}}],[\"因此即使移动设备的网络变化后\",{\"1\":{\"281\":1}}],[\"因此某一个\",{\"1\":{\"278\":1}}],[\"因此在到达\",{\"1\":{\"246\":1}}],[\"因此在不影响其他需要交互的任务\",{\"1\":{\"59\":1}}],[\"因此出于效率考虑\",{\"1\":{\"183\":1}}],[\"因此没有主机响应这个查询\",{\"1\":{\"139\":1}}],[\"因此它立即响应这个特定组查询\",{\"1\":{\"139\":1}}],[\"因此会有以下的问题\",{\"1\":{\"138\":1}}],[\"因此仅需\",{\"1\":{\"114\":1,\"280\":1}}],[\"因此可以并发不同的\",{\"1\":{\"106\":1}}],[\"因此后续的请求解码会阻塞到首次请求中丢失的数据包重传过来\",{\"1\":{\"104\":1}}],[\"因此当客户端需要获取通知时\",{\"1\":{\"100\":1}}],[\"因此你可以认为\",{\"1\":{\"82\":1}}],[\"因此如果要表示精度更高的小数\",{\"1\":{\"82\":1}}],[\"因此不需要给其他\",{\"1\":{\"69\":1}}],[\"因此这时候就需要排队\",{\"1\":{\"61\":1}}],[\"因此以\",{\"1\":{\"58\":1}}],[\"因此我们要来着手提高缓存的命中率\",{\"1\":{\"50\":1}}],[\"因此\",{\"1\":{\"49\":2,\"52\":1,\"56\":1,\"57\":3,\"61\":1,\"62\":2,\"67\":1,\"82\":2,\"137\":1,\"160\":1,\"198\":1}}],[\"因为需要\",{\"1\":{\"307\":1}}],[\"因为路由器是基于\",{\"1\":{\"307\":1}}],[\"因为滑动窗口并不是一成不变的\",{\"1\":{\"226\":1}}],[\"因为有\",{\"1\":{\"223\":1}}],[\"因为有的时候我们并不知道路由器的\",{\"1\":{\"143\":1}}],[\"因为有的小数无法可以用\",{\"1\":{\"83\":1}}],[\"因为大部分没丢\",{\"1\":{\"218\":1}}],[\"因为网络的传输能力是有限的\",{\"1\":{\"198\":1}}],[\"因为重传的时候还需要用到\",{\"1\":{\"198\":1}}],[\"因为开启了这个内核参数后\",{\"1\":{\"193\":1}}],[\"因为客户端的端口通常都没什么意义\",{\"1\":{\"192\":1}}],[\"因为客户端没有执行listen\",{\"1\":{\"181\":1}}],[\"因为内核是通过四元祖信息来定位一个\",{\"1\":{\"191\":1}}],[\"因为它也有\",{\"1\":{\"262\":1}}],[\"因为它的另外一个作用\",{\"1\":{\"188\":1}}],[\"因为它在ipv4中表示的是无效的目标地址\",{\"1\":{\"148\":1}}],[\"因为服务端并不会保存连接信息\",{\"1\":{\"185\":1}}],[\"因为队列里的都是不完整的连接\",{\"1\":{\"183\":1}}],[\"因为也是线性结构\",{\"1\":{\"183\":1}}],[\"因为半连接队列和全连接队列都是在执行\",{\"1\":{\"181\":1}}],[\"因为两台计算机要通讯\",{\"1\":{\"155\":1}}],[\"因为这个广播地址的\",{\"1\":{\"153\":1}}],[\"因为在数据链路层和传输层都会校验\",{\"1\":{\"160\":1}}],[\"因为在\",{\"1\":{\"153\":1}}],[\"因为在相同安全强度下\",{\"1\":{\"121\":1}}],[\"因为每个帧的头部会携带\",{\"1\":{\"106\":1}}],[\"因为对方还没建立好动态表\",{\"1\":{\"104\":1}}],[\"因为只有你这有这个数据\",{\"1\":{\"69\":1}}],[\"因为刚才\",{\"1\":{\"67\":1}}],[\"因为写回策略\",{\"1\":{\"67\":1}}],[\"因为线程的\",{\"1\":{\"58\":1}}],[\"因为\",{\"1\":{\"49\":1,\"138\":1,\"139\":1,\"179\":1,\"190\":1,\"212\":1}}],[\"因为生活永远不会停止教导\",{\"1\":{\"15\":1}}],[\"号和\",{\"1\":{\"56\":2}}],[\"号核心都能看到相同顺序的数据变化\",{\"1\":{\"67\":1}}],[\"号核心看到的是变量\",{\"1\":{\"67\":1}}],[\"号核心看到的变量\",{\"1\":{\"67\":1}}],[\"号核心收到的事件是反过来的\",{\"1\":{\"67\":1}}],[\"号核心先收到了\",{\"1\":{\"67\":1}}],[\"号核心先把\",{\"1\":{\"67\":2}}],[\"号核心更新数据的事件\",{\"1\":{\"67\":2}}],[\"号核心更新\",{\"1\":{\"67\":1}}],[\"号核心尝试从内存读取\",{\"1\":{\"67\":1}}],[\"号核心中的这个\",{\"1\":{\"67\":1}}],[\"号核心执行了\",{\"1\":{\"67\":1}}],[\"号核心同时运行两个线程\",{\"1\":{\"67\":1}}],[\"号核心和\",{\"1\":{\"67\":3}}],[\"号核心再从内存读取\",{\"1\":{\"56\":1}}],[\"号核心对应的\",{\"1\":{\"56\":1}}],[\"号核心把\",{\"1\":{\"56\":1}}],[\"号核心\",{\"1\":{\"56\":1,\"67\":1}}],[\"号核心需要修改变量\",{\"1\":{\"56\":2}}],[\"号核心的缓存\",{\"1\":{\"67\":1}}],[\"号核心的\",{\"1\":{\"56\":5}}],[\"号核心开始从内存里读取变量\",{\"1\":{\"56\":1}}],[\"号核心读取变量\",{\"1\":{\"56\":1}}],[\"号核心绑定了线程\",{\"1\":{\"56\":2}}],[\"号\",{\"1\":{\"49\":1,\"56\":1,\"68\":2,\"69\":9,\"72\":1,\"156\":2}}],[\"号内存块中的数据已经缓存在\",{\"1\":{\"49\":1}}],[\"号内存块\",{\"1\":{\"49\":1}}],[\"想要访问第\",{\"1\":{\"49\":1}}],[\"想要访问资源拥有者的资源的应用程序\",{\"1\":{\"43\":1}}],[\"假基站和抓包工具\",{\"1\":{\"130\":1}}],[\"假设每条消息都有个id\",{\"1\":{\"213\":1}}],[\"假设发送方发送一个\",{\"1\":{\"158\":1}}],[\"假设你要开一个博客网站\",{\"1\":{\"156\":1}}],[\"假设不用补码的方式来表示负数\",{\"1\":{\"80\":1}}],[\"假设我们有一个含有\",{\"1\":{\"67\":1}}],[\"假设\",{\"1\":{\"49\":1,\"56\":1,\"67\":1}}],[\"假如1亿用户体量\",{\"0\":{\"47\":1}}],[\"举个例子\",{\"1\":{\"49\":1,\"57\":1,\"81\":1,\"82\":1}}],[\"则这个ip\",{\"1\":{\"307\":1}}],[\"则认为当前的\",{\"1\":{\"268\":1}}],[\"则不管引用计数\",{\"1\":{\"261\":1}}],[\"则改为上一次收到的报文中的序列号\",{\"1\":{\"248\":1}}],[\"则改为\",{\"1\":{\"248\":1}}],[\"则滑动窗口往右边移动\",{\"1\":{\"223\":1}}],[\"则就会使用拥塞发生算法\",{\"1\":{\"218\":1}}],[\"则就要提高尾数位的长度\",{\"1\":{\"82\":1}}],[\"则表示该数据包是过期的\",{\"1\":{\"210\":1,\"246\":1}}],[\"则将会被丢弃\",{\"1\":{\"197\":1}}],[\"则需要从队列里把相应ip端口的连接取出\",{\"1\":{\"183\":1}}],[\"则需要把数据报分片成\",{\"1\":{\"158\":1}}],[\"则此时会向服务端发送\",{\"1\":{\"179\":1}}],[\"则会在\",{\"1\":{\"174\":1}}],[\"则会在传输层进行分片\",{\"1\":{\"174\":1}}],[\"则会造成整个\",{\"1\":{\"158\":1}}],[\"则没有\",{\"1\":{\"174\":1}}],[\"则负责在\",{\"1\":{\"150\":1}}],[\"则遇到第一个路由器\",{\"1\":{\"143\":1}}],[\"则说明目标主机可达\",{\"1\":{\"142\":1}}],[\"则说明目标主机不可达\",{\"1\":{\"142\":1}}],[\"则自己不再发送\",{\"1\":{\"139\":1}}],[\"则用\",{\"1\":{\"137\":2}}],[\"则关闭加密通信\",{\"1\":{\"129\":2}}],[\"则使用该缓存\",{\"1\":{\"93\":1}}],[\"则直接使用浏览器的本地缓存\",{\"1\":{\"93\":1}}],[\"则保持\",{\"1\":{\"88\":1}}],[\"则实际存储的指数是\",{\"1\":{\"82\":1}}],[\"则后面要补充\",{\"1\":{\"82\":1}}],[\"则称为单精度浮点数\",{\"1\":{\"82\":1}}],[\"则在做基本对加减法运算的时候\",{\"1\":{\"80\":1}}],[\"则考虑硬件升级等\",{\"1\":{\"72\":1}}],[\"则要向所有的其他\",{\"1\":{\"69\":1}}],[\"则\",{\"1\":{\"67\":1,\"218\":1,\"307\":1}}],[\"则读到的将会是错误的值\",{\"1\":{\"67\":1}}],[\"则把数据更新到\",{\"1\":{\"66\":1}}],[\"则可以使用\",{\"1\":{\"62\":1}}],[\"则可以设置\",{\"1\":{\"46\":1}}],[\"则是最低优先级\",{\"1\":{\"62\":1}}],[\"则是由索引\",{\"1\":{\"49\":1}}],[\"则是一定映射在\",{\"1\":{\"49\":1}}],[\"则是使用\",{\"1\":{\"49\":1}}],[\"至于映射关系实现方式\",{\"1\":{\"49\":1}}],[\"映射\",{\"1\":{\"49\":1}}],[\"采用非对称加密算法\",{\"1\":{\"128\":1}}],[\"采用的策略\",{\"1\":{\"49\":1}}],[\"采用分布式架构\",{\"1\":{\"47\":1}}],[\"称为双精度浮点数\",{\"1\":{\"82\":1}}],[\"称为指数\",{\"1\":{\"82\":1}}],[\"称为尾数\",{\"1\":{\"82\":1}}],[\"称为\",{\"1\":{\"49\":1,\"252\":2}}],[\"bhash和listen\",{\"1\":{\"181\":1}}],[\"bind\",{\"1\":{\"167\":1,\"176\":1,\"180\":1,\"188\":2,\"189\":1,\"192\":2}}],[\"bit\",{\"1\":{\"49\":1,\"74\":1}}],[\"buffer\",{\"1\":{\"146\":1}}],[\"bus\",{\"1\":{\"68\":1}}],[\"body\",{\"1\":{\"88\":1}}],[\"bytes\",{\"1\":{\"148\":1}}],[\"byte\",{\"1\":{\"74\":1,\"75\":1}}],[\"backlog\",{\"0\":{\"177\":1},\"1\":{\"169\":3,\"177\":2,\"209\":1}}],[\"back\",{\"1\":{\"64\":1}}],[\"batch\",{\"1\":{\"59\":1}}],[\"b\",{\"0\":{\"153\":1},\"1\":{\"56\":13,\"57\":3,\"67\":5,\"68\":1,\"69\":3,\"138\":1,\"153\":1,\"155\":1,\"191\":1}}],[\"block\",{\"1\":{\"49\":1,\"66\":14,\"67\":2,\"69\":4}}],[\"bcrypt\",{\"1\":{\"47\":1}}],[\"访问的数据在\",{\"1\":{\"50\":1}}],[\"访问\",{\"1\":{\"49\":3}}],[\"访问频率等\",{\"1\":{\"47\":1}}],[\"越靠近\",{\"1\":{\"49\":1}}],[\"最大报文段长度mss\",{\"1\":{\"287\":1}}],[\"最大化接近\",{\"1\":{\"81\":1}}],[\"最好就是在服务端发送数据前\",{\"1\":{\"239\":1}}],[\"最近的节点是由路由协议决定\",{\"1\":{\"159\":1}}],[\"最重要的是两个\",{\"1\":{\"142\":1}}],[\"最终的会话密钥\",{\"1\":{\"129\":1}}],[\"最为关键的是\",{\"1\":{\"82\":1}}],[\"最主要区别在于一次能计算多少字节数据\",{\"1\":{\"75\":1}}],[\"最常用的是ip协议\",{\"1\":{\"288\":1}}],[\"最常用的模式\",{\"1\":{\"44\":1}}],[\"最常见实现的方式是总线嗅探\",{\"1\":{\"68\":1}}],[\"最左侧的叶子节点\",{\"1\":{\"61\":1}}],[\"最后将数字信息\",{\"1\":{\"305\":1}}],[\"最后收到的报文的时间戳\",{\"1\":{\"265\":1,\"266\":1}}],[\"最后发现不是正经数据包后才丢弃\",{\"1\":{\"185\":1}}],[\"最后成功建立连接\",{\"1\":{\"181\":1}}],[\"最后会将自己的连接信息放入到这个全局\",{\"1\":{\"181\":1}}],[\"最后会调用到\",{\"1\":{\"146\":1}}],[\"最后客户端再发送一个ack\",{\"1\":{\"170\":1}}],[\"最后\",{\"1\":{\"136\":1,\"137\":1}}],[\"最后通过\",{\"1\":{\"76\":1}}],[\"最后一个地址为内存总字节数\",{\"1\":{\"74\":1}}],[\"最后把\",{\"1\":{\"81\":1}}],[\"最后把数据送给应用程序\",{\"1\":{\"72\":1}}],[\"最后把变量\",{\"1\":{\"56\":1}}],[\"最后也把它标记为脏的\",{\"1\":{\"66\":1}}],[\"最后从\",{\"1\":{\"61\":1}}],[\"最后进入到最快的\",{\"1\":{\"49\":1}}],[\"最开始变量\",{\"1\":{\"56\":1}}],[\"中还包括\",{\"1\":{\"297\":1}}],[\"中取出信息\",{\"1\":{\"181\":1}}],[\"中文叫\",{\"1\":{\"156\":1}}],[\"中继代理将此包广播给\",{\"1\":{\"137\":1}}],[\"中继代理返回应答\",{\"1\":{\"137\":1}}],[\"中继代理在收到这个广播包以后\",{\"1\":{\"137\":1}}],[\"中继代理发送\",{\"1\":{\"137\":1}}],[\"中继代理以后\",{\"1\":{\"137\":1}}],[\"中继代理\",{\"1\":{\"137\":1}}],[\"中间服务\",{\"1\":{\"133\":1}}],[\"中设置的过期时间大小\",{\"1\":{\"93\":1}}],[\"中设置了过期时间大小\",{\"1\":{\"93\":1}}],[\"中央处理器也就是我们常说的\",{\"1\":{\"75\":1}}],[\"中央处理器\",{\"0\":{\"75\":1}}],[\"中断处理程序的上部分和下半部可以理解为\",{\"1\":{\"72\":1}}],[\"中断处理程序在响应中断时\",{\"1\":{\"71\":1}}],[\"中断是一种异步的事件处理机制\",{\"1\":{\"71\":1}}],[\"中断是系统用来响应硬件设备请求的一种机制\",{\"1\":{\"71\":1}}],[\"中断\",{\"0\":{\"71\":1}}],[\"中有该数据\",{\"1\":{\"68\":1}}],[\"中有一个\",{\"1\":{\"57\":1}}],[\"中数据的操作\",{\"1\":{\"67\":1}}],[\"中数据块中找到所需的字呢\",{\"1\":{\"49\":1}}],[\"中了\",{\"1\":{\"57\":1}}],[\"中对应的\",{\"1\":{\"56\":2,\"67\":1,\"69\":2}}],[\"中找到缓存的数据\",{\"1\":{\"49\":1}}],[\"中是否有数据\",{\"1\":{\"49\":1}}],[\"中存储的数据对应的内存块\",{\"1\":{\"49\":1}}],[\"中我们还会存储一个组标记\",{\"1\":{\"49\":1}}],[\"中的寄存器主要作用是存储计算时的数据\",{\"1\":{\"75\":1}}],[\"中的线程也被称为轻量级进程\",{\"1\":{\"58\":1}}],[\"中的共享的数据\",{\"1\":{\"57\":1}}],[\"中的任意数据被修改后\",{\"1\":{\"56\":1}}],[\"中的数据就与内存不一致了\",{\"1\":{\"69\":1}}],[\"中的数据与内存也是一致的\",{\"1\":{\"69\":1}}],[\"中的数据与内存是一致的\",{\"1\":{\"69\":1}}],[\"中的数据\",{\"1\":{\"68\":1}}],[\"中的数据同步到内存里的\",{\"1\":{\"64\":1}}],[\"中的数据也包含了变量\",{\"1\":{\"56\":1}}],[\"中的数据是否是有效的\",{\"1\":{\"49\":1}}],[\"中的指令\",{\"1\":{\"52\":1}}],[\"中的整个数据块\",{\"1\":{\"49\":1}}],[\"中的话\",{\"1\":{\"49\":1,\"50\":2}}],[\"中的\",{\"1\":{\"49\":1,\"57\":2,\"82\":1}}],[\"中\",{\"1\":{\"49\":2,\"52\":1,\"56\":5,\"57\":2,\"65\":1,\"67\":1,\"68\":1,\"69\":2,\"106\":1,\"107\":1,\"147\":1}}],[\"核心发送消息\",{\"1\":{\"69\":1}}],[\"核心才更新\",{\"1\":{\"69\":1}}],[\"核心要修改\",{\"1\":{\"69\":1}}],[\"核心缓存了相同的数据\",{\"1\":{\"69\":1}}],[\"核心已经缓存了该数据\",{\"1\":{\"69\":1}}],[\"核心也从内存读取了变量\",{\"1\":{\"69\":1}}],[\"核心自己的\",{\"1\":{\"69\":1}}],[\"核心从内存读取变量\",{\"1\":{\"69\":1}}],[\"核心广播一个请求\",{\"1\":{\"69\":2}}],[\"核心知道\",{\"1\":{\"68\":1}}],[\"核心的\",{\"1\":{\"68\":2,\"69\":5}}],[\"核心的缓存其访问速度越快\",{\"1\":{\"49\":1}}],[\"核心都会监听总线上的广播事件\",{\"1\":{\"68\":1}}],[\"核心修改了\",{\"1\":{\"68\":1}}],[\"核心更新了\",{\"1\":{\"68\":1}}],[\"核心\",{\"1\":{\"67\":1,\"69\":5}}],[\"核心对于\",{\"1\":{\"67\":1}}],[\"核心里有相同数据的\",{\"1\":{\"67\":1}}],[\"核心里对数据的操作顺序\",{\"1\":{\"67\":1}}],[\"核心里的\",{\"1\":{\"67\":1}}],[\"核心数量\",{\"1\":{\"61\":1}}],[\"核心这样持续交替的分别修改变量\",{\"1\":{\"56\":1}}],[\"核心中各自\",{\"1\":{\"56\":1}}],[\"核心并行运行着两个不同的线程\",{\"1\":{\"56\":1}}],[\"核心上\",{\"1\":{\"53\":1}}],[\"核心来回切换执行\",{\"1\":{\"53\":1}}],[\"核心共享的\",{\"1\":{\"49\":1}}],[\"核心独有的\",{\"1\":{\"49\":1}}],[\"和目标\",{\"1\":{\"307\":1}}],[\"和发送方协商得出\",{\"1\":{\"278\":1}}],[\"和发送窗口有什么关系\",{\"1\":{\"215\":1}}],[\"和真正用来传送数据的\",{\"1\":{\"176\":1}}],[\"和端口\",{\"1\":{\"148\":1,\"188\":1}}],[\"和最后一跳路由之间\",{\"1\":{\"139\":1}}],[\"和私钥计算出服务端的椭圆曲线公钥\",{\"1\":{\"129\":1}}],[\"和公钥交换这两个消息合并成了一个消息\",{\"1\":{\"120\":1}}],[\"和原来数据和接近\",{\"1\":{\"99\":1}}],[\"和内存以及其他设备之间的通信\",{\"1\":{\"76\":1}}],[\"和内存数据都不一致了\",{\"1\":{\"64\":1}}],[\"和\",{\"1\":{\"49\":2,\"53\":2,\"56\":9,\"57\":2,\"59\":1,\"61\":1,\"67\":1,\"69\":3,\"82\":3,\"83\":1,\"100\":1,\"105\":1,\"122\":1,\"138\":1,\"139\":1,\"142\":1,\"153\":1,\"159\":1,\"197\":1,\"210\":1,\"218\":2,\"262\":1,\"297\":1}}],[\"和网络的负担\",{\"1\":{\"24\":1}}],[\"layer\",{\"1\":{\"283\":3}}],[\"last\",{\"1\":{\"179\":1}}],[\"listen\",{\"0\":{\"177\":1},\"1\":{\"148\":2,\"167\":1,\"169\":1,\"176\":1,\"180\":1,\"181\":1}}],[\"link\",{\"1\":{\"283\":1}}],[\"linux\",{\"1\":{\"57\":1,\"58\":4,\"59\":1,\"60\":1,\"61\":1,\"72\":2,\"162\":2,\"205\":1}}],[\"line\",{\"1\":{\"49\":18,\"56\":19,\"57\":13,\"69\":11}}],[\"len\",{\"1\":{\"248\":2}}],[\"length\",{\"1\":{\"88\":3,\"276\":1}}],[\"leetcode\",{\"0\":{\"18\":1}}],[\"localport\",{\"1\":{\"241\":1}}],[\"localhost\",{\"1\":{\"157\":1,\"241\":1}}],[\"localhost是一个域名默认等于127\",{\"1\":{\"148\":1}}],[\"log10\",{\"1\":{\"82\":2}}],[\"load\",{\"1\":{\"60\":1}}],[\"long\",{\"1\":{\"56\":1,\"57\":7}}],[\"l3\",{\"1\":{\"49\":3,\"53\":1,\"78\":1}}],[\"l2\",{\"1\":{\"49\":3,\"53\":2,\"67\":3,\"78\":1}}],[\"l1\",{\"1\":{\"49\":4,\"53\":2,\"67\":3,\"68\":4,\"78\":1}}],[\"持续优化\",{\"1\":{\"47\":1}}],[\"定义一个时间段\",{\"1\":{\"268\":1}}],[\"定义了一个叫做\",{\"1\":{\"215\":1}}],[\"定义了多种授权模式\",{\"1\":{\"44\":1}}],[\"定时器的时间一到\",{\"1\":{\"166\":1}}],[\"定期进行性能测试和优化\",{\"1\":{\"47\":1}}],[\"定期进行数据备份\",{\"1\":{\"47\":1}}],[\"容易丢包\",{\"1\":{\"209\":1}}],[\"容易造成队头阻塞\",{\"1\":{\"95\":1}}],[\"容易造成资源的浪费\",{\"1\":{\"24\":1}}],[\"容易被篡改\",{\"1\":{\"95\":1}}],[\"容易被窃听\",{\"1\":{\"95\":1}}],[\"容灾备份\",{\"1\":{\"47\":1}}],[\"同样是修改重发次数\",{\"1\":{\"196\":1}}],[\"同样的实际运行时间\",{\"1\":{\"60\":1}}],[\"同样的也是读取\",{\"1\":{\"56\":1}}],[\"同一时间里\",{\"1\":{\"134\":1}}],[\"同一个链路中相互连接的主机之间发送数据包\",{\"1\":{\"153\":1}}],[\"同一个\",{\"1\":{\"106\":1}}],[\"同一连接只能在完成一个\",{\"1\":{\"100\":1}}],[\"同时也不会发出\",{\"1\":{\"261\":1}}],[\"同时导致网络过载\",{\"1\":{\"209\":1}}],[\"同时对\",{\"1\":{\"203\":1}}],[\"同时带上各种瞎编的cookies信息\",{\"1\":{\"185\":1}}],[\"同时与服务器\",{\"1\":{\"138\":1}}],[\"同时要规范化\",{\"1\":{\"82\":1}}],[\"同时标记\",{\"1\":{\"66\":1,\"69\":1}}],[\"同时\",{\"1\":{\"47\":1,\"114\":1,\"261\":1,\"280\":1}}],[\"同步双方初始序列号\",{\"1\":{\"239\":1}}],[\"同步上来就是了\",{\"1\":{\"213\":1}}],[\"同步\",{\"1\":{\"170\":2}}],[\"同步已发送\",{\"1\":{\"31\":1,\"299\":1}}],[\"同步序列编号\",{\"1\":{\"31\":1,\"299\":1}}],[\"监听的\",{\"1\":{\"176\":1}}],[\"监听端口\",{\"1\":{\"167\":1}}],[\"监听状态\",{\"1\":{\"31\":1,\"299\":1}}],[\"监控和日志\",{\"1\":{\"47\":1}}],[\"分组\",{\"1\":{\"203\":1}}],[\"分片\",{\"1\":{\"283\":2}}],[\"分片不同\",{\"1\":{\"174\":1}}],[\"分片与重组是耗时的过程\",{\"1\":{\"160\":1}}],[\"分片等\",{\"1\":{\"47\":1}}],[\"分离网络号和主机号\",{\"1\":{\"155\":1}}],[\"分析性能损耗\",{\"0\":{\"118\":1}}],[\"分别是负责收发数据的\",{\"1\":{\"297\":1}}],[\"分别是主机号全为\",{\"1\":{\"153\":1}}],[\"分别是网络号和主机号\",{\"1\":{\"153\":1}}],[\"分别是\",{\"1\":{\"69\":1,\"72\":1}}],[\"分别是类型为\",{\"1\":{\"56\":1}}],[\"分为两种调度策略\",{\"1\":{\"59\":1}}],[\"分支预测就无法有效工作\",{\"1\":{\"52\":1}}],[\"分支预测器会动态地根据历史命中数据对未来进行预测\",{\"1\":{\"52\":1}}],[\"分支预测器\",{\"1\":{\"52\":1}}],[\"分布式架构\",{\"1\":{\"47\":1}}],[\"提升服务器的资源和处理能力\",{\"1\":{\"170\":1}}],[\"提供了用户与网络应用之间的接口\",{\"1\":{\"283\":1}}],[\"提供了在应用层实现拥塞控制的能力\",{\"1\":{\"279\":1}}],[\"提供报文后\",{\"1\":{\"137\":1}}],[\"提供报文\",{\"1\":{\"137\":1}}],[\"提供一种机制可以让\",{\"1\":{\"227\":1}}],[\"提供一种快速\",{\"1\":{\"21\":1}}],[\"提供一种可靠的数据传输\",{\"1\":{\"21\":1}}],[\"提供一种可靠的数据传输和通信方式\",{\"1\":{\"21\":1}}],[\"提前\",{\"1\":{\"52\":1}}],[\"提高数据缓存的命中率\",{\"1\":{\"51\":1}}],[\"提高系统的响应速度和吞吐量\",{\"1\":{\"47\":1}}],[\"保活机制会开始作用\",{\"1\":{\"268\":1}}],[\"保活机制\",{\"1\":{\"252\":1}}],[\"保存在tcp报头的seq里\",{\"1\":{\"184\":1}}],[\"保持内存与\",{\"1\":{\"65\":1}}],[\"保护系统免受恶意攻击\",{\"1\":{\"47\":1}}],[\"保证数据的顺序性和可靠\",{\"1\":{\"276\":1}}],[\"保证数据传输的安全性\",{\"1\":{\"174\":1}}],[\"保证\",{\"1\":{\"39\":1,\"163\":1}}],[\"防回绕序列号算法要求连接双方维护最近一次收到的数据包的时间戳\",{\"1\":{\"246\":1}}],[\"防火墙设置\",{\"1\":{\"169\":1}}],[\"防护和安全审计等安全措施\",{\"1\":{\"47\":1}}],[\"防止发送方超过连接的缓冲容量\",{\"1\":{\"278\":1}}],[\"防止单个\",{\"1\":{\"278\":1}}],[\"防止黑客伪造的相同序列号tcp报文被对方接收\",{\"1\":{\"240\":1}}],[\"防止历史报文被下一个相同四元组接收\",{\"1\":{\"240\":1}}],[\"防止历史连接中的数据\",{\"1\":{\"39\":1,\"163\":1}}],[\"防止公钥是假的\",{\"1\":{\"128\":1}}],[\"防止被假网站骗\",{\"1\":{\"127\":1}}],[\"防止通信内容被篡改\",{\"1\":{\"127\":1}}],[\"防止信息泄露\",{\"1\":{\"127\":1}}],[\"防止它们变成僵尸进程\",{\"1\":{\"20\":1}}],[\"实际上cookies并不会有一个专门的队列保存\",{\"1\":{\"184\":1}}],[\"实际上是和正数加减法操作一样的\",{\"1\":{\"80\":1}}],[\"实现的\",{\"1\":{\"252\":2}}],[\"实现就会发\",{\"1\":{\"229\":1}}],[\"实现主机与主机之间的通信\",{\"1\":{\"150\":1}}],[\"实现\",{\"1\":{\"106\":1,\"283\":1}}],[\"实现了一个基于\",{\"1\":{\"60\":1}}],[\"实现了文章发布\",{\"1\":{\"11\":1}}],[\"实现了用户注册\",{\"1\":{\"10\":1}}],[\"实时性相对较好\",{\"1\":{\"287\":1}}],[\"实时任务总是会比普通任务优先被执行\",{\"1\":{\"61\":1}}],[\"实时任务运行队列\",{\"1\":{\"61\":1}}],[\"实时任务\",{\"1\":{\"58\":1}}],[\"实时监控系统运行状态\",{\"1\":{\"47\":1}}],[\"实施合理的访问限制策略\",{\"1\":{\"47\":1}}],[\"实施防火墙\",{\"1\":{\"47\":1}}],[\"www\",{\"1\":{\"295\":1}}],[\"wnd\",{\"1\":{\"224\":3,\"225\":2}}],[\"windows\",{\"1\":{\"226\":1}}],[\"window\",{\"1\":{\"222\":1}}],[\"wifi\",{\"1\":{\"111\":1,\"291\":1}}],[\"wr\",{\"1\":{\"197\":2}}],[\"write\",{\"1\":{\"64\":2,\"65\":1,\"67\":1,\"176\":1}}],[\"word\",{\"1\":{\"49\":1}}],[\"websocket完美继承了\",{\"1\":{\"134\":1}}],[\"websocket\",{\"1\":{\"134\":2}}],[\"websocket是什么\",{\"0\":{\"134\":1}}],[\"web\",{\"1\":{\"47\":1,\"166\":2,\"303\":1}}],[\"wait2\",{\"1\":{\"197\":1}}],[\"wait结束之后就可以\",{\"1\":{\"189\":1}}],[\"wait和time\",{\"0\":{\"161\":1}}],[\"wait时间太短\",{\"1\":{\"39\":1}}],[\"wait状态的tcp接收到syn报文会怎么样\",{\"0\":{\"264\":1}}],[\"wait状态的意义\",{\"0\":{\"39\":1}}],[\"wait状态或者time\",{\"1\":{\"39\":1}}],[\"wait状态标识一个连接已经完成了关闭过程\",{\"1\":{\"39\":1}}],[\"wait状态\",{\"1\":{\"36\":1,\"255\":1,\"257\":1,\"259\":1,\"263\":2}}],[\"wait\",{\"0\":{\"161\":1,\"162\":1,\"163\":1,\"164\":1,\"165\":1,\"166\":1,\"167\":1,\"193\":1,\"267\":1},\"1\":{\"35\":1,\"36\":1,\"38\":2,\"164\":2,\"165\":2,\"166\":1,\"167\":4,\"179\":2,\"189\":2,\"190\":1,\"193\":3,\"210\":1,\"255\":4,\"256\":1,\"257\":2,\"263\":1}}],[\"推荐使用哈希函数加盐存储用户密码\",{\"1\":{\"47\":1}}],[\"对拥塞控制改进\",{\"0\":{\"279\":1}}],[\"对端\",{\"1\":{\"210\":1}}],[\"对端还是会接收到\",{\"1\":{\"197\":1}}],[\"对可打开的文件描述符的数量分别作了三个方面的限制\",{\"1\":{\"205\":1}}],[\"对\",{\"1\":{\"205\":1}}],[\"对方的第二个数据报文又到达了\",{\"1\":{\"262\":1}}],[\"对方连接关闭时\",{\"1\":{\"167\":1}}],[\"对方就无法解码出\",{\"1\":{\"104\":1}}],[\"对不同网段的\",{\"1\":{\"137\":1}}],[\"对内容进行哈希\",{\"1\":{\"128\":1}}],[\"对称加密算法\",{\"1\":{\"129\":2}}],[\"对称加密\",{\"1\":{\"128\":1}}],[\"对称加密和非对称加密\",{\"1\":{\"128\":1}}],[\"对指定的资源做出处理\",{\"1\":{\"90\":1,\"91\":1}}],[\"对网络数据进行逐层解析和处理\",{\"1\":{\"72\":1}}],[\"对系统的响应时间要求很高\",{\"1\":{\"58\":1}}],[\"对象继承关系中父类成员和子类成员\",{\"1\":{\"57\":1}}],[\"对齐地址\",{\"1\":{\"57\":1}}],[\"对应的软中断内核线程的名字是\",{\"1\":{\"72\":1}}],[\"对应的\",{\"1\":{\"56\":1}}],[\"对于发送方\",{\"1\":{\"213\":1}}],[\"对于回送请求消息而言该字段为\",{\"1\":{\"142\":1}}],[\"对于服务器的证书应该选择椭圆曲线\",{\"1\":{\"121\":1}}],[\"对于证书的优化\",{\"1\":{\"121\":1}}],[\"对于我们在从\",{\"1\":{\"82\":1}}],[\"对于二进制小数转十进制时\",{\"1\":{\"81\":1}}],[\"对于负数的加减法操作\",{\"1\":{\"80\":1}}],[\"对于普通任务来说\",{\"1\":{\"60\":1}}],[\"对于相同优先级的任务\",{\"1\":{\"59\":2}}],[\"对于多个线程共享的热点数据\",{\"1\":{\"57\":1}}],[\"对于\",{\"1\":{\"52\":1,\"80\":1}}],[\"对数据库进行优化\",{\"1\":{\"47\":1}}],[\"对数据完整性和正确性不那么高的场景\",{\"1\":{\"21\":1}}],[\"对用户密码进行加密存储\",{\"1\":{\"47\":1}}],[\"来委托协议栈工作\",{\"1\":{\"297\":1}}],[\"来拿到\",{\"1\":{\"250\":1}}],[\"来告诉\",{\"1\":{\"236\":1}}],[\"来识别同一计算机中同时通信的不同应用程序\",{\"1\":{\"187\":1}}],[\"来定义一条\",{\"1\":{\"166\":1}}],[\"来控制数据包的大小\",{\"1\":{\"158\":1}}],[\"来追踪去往目的地时沿途经过的路由器\",{\"1\":{\"143\":1}}],[\"来计算往返时间\",{\"1\":{\"142\":1}}],[\"来计算出该资源是否过期\",{\"1\":{\"93\":1}}],[\"来序列化结构体数据\",{\"1\":{\"133\":1}}],[\"来确认消息的身份\",{\"1\":{\"128\":1}}],[\"来保证服务器的身份是可信的\",{\"1\":{\"126\":1}}],[\"来标识\",{\"1\":{\"122\":1}}],[\"来标记自己\",{\"1\":{\"115\":1,\"281\":1}}],[\"来标记通信的两个端点\",{\"1\":{\"115\":1}}],[\"来查询证书的有效性\",{\"1\":{\"121\":1}}],[\"来渲染页面\",{\"1\":{\"107\":1}}],[\"来实现强缓存\",{\"1\":{\"93\":1}}],[\"来表示\",{\"1\":{\"81\":1}}],[\"来把\",{\"1\":{\"81\":1}}],[\"来传输数据\",{\"1\":{\"76\":1}}],[\"来指定内存的地址\",{\"1\":{\"76\":1}}],[\"来同步两个不同核心里面的缓存数据\",{\"1\":{\"67\":1}}],[\"来调整\",{\"1\":{\"62\":1}}],[\"来避免伪共享的问题\",{\"1\":{\"57\":1}}],[\"来存储用户数据和登录状态\",{\"1\":{\"47\":1}}],[\"来获取其终止状态时\",{\"1\":{\"20\":1}}],[\"ehash\",{\"1\":{\"181\":1}}],[\"established\",{\"1\":{\"177\":1,\"250\":1,\"270\":1}}],[\"eof\",{\"1\":{\"176\":1,\"179\":4}}],[\"epoll\",{\"1\":{\"167\":4}}],[\"e\",{\"1\":{\"154\":2}}],[\"e类\",{\"0\":{\"154\":1}}],[\"end\",{\"1\":{\"150\":2}}],[\"encrypted\",{\"1\":{\"129\":3}}],[\"encoder\",{\"1\":{\"116\":1}}],[\"encoding\",{\"1\":{\"88\":2}}],[\"echo\",{\"1\":{\"142\":2}}],[\"ecdhe算法\",{\"1\":{\"129\":1}}],[\"ecdhe\",{\"1\":{\"129\":4}}],[\"ecdsa\",{\"1\":{\"121\":1}}],[\"ecc\",{\"1\":{\"121\":1,\"129\":1}}],[\"etag\",{\"1\":{\"94\":1}}],[\"exactly\",{\"1\":{\"188\":1}}],[\"example\",{\"1\":{\"46\":5}}],[\"exchange\",{\"1\":{\"129\":3}}],[\"exclusive\",{\"1\":{\"69\":1}}],[\"expires\",{\"1\":{\"93\":2}}],[\"else\",{\"1\":{\"52\":2}}],[\"elb\",{\"1\":{\"47\":1}}],[\"number\",{\"1\":{\"275\":2}}],[\"num\",{\"1\":{\"249\":1}}],[\"nxt\",{\"1\":{\"224\":2,\"225\":2}}],[\"n\",{\"1\":{\"183\":1,\"275\":4}}],[\"net\",{\"1\":{\"169\":3,\"193\":2,\"210\":2}}],[\"netdev\",{\"1\":{\"169\":1}}],[\"new\",{\"1\":{\"62\":1}}],[\"nagle\",{\"1\":{\"230\":1}}],[\"napt\",{\"1\":{\"138\":4}}],[\"nat设备后的应用程序处于主动地位\",{\"1\":{\"138\":1}}],[\"nat设备后的应用程序自动完成的\",{\"1\":{\"138\":1}}],[\"nat\",{\"0\":{\"138\":1},\"1\":{\"138\":13,\"150\":1}}],[\"nack\",{\"1\":{\"137\":1}}],[\"name=value\",{\"1\":{\"46\":2}}],[\"ni\",{\"1\":{\"119\":1}}],[\"nice\",{\"1\":{\"60\":3,\"62\":14}}],[\"no\",{\"1\":{\"148\":2}}],[\"not\",{\"1\":{\"97\":1}}],[\"normal\",{\"1\":{\"59\":1}}],[\"nosql\",{\"1\":{\"47\":1}}],[\"nginx\",{\"1\":{\"47\":1,\"166\":1}}],[\"亿用户体量的登录验签服务需要考虑到高可用性\",{\"1\":{\"47\":1}}],[\"设计的\",{\"1\":{\"307\":1}}],[\"设计一个支持\",{\"1\":{\"47\":1}}],[\"设定一个定时器\",{\"1\":{\"233\":1}}],[\"设为\",{\"1\":{\"218\":1}}],[\"设备来进行转换了\",{\"1\":{\"138\":1}}],[\"设备来建立映射了\",{\"1\":{\"138\":1}}],[\"设备获取公有\",{\"1\":{\"138\":1}}],[\"设备的操作\",{\"1\":{\"138\":1}}],[\"设备的公有\",{\"1\":{\"138\":1}}],[\"设备要修改它外发的数据包\",{\"1\":{\"138\":1}}],[\"设备之后\",{\"1\":{\"138\":1}}],[\"设备就根据从\",{\"1\":{\"136\":1}}],[\"设备复位等信号\",{\"1\":{\"76\":1}}],[\"设置为\",{\"1\":{\"143\":1,\"162\":1}}],[\"设置为第一步中的\",{\"1\":{\"28\":1,\"219\":1}}],[\"设置缓存时间过期之后重新请求\",{\"1\":{\"97\":1}}],[\"设置更加精细\",{\"1\":{\"93\":1}}],[\"设置跨域资源共享\",{\"1\":{\"46\":1}}],[\"设置\",{\"1\":{\"46\":2,\"143\":1}}],[\"使重传没有歧义\",{\"1\":{\"275\":1}}],[\"使其能够容忍更长的等待时间\",{\"1\":{\"170\":1}}],[\"使得服务器不能为正常用户服务\",{\"1\":{\"169\":1}}],[\"使得原来连接的数据包在网络中都自然消失\",{\"1\":{\"163\":2}}],[\"使得动态表生效有一个前提\",{\"1\":{\"104\":1}}],[\"使得它变成实时任务\",{\"1\":{\"62\":1}}],[\"使得\",{\"1\":{\"46\":1}}],[\"使用三次握手建立连接的最主要原因是防止\",{\"1\":{\"239\":1}}],[\"使用慢启动算法\",{\"1\":{\"216\":1}}],[\"使用tcp出现丢包\",{\"1\":{\"213\":1}}],[\"使用udp传输协议的时候\",{\"1\":{\"207\":1}}],[\"使用目的不同\",{\"1\":{\"158\":1}}],[\"使用这个\",{\"1\":{\"157\":1}}],[\"使用的椭圆曲线\",{\"1\":{\"129\":1}}],[\"使用的是短链接\",{\"1\":{\"166\":1}}],[\"使用的是\",{\"1\":{\"114\":1,\"280\":1}}],[\"使用了\",{\"1\":{\"129\":1,\"236\":1}}],[\"使用了我们前面所说的写回策略\",{\"1\":{\"67\":1}}],[\"使用hpack\",{\"1\":{\"102\":1}}],[\"使用率最高的进程也是软中断\",{\"1\":{\"72\":1}}],[\"使用异步处理技术\",{\"1\":{\"47\":1}}],[\"使用缓存技术加速登录验签过程\",{\"1\":{\"47\":1}}],[\"使用\",{\"1\":{\"47\":2,\"57\":1,\"133\":1,\"291\":1}}],[\"使用负载均衡技术将流量分发到多个服务器上\",{\"1\":{\"47\":1}}],[\"使用代理\",{\"1\":{\"46\":1}}],[\"使用特殊符号标识边界\",{\"1\":{\"26\":1}}],[\"由分布在各处的客户端去承受\",{\"1\":{\"165\":1}}],[\"由\",{\"1\":{\"62\":1,\"151\":1,\"204\":1}}],[\"由于服务端超时间没有收到ack报文\",{\"1\":{\"258\":1}}],[\"由于服务端长时间没有收到ack报文\",{\"1\":{\"245\":1}}],[\"由于ack报文不会重传\",{\"1\":{\"257\":1}}],[\"由于客户端已经不再具有发送和接收数据的能力\",{\"1\":{\"261\":1}}],[\"由于客户端在第一次握手之后迟迟没有接受ack\",{\"1\":{\"244\":1}}],[\"由于客户端没有\",{\"1\":{\"137\":1}}],[\"由于ip层没有超时重传\",{\"1\":{\"242\":1}}],[\"由于直接广播有一定的安全问题\",{\"1\":{\"153\":1}}],[\"由于主机的路由表中可以找到下一跳的\",{\"1\":{\"136\":1}}],[\"由于尾数位是\",{\"1\":{\"82\":1}}],[\"由于同时都带有一个固定隐含位\",{\"1\":{\"82\":1}}],[\"由于计算机的资源是有限的\",{\"1\":{\"81\":1}}],[\"由于此时的\",{\"1\":{\"69\":1}}],[\"由于任务有优先级之分\",{\"1\":{\"59\":1}}],[\"由于\",{\"1\":{\"56\":1,\"62\":1,\"67\":1,\"69\":1,\"100\":1,\"138\":1}}],[\"由该中间层代理请求到其他域名\",{\"1\":{\"46\":1}}],[\"由头部和消息体组成\",{\"1\":{\"26\":1}}],[\"即通过\",{\"1\":{\"303\":1}}],[\"即是客户端输出的\",{\"1\":{\"303\":1}}],[\"即一条连接只有两个端点\",{\"1\":{\"174\":1}}],[\"即刻传数据\",{\"1\":{\"174\":1}}],[\"即网络地址是否相同\",{\"1\":{\"155\":1}}],[\"即使它先收到了后面的\",{\"1\":{\"203\":1}}],[\"即使网络非常拥堵了\",{\"1\":{\"174\":1}}],[\"即使没有开启\",{\"1\":{\"270\":1}}],[\"即使没有\",{\"1\":{\"159\":1}}],[\"即使你成功进行中间人攻击\",{\"1\":{\"130\":1}}],[\"即使该流的其他数据包到达了\",{\"1\":{\"113\":1}}],[\"即\",{\"1\":{\"82\":1,\"130\":1,\"210\":1}}],[\"即可\",{\"1\":{\"82\":1}}],[\"即把\",{\"1\":{\"82\":1}}],[\"即指数是有符号的整数\",{\"1\":{\"82\":1}}],[\"即指数位这\",{\"1\":{\"82\":1}}],[\"即将\",{\"1\":{\"82\":1}}],[\"即小数点后面的数字\",{\"1\":{\"82\":1}}],[\"即经常会修改的数据\",{\"1\":{\"57\":1}}],[\"即在同一域名下创建一个中间层\",{\"1\":{\"46\":1}}],[\"即用户\",{\"1\":{\"43\":1}}],[\"头里有一个字段叫\",{\"1\":{\"222\":1}}],[\"头部中的接收方\",{\"1\":{\"307\":2}}],[\"头部前\",{\"1\":{\"103\":1}}],[\"头部压缩\",{\"0\":{\"102\":1}}],[\"头部\",{\"1\":{\"100\":1,\"104\":2,\"116\":1}}],[\"头部巨大且重复\",{\"1\":{\"100\":1}}],[\"头部的协议号为\",{\"1\":{\"139\":1}}],[\"头部的\",{\"1\":{\"93\":1}}],[\"头部加上\",{\"1\":{\"93\":1}}],[\"头\",{\"1\":{\"46\":1,\"134\":1,\"262\":2}}],[\"头来允许跨域请求\",{\"1\":{\"46\":1}}],[\"头像等\",{\"1\":{\"45\":1}}],[\"ff\",{\"1\":{\"306\":6}}],[\"fcs\",{\"1\":{\"305\":1}}],[\"ftp\",{\"1\":{\"283\":1}}],[\"f\",{\"1\":{\"241\":2}}],[\"fddi\",{\"1\":{\"158\":1}}],[\"frame\",{\"0\":{\"276\":1},\"1\":{\"105\":2,\"106\":2}}],[\"flood攻击\",{\"1\":{\"185\":1}}],[\"float\",{\"1\":{\"82\":15}}],[\"flipped\",{\"1\":{\"1\":2}}],[\"flipped的个人介绍页\",{\"0\":{\"0\":1}}],[\"fast\",{\"1\":{\"123\":2,\"196\":1}}],[\"fair\",{\"1\":{\"59\":1,\"60\":1,\"61\":1,\"62\":1}}],[\"false\",{\"1\":{\"56\":1}}],[\"files\",{\"1\":{\"205\":1}}],[\"fin\",{\"1\":{\"162\":1,\"179\":6,\"197\":3,\"201\":2,\"248\":3,\"260\":2,\"261\":3,\"269\":1,\"270\":1,\"308\":2}}],[\"finishd\",{\"1\":{\"129\":2}}],[\"final\",{\"1\":{\"57\":1}}],[\"fifo\",{\"1\":{\"59\":1}}],[\"fetch\",{\"1\":{\"46\":1}}],[\"或连接接受\",{\"1\":{\"299\":1}}],[\"或主机名时\",{\"1\":{\"157\":1}}],[\"或其他序列化协议去保存结构体数据\",{\"1\":{\"133\":1}}],[\"或者接收方缓存空间有一半可以使用\",{\"1\":{\"230\":1}}],[\"或者把减法反转成加法\",{\"1\":{\"80\":1}}],[\"或者\",{\"1\":{\"69\":1,\"266\":1}}],[\"或类似的令牌机制来生成并验证用户身份\",{\"1\":{\"47\":1}}],[\"或\",{\"1\":{\"46\":1,\"47\":2}}],[\"或waitpid\",{\"1\":{\"20\":1}}],[\"就\",{\"1\":{\"248\":1}}],[\"就由对方重传对应的报文\",{\"1\":{\"245\":1}}],[\"就断开连接\",{\"1\":{\"243\":1}}],[\"就说明网络环境差\",{\"1\":{\"233\":1}}],[\"就启动持续计时器\",{\"1\":{\"229\":1}}],[\"就知道哪条消息没发送成功\",{\"1\":{\"213\":1}}],[\"就容易出现丢包现象\",{\"1\":{\"213\":1}}],[\"就应该调大\",{\"1\":{\"209\":1}}],[\"就累加一次\",{\"1\":{\"201\":1}}],[\"就无法充分使用网络带宽\",{\"1\":{\"198\":1}}],[\"就够了\",{\"1\":{\"181\":1}}],[\"就永远不要主动断开连接\",{\"1\":{\"165\":1}}],[\"就认为报文已经消失在网络中了\",{\"1\":{\"162\":1}}],[\"就选择相同位数最多的网络地址\",{\"1\":{\"157\":1}}],[\"就像每个小区都有自己的楼编号和门牌号\",{\"1\":{\"156\":1}}],[\"就牺牲了\",{\"1\":{\"143\":1}}],[\"就出现了\",{\"1\":{\"137\":1}}],[\"就能建立连接\",{\"1\":{\"181\":1}}],[\"就能完成\",{\"1\":{\"120\":1}}],[\"就能通过这些信息\",{\"1\":{\"49\":1}}],[\"就很难再下降了\",{\"1\":{\"100\":1}}],[\"就要同时解决上面两个问题就可以了\",{\"1\":{\"230\":1}}],[\"就要加个偏移量\",{\"1\":{\"82\":1}}],[\"就要检查这个\",{\"1\":{\"66\":1}}],[\"就跟这里移动的位数有关系\",{\"1\":{\"82\":1}}],[\"就不能很好的发挥出网络的传输效率\",{\"1\":{\"209\":1}}],[\"就不需要\",{\"1\":{\"138\":1}}],[\"就不搞那么多花里胡哨的地址转换了\",{\"1\":{\"138\":1}}],[\"就不是了\",{\"1\":{\"82\":1}}],[\"就不存在缓存一致性的问题了\",{\"1\":{\"69\":1}}],[\"就需要三次握手\",{\"1\":{\"239\":1}}],[\"就需要应用层自己去实现逻辑做保证\",{\"1\":{\"213\":1}}],[\"就需要带上中山路\",{\"1\":{\"156\":1}}],[\"就需要特殊处理\",{\"1\":{\"80\":1}}],[\"就需要同步到其他核心的\",{\"1\":{\"67\":1}}],[\"就需要一种机制\",{\"1\":{\"67\":1}}],[\"就可得到网络号\",{\"1\":{\"155\":1}}],[\"就可能造成结果错误\",{\"1\":{\"67\":1}}],[\"就可以通过它找到根域\",{\"1\":{\"295\":1}}],[\"就可以认为在这个序号以前的数据都已经被正常接收\",{\"1\":{\"248\":1}}],[\"就可以只重传丢失的数据\",{\"1\":{\"235\":1}}],[\"就可以把窗口打开让发送方发送数据过来\",{\"1\":{\"230\":1}}],[\"就可以指向\",{\"1\":{\"224\":1,\"225\":1}}],[\"就可以强制部分过低版本升级\",{\"1\":{\"213\":1}}],[\"就可以愉快的把要传输的数据写到这个文件里\",{\"1\":{\"146\":1}}],[\"就可以拿到了所有的路由器\",{\"1\":{\"143\":1}}],[\"就可以正确地转换地址跟端口的组合\",{\"1\":{\"138\":1}}],[\"就可以直接自由地写入\",{\"1\":{\"69\":1}}],[\"就可以\",{\"1\":{\"52\":1,\"114\":1,\"280\":1,\"281\":1}}],[\"就可以在所有以example\",{\"1\":{\"46\":1}}],[\"就是可以通过这一步拿到服务端下一次预期接收的序列号\",{\"1\":{\"250\":1}}],[\"就是安全问题\",{\"1\":{\"213\":1}}],[\"就是为了避免tcp中序列号出现回绕\",{\"1\":{\"210\":1}}],[\"就是要打开\",{\"1\":{\"210\":1}}],[\"就是没有服务端参与\",{\"1\":{\"181\":1}}],[\"就是尝试发送一个小小的消息到目标机器上\",{\"1\":{\"145\":1}}],[\"就是人为规定的\",{\"1\":{\"145\":1}}],[\"就是\",{\"1\":{\"142\":1}}],[\"就是客户端主动从\",{\"1\":{\"138\":1}}],[\"就是用\",{\"1\":{\"129\":1}}],[\"就是在有限的精度情况下\",{\"1\":{\"81\":1}}],[\"就是下次会被调度的任务\",{\"1\":{\"61\":1}}],[\"就是把内存块的地址始终\",{\"1\":{\"49\":1}}],[\"就自然没有数据被换出\",{\"1\":{\"57\":1}}],[\"就调度下一个线程\",{\"1\":{\"53\":1}}],[\"就会回复rst\",{\"1\":{\"266\":1}}],[\"就会触发超时重传\",{\"1\":{\"258\":1}}],[\"就会触发回调函数来关闭该连接\",{\"1\":{\"166\":1}}],[\"就会直接进入close状态\",{\"1\":{\"257\":1}}],[\"就会直接丢弃这个数据包\",{\"1\":{\"210\":1,\"246\":1}}],[\"就会让这个tcp保持连接状态\",{\"1\":{\"252\":1}}],[\"就会释放掉该连接\",{\"1\":{\"249\":1}}],[\"就会建立一个新的链接\",{\"1\":{\"249\":1}}],[\"就会重置计时器\",{\"1\":{\"259\":1}}],[\"就会重传syn\",{\"1\":{\"245\":1}}],[\"就会重发该数据\",{\"1\":{\"233\":1}}],[\"就会重复\",{\"1\":{\"56\":1}}],[\"就会向发送方通告窗口为\",{\"1\":{\"230\":1}}],[\"就会阻止发送方给接收方传递数据\",{\"1\":{\"229\":1}}],[\"就会出现丢包的现象\",{\"1\":{\"228\":1}}],[\"就会出现连包和拆包的问题\",{\"1\":{\"26\":1}}],[\"就会使用\",{\"1\":{\"216\":1}}],[\"就会将在收到的信息丢掉\",{\"1\":{\"213\":1}}],[\"就会判断该连接是否处于\",{\"1\":{\"193\":1}}],[\"就会返回了\",{\"1\":{\"189\":1}}],[\"就会根据\",{\"1\":{\"181\":1}}],[\"就会读取到了\",{\"1\":{\"176\":1}}],[\"就会断开连接\",{\"1\":{\"169\":1}}],[\"就会创建一个半连接对象\",{\"1\":{\"169\":1}}],[\"就会主动关闭连接\",{\"1\":{\"166\":1}}],[\"就会选择本地网卡\",{\"1\":{\"147\":1}}],[\"就会通过主机\",{\"1\":{\"136\":1}}],[\"就会在定时器过期之前\",{\"1\":{\"234\":1}}],[\"就会在\",{\"1\":{\"134\":1,\"139\":1}}],[\"就会在替换前先把数据同步到内存\",{\"1\":{\"69\":1}}],[\"就会导致需要\",{\"1\":{\"111\":1}}],[\"就会优先选择\",{\"1\":{\"62\":1}}],[\"就会越少\",{\"1\":{\"62\":1}}],[\"就会进入拥塞避免算法\",{\"1\":{\"28\":1}}],[\"适用于信任级别较高的应用\",{\"1\":{\"44\":1}}],[\"适用于服务器端应用\",{\"1\":{\"44\":1}}],[\"主机号\",{\"1\":{\"289\":1}}],[\"主机号全为\",{\"1\":{\"153\":2}}],[\"主机崩溃\",{\"1\":{\"270\":2}}],[\"主机\",{\"1\":{\"139\":4}}],[\"主机1\",{\"1\":{\"139\":1}}],[\"主机申请加入到组播组时\",{\"1\":{\"139\":1}}],[\"主机会通过广播发送\",{\"1\":{\"136\":1}}],[\"主动方的优化\",{\"1\":{\"197\":1}}],[\"主动发起关闭连接方\",{\"1\":{\"164\":2}}],[\"主动地建立好映射\",{\"1\":{\"138\":1}}],[\"主动关闭连接的\",{\"1\":{\"38\":1,\"255\":1}}],[\"主攻协议优化\",{\"1\":{\"120\":1}}],[\"主要通过\",{\"1\":{\"283\":1}}],[\"主要目的是为了协商连接\",{\"1\":{\"275\":1}}],[\"主要有三个原因\",{\"1\":{\"213\":1}}],[\"主要分析的方向就是服务端为什么没有调用\",{\"1\":{\"167\":1}}],[\"主要分为两种\",{\"1\":{\"58\":1}}],[\"主要用于区分连续\",{\"1\":{\"142\":1}}],[\"主要用于浏览器中的单页应用\",{\"1\":{\"44\":1}}],[\"主要的功能包括\",{\"1\":{\"139\":1}}],[\"主要是负责上半部未完成的工作\",{\"1\":{\"72\":1}}],[\"主要是负责耗时短的工作\",{\"1\":{\"72\":1}}],[\"主要负责处理跟硬件紧密相关或者时间敏感的事情\",{\"1\":{\"72\":1}}],[\"isn\",{\"1\":{\"238\":1,\"241\":1,\"246\":1,\"299\":1}}],[\"icann\",{\"1\":{\"156\":1}}],[\"icmp\",{\"0\":{\"139\":1},\"1\":{\"139\":4,\"142\":10,\"143\":7,\"146\":1,\"283\":1,\"297\":2}}],[\"it\",{\"1\":{\"156\":1}}],[\"igmpv2\",{\"1\":{\"139\":1}}],[\"igmp\",{\"1\":{\"139\":13}}],[\"id来标记通信的两个端点\",{\"1\":{\"281\":1}}],[\"id\",{\"1\":{\"105\":1,\"106\":2,\"115\":2,\"122\":3,\"275\":1,\"276\":2,\"281\":2}}],[\"ieee\",{\"1\":{\"82\":3}}],[\"i++\",{\"1\":{\"67\":1}}],[\"input\",{\"1\":{\"147\":1}}],[\"inet\",{\"1\":{\"146\":3}}],[\"internet\",{\"1\":{\"139\":1,\"283\":2}}],[\"interrupts\",{\"1\":{\"72\":1}}],[\"int\",{\"1\":{\"80\":3}}],[\"invalidated\",{\"1\":{\"69\":1}}],[\"in\",{\"0\":{\"190\":1},\"1\":{\"57\":1,\"188\":1,\"189\":1,\"192\":1}}],[\"init\",{\"1\":{\"20\":2}}],[\"i\",{\"1\":{\"52\":1,\"67\":9,\"68\":2,\"69\":5}}],[\"if\",{\"1\":{\"52\":5}}],[\"ip通信里\",{\"1\":{\"304\":1}}],[\"ip与子网掩码做与运算\",{\"1\":{\"303\":1}}],[\"ip协议需要源ip和目标地址ip\",{\"1\":{\"303\":1}}],[\"ip协议还可以\",{\"0\":{\"290\":1}}],[\"ip协议的寻址作用告诉我们要\",{\"1\":{\"290\":1}}],[\"ip协议的寻址作用\",{\"0\":{\"289\":1}}],[\"ip协议的相关技术\",{\"0\":{\"135\":1}}],[\"ip协议栈的五层模型\",{\"1\":{\"283\":1}}],[\"ip四层模型\",{\"1\":{\"283\":1}}],[\"ip层分片\",{\"1\":{\"242\":1}}],[\"ip+port\",{\"1\":{\"189\":3,\"190\":2}}],[\"ip+\",{\"1\":{\"164\":1}}],[\"ip头中有一个有一个ttl字段\",{\"1\":{\"162\":1}}],[\"ip分片与重组\",{\"0\":{\"158\":1}}],[\"ip地址\",{\"1\":{\"188\":1}}],[\"ip地址的网络地址这一部分是用于进行路由控制\",{\"1\":{\"157\":1}}],[\"ip地址为\",{\"1\":{\"136\":1}}],[\"ip的分类\",{\"0\":{\"152\":1}}],[\"ip的基础知识\",{\"0\":{\"151\":1}}],[\"ip基本认识\",{\"0\":{\"150\":1}}],[\"ipproto\",{\"1\":{\"146\":1}}],[\"ipv4\",{\"1\":{\"145\":3,\"146\":1,\"151\":1,\"159\":4,\"169\":2,\"193\":2,\"205\":1,\"210\":2,\"267\":1}}],[\"ipv6的首部改进\",{\"0\":{\"160\":1}}],[\"ipv6\",{\"0\":{\"159\":1},\"1\":{\"138\":3,\"159\":8,\"160\":4}}],[\"ip\",{\"0\":{\"156\":2,\"157\":1,\"303\":1},\"1\":{\"47\":1,\"111\":3,\"133\":1,\"136\":13,\"137\":11,\"138\":8,\"139\":9,\"143\":4,\"148\":1,\"150\":3,\"151\":5,\"152\":1,\"153\":4,\"154\":1,\"155\":5,\"156\":6,\"157\":5,\"158\":4,\"159\":5,\"160\":2,\"174\":2,\"176\":1,\"180\":1,\"181\":1,\"187\":1,\"188\":3,\"192\":1,\"204\":1,\"205\":2,\"210\":2,\"262\":1,\"281\":1,\"283\":3,\"284\":1,\"297\":5,\"303\":3,\"304\":1,\"306\":1,\"307\":10}}],[\"implicit\",{\"1\":{\"44\":1}}],[\"授权码模式\",{\"1\":{\"44\":1}}],[\"授权模式\",{\"0\":{\"44\":1}}],[\"授权服务器验证授权代码并向客户端颁发访问令牌\",{\"1\":{\"43\":1}}],[\"授权服务器验证资源拥有者的身份并获取其授权\",{\"1\":{\"43\":1}}],[\"授权服务器颁发访问令牌\",{\"1\":{\"43\":1}}],[\"授权服务器\",{\"1\":{\"43\":1}}],[\"托管资源拥有者的受保护资源\",{\"1\":{\"43\":1}}],[\"资源\",{\"1\":{\"164\":1}}],[\"资源比较少\",{\"1\":{\"58\":1}}],[\"资源服务器\",{\"1\":{\"43\":1}}],[\"资源所有者同意授权\",{\"1\":{\"43\":1}}],[\"资源所有者授予授权\",{\"1\":{\"43\":1}}],[\"资源所有者\",{\"1\":{\"43\":1}}],[\"address\",{\"0\":{\"190\":1},\"1\":{\"188\":1,\"189\":1,\"192\":1}}],[\"and\",{\"1\":{\"155\":1}}],[\"af\",{\"1\":{\"146\":3}}],[\"arp\",{\"1\":{\"136\":12,\"297\":2,\"304\":1,\"307\":1}}],[\"array\",{\"1\":{\"52\":1}}],[\"apr协议\",{\"1\":{\"304\":1}}],[\"apr\",{\"0\":{\"136\":1}}],[\"aes\",{\"1\":{\"119\":1}}],[\"ascii\",{\"1\":{\"90\":1}}],[\"already\",{\"1\":{\"188\":1,\"189\":1,\"192\":1}}],[\"alive的设计初衷就是为用户的后续请求重用连接\",{\"1\":{\"166\":1}}],[\"alive\",{\"1\":{\"133\":1,\"166\":5,\"252\":1}}],[\"aligned\",{\"1\":{\"57\":2}}],[\"allow\",{\"1\":{\"46\":2}}],[\"aws\",{\"1\":{\"47\":1}}],[\"ajax\",{\"1\":{\"46\":1}}],[\"accept\",{\"0\":{\"178\":1},\"1\":{\"176\":2,\"177\":1,\"178\":1}}],[\"accept队列\",{\"1\":{\"169\":1}}],[\"access\",{\"1\":{\"45\":1,\"46\":2}}],[\"accpet\",{\"1\":{\"167\":1,\"177\":2}}],[\"ack标识表示确认号表示服务器希望下一次接受的下一序列号\",{\"1\":{\"300\":1}}],[\"ack=1\",{\"1\":{\"299\":1}}],[\"ack=0\",{\"1\":{\"299\":1}}],[\"ack报文\",{\"1\":{\"244\":1,\"245\":1}}],[\"ack为1\",{\"1\":{\"238\":1}}],[\"acknowledgment\",{\"1\":{\"235\":1}}],[\"ack确认的数据\",{\"1\":{\"223\":2}}],[\"ack包\",{\"1\":{\"185\":1}}],[\"ack状态\",{\"1\":{\"37\":1,\"255\":1}}],[\"ack\",{\"1\":{\"28\":5,\"137\":3,\"162\":1,\"163\":1,\"170\":1,\"179\":1,\"197\":3,\"201\":1,\"212\":1,\"216\":1,\"217\":1,\"219\":4,\"223\":1,\"230\":1,\"233\":1,\"236\":1,\"239\":1,\"245\":2,\"248\":2,\"249\":4,\"250\":2,\"262\":6,\"300\":1,\"308\":2}}],[\"a\",{\"0\":{\"44\":1},\"1\":{\"56\":14,\"57\":2,\"67\":7,\"68\":1,\"69\":8,\"138\":1,\"153\":1,\"155\":1,\"191\":1}}],[\"authorization\",{\"1\":{\"43\":2,\"44\":1}}],[\"拥有受保护的资源\",{\"1\":{\"43\":1}}],[\"拥塞或网络故障等原因引起\",{\"1\":{\"170\":1}}],[\"拥塞窗口\",{\"1\":{\"28\":1,\"112\":1,\"215\":2,\"216\":1,\"219\":1}}],[\"拥塞窗口加1\",{\"1\":{\"28\":1}}],[\"拥塞发生算法\",{\"1\":{\"217\":1}}],[\"拥塞发生\",{\"0\":{\"218\":1},\"1\":{\"28\":1}}],[\"拥塞避免算法\",{\"1\":{\"216\":1}}],[\"拥塞避免\",{\"0\":{\"217\":1},\"1\":{\"28\":1}}],[\"拥塞控制等\",{\"1\":{\"287\":1}}],[\"拥塞控制有哪些\",{\"1\":{\"215\":1}}],[\"拥塞控制\",{\"0\":{\"28\":1,\"215\":1},\"1\":{\"174\":1}}],[\"增大半连接队列\",{\"1\":{\"209\":1}}],[\"增大三个参数\",{\"1\":{\"169\":1}}],[\"增大\",{\"1\":{\"169\":1}}],[\"增强了灵活性和安全性\",{\"1\":{\"43\":1}}],[\"增加syn超时时间\",{\"1\":{\"170\":1}}],[\"增加\",{\"1\":{\"28\":2,\"217\":1,\"219\":1}}],[\"简单地说\",{\"1\":{\"136\":1}}],[\"简单\",{\"1\":{\"95\":1}}],[\"简化了首部结构\",{\"1\":{\"159\":1}}],[\"简化了许多流程\",{\"1\":{\"43\":1}}],[\"简化模式\",{\"1\":{\"44\":1}}],[\"简介\",{\"0\":{\"2\":1}}],[\"比udp多了很多特性\",{\"1\":{\"287\":1}}],[\"比服务端\",{\"1\":{\"265\":2,\"266\":2}}],[\"比特的\",{\"1\":{\"155\":1}}],[\"比低权重任务的\",{\"1\":{\"60\":1}}],[\"比如流量控制\",{\"1\":{\"287\":1}}],[\"比如网络包的封帧\",{\"1\":{\"283\":1}}],[\"比如连接\",{\"1\":{\"281\":1}}],[\"比如是\",{\"1\":{\"248\":1}}],[\"比如文件描述符\",{\"1\":{\"164\":1}}],[\"比如用进程\",{\"1\":{\"142\":1}}],[\"比如面对不属于静态表的\",{\"1\":{\"116\":1}}],[\"比如二进制\",{\"1\":{\"82\":1}}],[\"比如中断\",{\"1\":{\"76\":1}}],[\"比如需要进行加和运算的两个数据\",{\"1\":{\"75\":1}}],[\"比如说\",{\"1\":{\"75\":1}}],[\"比如内核调度等\",{\"1\":{\"72\":1}}],[\"比如内存地址空间\",{\"1\":{\"58\":1}}],[\"比如变量\",{\"1\":{\"67\":1}}],[\"比如\",{\"1\":{\"62\":1,\"72\":1,\"80\":1,\"82\":4,\"107\":1,\"111\":1,\"143\":1,\"226\":1,\"283\":3}}],[\"比如将\",{\"1\":{\"62\":1}}],[\"比如音视频通话\",{\"1\":{\"21\":1}}],[\"比\",{\"1\":{\"43\":1}}],[\"是如何迁移连接的\",{\"0\":{\"281\":1}}],[\"是如何做流量控制的\",{\"0\":{\"278\":1}}],[\"是如何解决\",{\"0\":{\"277\":1}}],[\"是如何转换成二进制浮点数的呢\",{\"1\":{\"82\":1}}],[\"是接受到上一次的数据包\",{\"1\":{\"275\":1}}],[\"是每个报文独一无二的编号\",{\"1\":{\"275\":1}}],[\"是粗暴的关闭\",{\"1\":{\"261\":1}}],[\"是发出去的包丢了\",{\"1\":{\"236\":1}}],[\"是重传一个\",{\"1\":{\"234\":1}}],[\"是通过\",{\"1\":{\"226\":1}}],[\"是未发送但总大小超过接收方处理范围\",{\"1\":{\"223\":1}}],[\"是未发送但总大小在接收方处理范围内\",{\"1\":{\"223\":1}}],[\"是已发送但未收到\",{\"1\":{\"223\":1}}],[\"是已发送并收到\",{\"1\":{\"223\":1}}],[\"是已失效状态\",{\"1\":{\"56\":1}}],[\"是恢复为\",{\"1\":{\"218\":1}}],[\"是软件版本问题\",{\"1\":{\"213\":1}}],[\"是过期的\",{\"1\":{\"212\":1}}],[\"是对\",{\"1\":{\"210\":1}}],[\"是面向字节流的协议\",{\"0\":{\"208\":1}}],[\"是面向报文的协议\",{\"0\":{\"207\":1}}],[\"是面向连接的\",{\"1\":{\"203\":1}}],[\"是无法读出一个有效的用户消息的\",{\"1\":{\"203\":1}}],[\"是客户端\",{\"1\":{\"193\":1}}],[\"是可以的\",{\"1\":{\"181\":1}}],[\"是可靠交付数据的\",{\"1\":{\"174\":1}}],[\"是有边界的\",{\"1\":{\"174\":1}}],[\"是有三个特点\",{\"0\":{\"132\":1}}],[\"是流式传输\",{\"1\":{\"174\":1}}],[\"是尽最大努力交付\",{\"1\":{\"174\":1}}],[\"是ip数据报文可以跳跃的最大路由数\",{\"1\":{\"162\":1}}],[\"是以每\",{\"1\":{\"159\":1}}],[\"是以内核线程的方式执行\",{\"1\":{\"72\":1}}],[\"是因为每个不同类型的数据链路的使用目的不同\",{\"1\":{\"158\":1}}],[\"是因特网组管理协议\",{\"1\":{\"139\":1}}],[\"是国家统一分配的\",{\"1\":{\"156\":1}}],[\"是特殊的\",{\"1\":{\"153\":1}}],[\"是会失败的\",{\"1\":{\"148\":1}}],[\"是会打断\",{\"1\":{\"72\":1}}],[\"是原始套接字\",{\"1\":{\"146\":1}}],[\"是指使用面向字节流的\",{\"1\":{\"146\":1}}],[\"是看不到中间经过的路由的\",{\"1\":{\"143\":1}}],[\"是工作在主机与连接的路由器之间\",{\"1\":{\"139\":1}}],[\"是借助\",{\"1\":{\"136\":1}}],[\"是帧的类型\",{\"1\":{\"105\":1}}],[\"是变化\",{\"1\":{\"103\":1}}],[\"是一对一的两点服务\",{\"1\":{\"174\":1}}],[\"是一个hash\",{\"1\":{\"241\":1}}],[\"是一个指针\",{\"1\":{\"225\":1}}],[\"是一个绝对指针\",{\"1\":{\"224\":1}}],[\"是一个绝对时间\",{\"1\":{\"93\":1}}],[\"是一个工作在传输层的可靠数据传输的服务\",{\"1\":{\"202\":1}}],[\"是一个包一个包的发送\",{\"1\":{\"174\":1}}],[\"是一个相对时间\",{\"1\":{\"93\":1}}],[\"是一个在计算机世界里专门在\",{\"1\":{\"86\":1}}],[\"是一个用在计算机世界里的协议\",{\"1\":{\"86\":1}}],[\"是一种用于授权的开放标准协议\",{\"1\":{\"43\":1}}],[\"是一种针对网络应用程序设计的架构风格\",{\"1\":{\"41\":1}}],[\"是超文本传输协议\",{\"1\":{\"86\":1}}],[\"是规格化的科学记数法\",{\"1\":{\"82\":1}}],[\"是为了能计算更大的数值\",{\"1\":{\"75\":1}}],[\"是否都相同\",{\"1\":{\"192\":1}}],[\"是否缓存相同的数据\",{\"1\":{\"68\":1}}],[\"是否被\",{\"1\":{\"66\":1}}],[\"是先变成\",{\"1\":{\"67\":1}}],[\"是脏数据\",{\"1\":{\"66\":1}}],[\"是不同的\",{\"1\":{\"275\":1}}],[\"是不是觉得\",{\"1\":{\"62\":1}}],[\"是不会变化的\",{\"1\":{\"60\":1}}],[\"是最高优先级\",{\"1\":{\"62\":1}}],[\"是最简单和最通用的方法\",{\"1\":{\"46\":1}}],[\"是用红黑树来描述的\",{\"1\":{\"61\":1}}],[\"是用于解决伪共享的问题\",{\"1\":{\"57\":1}}],[\"是什么\",{\"1\":{\"60\":1}}],[\"是按照\",{\"1\":{\"59\":1}}],[\"是只有单个执行流\",{\"1\":{\"58\":1}}],[\"是根据什么来选择当前要执行的线程\",{\"0\":{\"58\":1}}],[\"是多核心之间共享的\",{\"1\":{\"53\":1}}],[\"是多个核心各自独有的\",{\"1\":{\"67\":1}}],[\"是多个\",{\"1\":{\"49\":1}}],[\"是由\",{\"1\":{\"252\":1}}],[\"是由应用层\",{\"1\":{\"252\":1}}],[\"是由各种标志\",{\"1\":{\"49\":1}}],[\"是由很多个\",{\"1\":{\"49\":1}}],[\"是\",{\"1\":{\"43\":1,\"56\":1,\"69\":1,\"158\":2,\"176\":1,\"177\":1,\"300\":1}}],[\"例如网络地址为\",{\"1\":{\"153\":2}}],[\"例如将打印机服务器等小型嵌入式设备接入到网络时就经常会用得到\",{\"1\":{\"136\":1}}],[\"例如\",{\"1\":{\"46\":2,\"47\":1,\"221\":1}}],[\"例如昵称\",{\"1\":{\"45\":1}}],[\"例如社交媒体账户\",{\"1\":{\"43\":1}}],[\"例如在每一个完整的数据之后加一个特殊字符\",{\"1\":{\"26\":1}}],[\"osi网络模型\",{\"1\":{\"283\":1}}],[\"oom\",{\"1\":{\"205\":1}}],[\"offer\",{\"1\":{\"137\":1}}],[\"offset\",{\"1\":{\"49\":1,\"276\":2}}],[\"open功能\",{\"1\":{\"196\":1}}],[\"open\",{\"1\":{\"123\":2,\"205\":1}}],[\"online\",{\"1\":{\"121\":1}}],[\"ocsp\",{\"1\":{\"121\":1}}],[\"o密集型\",{\"1\":{\"119\":1}}],[\"old\",{\"1\":{\"62\":1}}],[\"origin\",{\"1\":{\"46\":2}}],[\"orphan\",{\"1\":{\"20\":1}}],[\"owner\",{\"1\":{\"43\":1,\"44\":1}}],[\"oauth\",{\"0\":{\"44\":1},\"1\":{\"43\":6,\"44\":1}}],[\"0806\",{\"1\":{\"304\":1}}],[\"0800\",{\"1\":{\"304\":1}}],[\"01\",{\"1\":{\"103\":1}}],[\"01010100000000000000000\",{\"1\":{\"82\":1}}],[\"010101\",{\"1\":{\"82\":2}}],[\"00有什么区别\",{\"0\":{\"148\":1}}],[\"0011\",{\"1\":{\"82\":2}}],[\"000101\",{\"1\":{\"82\":4}}],[\"0~10\",{\"1\":{\"139\":1}}],[\"0~139\",{\"1\":{\"62\":1}}],[\"0~255\",{\"1\":{\"75\":1}}],[\"0~99\",{\"1\":{\"58\":1,\"62\":1}}],[\"0\",{\"0\":{\"43\":1,\"44\":1,\"144\":2,\"145\":2,\"147\":2,\"148\":3},\"1\":{\"43\":5,\"44\":1,\"49\":1,\"52\":1,\"60\":1,\"62\":1,\"67\":3,\"72\":2,\"74\":1,\"80\":1,\"81\":5,\"82\":6,\"83\":4,\"114\":1,\"137\":4,\"139\":4,\"142\":4,\"146\":1,\"148\":28,\"153\":10,\"155\":1,\"157\":2,\"159\":2,\"162\":1,\"188\":12,\"197\":1,\"223\":1,\"229\":3,\"230\":1,\"246\":1,\"261\":1,\"280\":1,\"303\":4}}],[\"rfc1337为1就丢掉\",{\"1\":{\"267\":1}}],[\"rfc7541\",{\"1\":{\"103\":1}}],[\"rot应该较大于rtt\",{\"1\":{\"233\":1}}],[\"round\",{\"1\":{\"233\":1}}],[\"route\",{\"1\":{\"148\":2}}],[\"rwnd\",{\"1\":{\"215\":1}}],[\"rdwr\",{\"1\":{\"197\":1}}],[\"rd\",{\"1\":{\"197\":2}}],[\"rst\",{\"0\":{\"267\":1},\"1\":{\"180\":1,\"201\":1,\"212\":4,\"229\":1,\"249\":1,\"250\":2,\"251\":1,\"261\":1}}],[\"rsa算法的缺陷\",{\"1\":{\"129\":1}}],[\"rsa\",{\"1\":{\"121\":2,\"129\":6}}],[\"ring\",{\"1\":{\"146\":1}}],[\"ringbuffer过小导致丢包\",{\"1\":{\"213\":1}}],[\"ringbufferfelds\",{\"1\":{\"57\":1}}],[\"ringbufferpad\",{\"1\":{\"57\":2}}],[\"ringbuffer\",{\"1\":{\"57\":2}}],[\"raw\",{\"1\":{\"146\":2}}],[\"rarp\",{\"1\":{\"136\":5}}],[\"random\",{\"1\":{\"129\":7}}],[\"rpc\",{\"1\":{\"132\":1,\"133\":3}}],[\"rcyd\",{\"1\":{\"238\":1}}],[\"rcv\",{\"1\":{\"225\":4}}],[\"rcv状态的优化\",{\"1\":{\"196\":1}}],[\"rcvd\",{\"1\":{\"32\":1,\"177\":1,\"300\":1}}],[\"rcu\",{\"1\":{\"72\":1}}],[\"rto较短\",{\"1\":{\"233\":1}}],[\"rto较长\",{\"1\":{\"233\":1}}],[\"rto超时重传时间\",{\"1\":{\"233\":1}}],[\"rtt\",{\"1\":{\"114\":2,\"120\":1,\"123\":1,\"233\":1,\"246\":1,\"280\":2}}],[\"rt\",{\"1\":{\"61\":2}}],[\"rq\",{\"1\":{\"61\":8}}],[\"run\",{\"1\":{\"61\":1}}],[\"rr\",{\"1\":{\"59\":1}}],[\"retries\",{\"1\":{\"243\":1,\"244\":1}}],[\"recv状态继续建立连接\",{\"1\":{\"265\":1}}],[\"recent\",{\"1\":{\"210\":2,\"246\":2}}],[\"recycle在nat网络下使用是不安全的\",{\"1\":{\"210\":1}}],[\"recycle\",{\"1\":{\"210\":1}}],[\"reuse\",{\"1\":{\"193\":2}}],[\"reuseaddr\",{\"1\":{\"188\":1,\"190\":2}}],[\"read\",{\"1\":{\"176\":2,\"179\":1,\"198\":1}}],[\"realtime\",{\"1\":{\"59\":1,\"61\":1}}],[\"reply\",{\"1\":{\"142\":1}}],[\"request\",{\"1\":{\"142\":1}}],[\"request进行响应\",{\"1\":{\"137\":1}}],[\"remoteport\",{\"1\":{\"241\":1}}],[\"remotehost\",{\"1\":{\"241\":1}}],[\"remote\",{\"1\":{\"132\":1}}],[\"renice\",{\"1\":{\"62\":1}}],[\"redis等\",{\"1\":{\"47\":1}}],[\"response\",{\"1\":{\"93\":3}}],[\"resource\",{\"1\":{\"43\":2,\"44\":1}}],[\"restful\",{\"1\":{\"41\":1}}],[\"被称之为\",{\"1\":{\"249\":1}}],[\"被动方的优化\",{\"1\":{\"197\":1}}],[\"被动关闭连接\",{\"1\":{\"39\":1,\"163\":1}}],[\"被替换\",{\"1\":{\"66\":1}}],[\"被后面相同四元组的连接错误的接收\",{\"1\":{\"39\":1,\"163\":1}}],[\"状态持续的时间超过了\",{\"1\":{\"193\":1}}],[\"状态并且\",{\"1\":{\"193\":1}}],[\"状态的服务端\",{\"1\":{\"250\":1}}],[\"状态的原因有哪些\",{\"0\":{\"166\":1,\"167\":1}}],[\"状态的连接被快速回收\",{\"1\":{\"210\":1}}],[\"状态的连接占用的\",{\"1\":{\"190\":1}}],[\"状态的连接使用的\",{\"1\":{\"189\":1}}],[\"状态的连接的时候\",{\"1\":{\"167\":2}}],[\"状态的连接\",{\"1\":{\"165\":1,\"166\":1,\"189\":1}}],[\"状态过多\",{\"0\":{\"193\":1},\"1\":{\"164\":2}}],[\"状态时\",{\"1\":{\"69\":1}}],[\"状态是\",{\"1\":{\"69\":2}}],[\"状态为\",{\"1\":{\"69\":1}}],[\"状态代表着相同的数据在多个\",{\"1\":{\"69\":1}}],[\"状态下的数据\",{\"1\":{\"69\":1}}],[\"状态都代表\",{\"1\":{\"69\":1}}],[\"状态就是我们前面提到的脏标记\",{\"1\":{\"69\":1}}],[\"状态变量\",{\"1\":{\"216\":1}}],[\"状态变成\",{\"1\":{\"56\":1}}],[\"状态变为\",{\"1\":{\"56\":1}}],[\"状态和操作的统一性\",{\"1\":{\"41\":1}}],[\"状态\",{\"0\":{\"163\":1,\"267\":1},\"1\":{\"38\":1,\"56\":7,\"69\":6,\"177\":2,\"179\":3,\"193\":1,\"197\":1,\"255\":1}}],[\"等收到数据包之后才会从这个队列中找是否有可用的数据包\",{\"1\":{\"263\":1}}],[\"等到窗口大小\",{\"1\":{\"230\":1}}],[\"等time\",{\"1\":{\"189\":1}}],[\"等待客户端连接\",{\"1\":{\"176\":1}}],[\"等待客户端的连接\",{\"1\":{\"148\":1}}],[\"等待事件发生\",{\"1\":{\"167\":1}}],[\"等待连接到来\",{\"1\":{\"167\":1}}],[\"等待足够的时间以确保最后的\",{\"1\":{\"163\":1}}],[\"等待的时间是\",{\"0\":{\"162\":1}}],[\"等待上层应用读取\",{\"1\":{\"27\":1}}],[\"等\",{\"1\":{\"72\":1,\"283\":3}}],[\"等服务端不再发送数据时\",{\"1\":{\"37\":1,\"255\":1}}],[\"服务进程时\",{\"0\":{\"190\":1}}],[\"服务进程重启时\",{\"1\":{\"189\":1}}],[\"服务进程同时绑定的\",{\"1\":{\"188\":1}}],[\"服务对象\",{\"1\":{\"174\":1}}],[\"服务的实现\",{\"1\":{\"166\":1}}],[\"服务发现\",{\"1\":{\"133\":1}}],[\"服务端是无法感知到的\",{\"1\":{\"270\":1}}],[\"服务端突然挂怎么办\",{\"0\":{\"269\":1}}],[\"服务端超过最大重传次数之后\",{\"1\":{\"259\":1}}],[\"服务端长时间没有收到ack就会触发第三次挥手的重传机制\",{\"1\":{\"259\":1}}],[\"服务端向客户端发送ack报文\",{\"1\":{\"257\":1}}],[\"服务端的\",{\"1\":{\"270\":1}}],[\"服务端的话由于长时间没有收到第三次握手\",{\"1\":{\"244\":1}}],[\"服务端的流程\",{\"1\":{\"167\":1}}],[\"服务端没有中间状态给客户端来阻止历史连接\",{\"1\":{\"239\":1}}],[\"服务端没有调用listen\",{\"0\":{\"180\":1}}],[\"服务端优化\",{\"1\":{\"196\":1}}],[\"服务端会\",{\"1\":{\"269\":1}}],[\"服务端会返回一个带有正确的确认号和正确的序列号这个\",{\"1\":{\"249\":1}}],[\"服务端会认为这是一个新的连接请求\",{\"1\":{\"249\":1}}],[\"服务端会触发超时重传\",{\"1\":{\"245\":1}}],[\"服务端会出现\",{\"1\":{\"189\":1}}],[\"服务端会回\",{\"1\":{\"180\":1}}],[\"服务端收到后\",{\"1\":{\"249\":1}}],[\"服务端收到客户端发来的报文\",{\"1\":{\"238\":1}}],[\"服务端收到ack包后以为是正经cookies\",{\"1\":{\"185\":1}}],[\"服务端收到该报文\",{\"1\":{\"36\":1,\"255\":1}}],[\"服务端如果只\",{\"1\":{\"180\":1}}],[\"服务端进入\",{\"1\":{\"179\":1}}],[\"服务端进入close\",{\"1\":{\"36\":1,\"255\":1}}],[\"服务端接收到了\",{\"1\":{\"179\":1}}],[\"服务端接收到报文之后进入close状态\",{\"1\":{\"38\":1,\"255\":1}}],[\"服务端\",{\"1\":{\"176\":1,\"178\":1}}],[\"服务端调用\",{\"1\":{\"176\":5}}],[\"服务端创建一个监听socket和客户端初始化用来通信的\",{\"1\":{\"176\":1}}],[\"服务端通常会有个参数\",{\"1\":{\"166\":1}}],[\"服务端也会主动关闭连接\",{\"1\":{\"166\":1}}],[\"服务端关闭\",{\"1\":{\"166\":1}}],[\"服务端在响应完就关闭连接\",{\"1\":{\"166\":1}}],[\"服务端开启\",{\"1\":{\"166\":1}}],[\"服务端用\",{\"1\":{\"137\":1}}],[\"服务端随机数\",{\"1\":{\"129\":1}}],[\"服务端椭圆曲线的公钥\",{\"1\":{\"129\":1}}],[\"服务端不在储存会话密钥\",{\"1\":{\"122\":1}}],[\"服务端可能还有数据需要处理和发送\",{\"1\":{\"37\":1,\"255\":1}}],[\"服务器准备好关闭连接时\",{\"1\":{\"308\":1}}],[\"服务器中\",{\"1\":{\"295\":1}}],[\"服务器信息保存在互联网中所有的\",{\"1\":{\"295\":1}}],[\"服务器域名与\",{\"0\":{\"295\":1}}],[\"服务器会主动监听某个端口处于listen\",{\"1\":{\"238\":1}}],[\"服务器会在返回这个资源的同时\",{\"1\":{\"93\":1}}],[\"服务器和聊天软件每次都拿最新消息的id进行对比\",{\"1\":{\"213\":1}}],[\"服务器和客户端不是在同一个局域网内\",{\"1\":{\"137\":1}}],[\"服务器可能记录了我们最近发过什么数据\",{\"1\":{\"213\":1}}],[\"服务器可以直接主动推送\",{\"1\":{\"107\":1}}],[\"服务器接收到后会回复一个syn\",{\"1\":{\"170\":1}}],[\"服务器接到这个消息后返回\",{\"1\":{\"136\":1}}],[\"服务器主动断开了很多tcp连接\",{\"1\":{\"166\":1}}],[\"服务器主动推送资源\",{\"0\":{\"107\":1}}],[\"服务器出现大量\",{\"0\":{\"166\":1,\"167\":1}}],[\"服务器也可以实现自动分配ip地址\",{\"1\":{\"159\":1}}],[\"服务器也会选择一个初始序列号用于标识服务器到客户端的数据流\",{\"1\":{\"32\":1,\"300\":1}}],[\"服务器即使不在同一个链路上也可以实现统一分配和管理ip地址\",{\"1\":{\"137\":1}}],[\"服务器端收到该包以后再向\",{\"1\":{\"137\":1}}],[\"服务器统一进行管理\",{\"1\":{\"137\":1}}],[\"服务器如果不同意继续租用\",{\"1\":{\"137\":1}}],[\"服务器如果同意继续租用\",{\"1\":{\"137\":1}}],[\"服务器分配的\",{\"1\":{\"137\":1}}],[\"服务器以及\",{\"1\":{\"137\":1}}],[\"服务器收到\",{\"1\":{\"137\":1}}],[\"服务器收到客户端的连接释放请求后\",{\"1\":{\"308\":1}}],[\"服务器收到客户端的第三个随机数\",{\"1\":{\"129\":2}}],[\"服务器收到客户端请求后\",{\"1\":{\"129\":2}}],[\"服务器的地址\",{\"1\":{\"137\":1}}],[\"服务器的数字证书\",{\"1\":{\"129\":2}}],[\"服务器所收到的应答信息设置自己的\",{\"1\":{\"136\":1}}],[\"服务器\",{\"0\":{\"308\":1},\"1\":{\"136\":1,\"137\":2,\"295\":6,\"303\":1}}],[\"服务器握手结束通知\",{\"1\":{\"129\":2}}],[\"服务器生产的随机数\",{\"1\":{\"129\":3}}],[\"服务器再次收到请求后\",{\"1\":{\"93\":1}}],[\"服务器在返回数据时\",{\"1\":{\"88\":1}}],[\"服务器响应中应包含\",{\"1\":{\"46\":1}}],[\"服务器处于syn\",{\"1\":{\"32\":1,\"300\":1}}],[\"服务器处于listen\",{\"1\":{\"31\":1,\"299\":1}}],[\"服务器同意建立连接\",{\"1\":{\"32\":1,\"300\":1}}],[\"向服务端的地址和端口发起连接请求\",{\"1\":{\"176\":1}}],[\"向服务器发送确认\",{\"1\":{\"308\":1}}],[\"向服务器发送如下信息\",{\"1\":{\"129\":2}}],[\"向服务器发送一个fin报文\",{\"1\":{\"35\":1,\"255\":1}}],[\"向客户端做出响应\",{\"1\":{\"137\":1}}],[\"向客户端发送连接释放请求\",{\"1\":{\"308\":1}}],[\"向客户端发送确认\",{\"1\":{\"308\":1}}],[\"向客户端发送一个ack报文\",{\"1\":{\"36\":1,\"255\":1}}],[\"向客户端发出响应\",{\"1\":{\"129\":2}}],[\"向对方发送相应的字节数\",{\"1\":{\"27\":1}}],[\"标志用于指示一个\",{\"1\":{\"299\":1}}],[\"标志的tcp报文到服务器\",{\"1\":{\"31\":1,\"299\":1}}],[\"标识符\",{\"1\":{\"142\":1}}],[\"标识的tcp报文之后\",{\"1\":{\"33\":1,\"301\":1}}],[\"标识的tcp报文\",{\"1\":{\"32\":1,\"300\":1}}],[\"标准规定\",{\"1\":{\"82\":1}}],[\"标准规定单精度浮点的指数取值范围是\",{\"1\":{\"82\":1}}],[\"标记为脏的\",{\"1\":{\"67\":1}}],[\"标记为脏的就好了\",{\"1\":{\"66\":1}}],[\"标记为\",{\"1\":{\"56\":2,\"69\":2}}],[\"会分配暂时的端口号\",{\"1\":{\"287\":1}}],[\"会断开连接吗\",{\"0\":{\"267\":1}}],[\"会随着响应数据一起立刻发送给对方\",{\"1\":{\"262\":1}}],[\"会回复一个\",{\"1\":{\"250\":1}}],[\"会回复一个带有syn和ack\",{\"1\":{\"32\":1,\"300\":1}}],[\"会认为第二次握手丢失就会重传syn\",{\"1\":{\"244\":1}}],[\"会认为第一次握手报文丢失就会重新传syn报文\",{\"1\":{\"244\":1}}],[\"会触发超时重传\",{\"1\":{\"243\":1}}],[\"会被操作系统调整\",{\"1\":{\"228\":1}}],[\"会被放在已排队等候的其他已接收的数据之后\",{\"1\":{\"179\":1}}],[\"会重新发送序号为101的数据段\",{\"1\":{\"221\":1}}],[\"会重传\",{\"1\":{\"169\":1}}],[\"会一点一点提高发送数据包的数量\",{\"1\":{\"216\":1}}],[\"会开启\",{\"1\":{\"210\":1}}],[\"会将其插入到队列里\",{\"1\":{\"207\":1}}],[\"会将它放到缓冲区\",{\"1\":{\"25\":1}}],[\"会发生什么\",{\"1\":{\"270\":1}}],[\"会发生\",{\"1\":{\"205\":2}}],[\"会发生回绕为初始值的情况\",{\"1\":{\"163\":1,\"246\":1}}],[\"会对数据进行\",{\"1\":{\"197\":1}}],[\"会导致端口资源耗尽而无法建立新的连接吗\",{\"0\":{\"193\":1}}],[\"会调用\",{\"1\":{\"176\":1}}],[\"会判断ack包的合法性\",{\"1\":{\"169\":1}}],[\"会占用系统资源\",{\"1\":{\"164\":1}}],[\"会再触发一个软中断\",{\"1\":{\"147\":1}}],[\"会再次更新\",{\"1\":{\"93\":1}}],[\"会返回\",{\"1\":{\"143\":1}}],[\"会填入一个不可能的端口号值作为\",{\"1\":{\"143\":1}}],[\"会构建一个\",{\"1\":{\"142\":1}}],[\"会去拆开\",{\"1\":{\"136\":1}}],[\"会把证书也发给客户端\",{\"1\":{\"129\":1}}],[\"会话层\",{\"1\":{\"283\":1}}],[\"会话秘钥\",{\"1\":{\"129\":11}}],[\"会话复用\",{\"0\":{\"122\":1}}],[\"会有一定的开销\",{\"1\":{\"174\":1}}],[\"会有一个cookies队列吗\",{\"0\":{\"184\":1}}],[\"会有一个队列用于保存这些数据包\",{\"1\":{\"169\":1}}],[\"会有一个限制\",{\"1\":{\"104\":1}}],[\"会有两个特殊的单向流\",{\"1\":{\"116\":1}}],[\"会有\",{\"1\":{\"88\":1}}],[\"会先通过请求资源的时间与\",{\"1\":{\"93\":1}}],[\"会先禁止网卡中断\",{\"1\":{\"72\":1}}],[\"会先将内存中的数据加载到共享的\",{\"1\":{\"49\":1}}],[\"会打断其他进程的运行\",{\"1\":{\"71\":1}}],[\"会打断正在执行的进程\",{\"1\":{\"71\":1}}],[\"会按照此优先级顺序进行选择\",{\"1\":{\"61\":1}}],[\"会优先选择\",{\"1\":{\"60\":1}}],[\"会向服务器发送一个带有ack标志的确认报文段\",{\"1\":{\"33\":1,\"301\":1}}],[\"第五次是在超时重传\",{\"1\":{\"243\":1}}],[\"第四次超时重传是在\",{\"1\":{\"243\":1}}],[\"第四次握手前\",{\"1\":{\"129\":1}}],[\"第四次挥手丢失\",{\"0\":{\"259\":1}}],[\"第四次挥手\",{\"0\":{\"38\":1},\"1\":{\"255\":1,\"308\":1}}],[\"第三\",{\"1\":{\"213\":1}}],[\"第三个场景\",{\"1\":{\"166\":1}}],[\"第三方应用程序使用访问令牌向微信服务器请求用户的个人信息\",{\"1\":{\"45\":1}}],[\"第三方应用程序可以使用此访问令牌来获取用户的个人信息\",{\"1\":{\"45\":1}}],[\"第三方网站或应用程序生成一个用于登录的二维码\",{\"1\":{\"45\":1}}],[\"第三次超时重传是在\",{\"1\":{\"243\":1}}],[\"第三次挥手丢失\",{\"0\":{\"258\":1}}],[\"第三次挥手\",{\"0\":{\"37\":1},\"1\":{\"255\":1,\"308\":1}}],[\"第三次握手丢失\",{\"0\":{\"245\":1}}],[\"第三次握手是可以携带数据的\",{\"1\":{\"238\":1}}],[\"第三次握手之后\",{\"1\":{\"33\":1,\"301\":1}}],[\"第三次握手\",{\"0\":{\"33\":1,\"301\":1},\"1\":{\"238\":1}}],[\"第二\",{\"1\":{\"213\":1}}],[\"第二个场景\",{\"1\":{\"166\":1}}],[\"第二个环节\",{\"1\":{\"118\":1}}],[\"第二种\",{\"1\":{\"138\":1}}],[\"第二种叫\",{\"1\":{\"122\":1}}],[\"第二轮结束后共享的消息\",{\"1\":{\"129\":1}}],[\"第二点\",{\"1\":{\"39\":1,\"67\":1}}],[\"第二次超时重传是在\",{\"1\":{\"243\":1}}],[\"第二次挥手丢失\",{\"0\":{\"257\":1}}],[\"第二次挥手\",{\"0\":{\"36\":1},\"1\":{\"255\":1,\"308\":1}}],[\"第二次握手丢失\",{\"0\":{\"244\":1}}],[\"第二次握手之后\",{\"1\":{\"32\":1,\"300\":1}}],[\"第二次握手\",{\"0\":{\"32\":1,\"300\":1},\"1\":{\"238\":1}}],[\"第一\",{\"1\":{\"213\":1}}],[\"第一个场景\",{\"1\":{\"166\":1}}],[\"第一个路由器过了\",{\"1\":{\"143\":1}}],[\"第一个是类型\",{\"1\":{\"142\":1}}],[\"第一个环节的性能损耗更大一些\",{\"1\":{\"118\":1}}],[\"第一个环节\",{\"1\":{\"118\":1}}],[\"第一种就是改用\",{\"1\":{\"138\":1}}],[\"第一种叫\",{\"1\":{\"122\":1}}],[\"第一点写传播很容易就理解\",{\"1\":{\"67\":1}}],[\"第一点\",{\"1\":{\"39\":1,\"67\":1}}],[\"第一次超时重传是在\",{\"1\":{\"243\":1}}],[\"第一次建立握手时还是三次链接\",{\"1\":{\"196\":1}}],[\"第一次挥手丢失\",{\"0\":{\"256\":1},\"1\":{\"256\":1}}],[\"第一次挥手\",{\"0\":{\"35\":1},\"1\":{\"255\":1,\"308\":1}}],[\"第一次握手之后\",{\"1\":{\"31\":1,\"299\":1}}],[\"第一次握手\",{\"0\":{\"31\":1,\"299\":1},\"1\":{\"238\":1}}],[\"客户端主机宕机又重启\",{\"0\":{\"271\":1}}],[\"客户端主机崩溃了\",{\"1\":{\"270\":1}}],[\"客户端主动想要断开连接\",{\"1\":{\"35\":1,\"255\":1}}],[\"客户端突然挂怎么办\",{\"0\":{\"268\":1}}],[\"客户端不会从fin\",{\"1\":{\"263\":1}}],[\"客户端不建议使用\",{\"1\":{\"192\":1}}],[\"客户端接收到第二次挥手的时候\",{\"1\":{\"257\":1}}],[\"客户端接收之后进入fin\",{\"1\":{\"36\":1,\"255\":1}}],[\"客户端和服务端都会触发超时重传机制\",{\"1\":{\"244\":1}}],[\"客户端和服务器首次\",{\"1\":{\"122\":1}}],[\"客户端和服务器可以各自选择一组\",{\"1\":{\"115\":1,\"281\":1}}],[\"客户端和服务器都进入established\",{\"1\":{\"33\":1,\"301\":1}}],[\"客户端的ack报文丢失\",{\"1\":{\"259\":1}}],[\"客户端的syn中的端口号和历史连接的不同\",{\"1\":{\"249\":1}}],[\"客户端的syn报文中的源端口号和历史连接的不同\",{\"1\":{\"249\":1}}],[\"客户端的端口数最多为\",{\"1\":{\"205\":1}}],[\"客户端的\",{\"1\":{\"205\":1,\"265\":1,\"266\":1}}],[\"客户端优化\",{\"1\":{\"196\":1}}],[\"客户端是可以自己连自己的形成连接\",{\"1\":{\"181\":1}}],[\"客户端请求建立连接会发生什么\",{\"0\":{\"180\":1}}],[\"客户端请求授权\",{\"1\":{\"43\":1}}],[\"客户端断开连接时\",{\"1\":{\"176\":1}}],[\"客户端调用\",{\"0\":{\"179\":1},\"1\":{\"176\":2,\"179\":1,\"193\":1}}],[\"客户端开启了\",{\"1\":{\"166\":1}}],[\"客户端禁用了\",{\"1\":{\"166\":1}}],[\"客户端就直接进入close状态\",{\"1\":{\"259\":1}}],[\"客户端就会直接进入close状态\",{\"1\":{\"256\":1,\"257\":1}}],[\"客户端就会延长租期\",{\"1\":{\"137\":1}}],[\"客户端就要停止使用租约的\",{\"1\":{\"137\":1}}],[\"客户端就已经发送了加密的\",{\"1\":{\"129\":1}}],[\"客户端将该\",{\"1\":{\"137\":1}}],[\"客户端将授权代码发送给授权服务器\",{\"1\":{\"43\":1}}],[\"客户端首先发起\",{\"1\":{\"137\":1}}],[\"客户端随机数\",{\"1\":{\"129\":1}}],[\"客户端握手结束通知\",{\"1\":{\"129\":2}}],[\"客户端收到服务器的连接释放请求后\",{\"1\":{\"308\":1}}],[\"客户端收到服务器的回应之后\",{\"1\":{\"129\":2}}],[\"客户端收到这个\",{\"1\":{\"249\":1}}],[\"客户端收到一个或多个服务器的\",{\"1\":{\"137\":1}}],[\"客户端收到授权代码\",{\"1\":{\"43\":1}}],[\"客户端生产的随机数\",{\"1\":{\"129\":2}}],[\"客户端支持的密码套件列表\",{\"1\":{\"129\":2}}],[\"客户端支持的\",{\"1\":{\"129\":2}}],[\"客户端会触发超时重传\",{\"1\":{\"256\":1}}],[\"客户端会发送一个syn\",{\"1\":{\"170\":1}}],[\"客户端会发送一个带有syn\",{\"1\":{\"31\":1,\"299\":1}}],[\"客户端会向\",{\"1\":{\"137\":1}}],[\"客户端会向服务器发送\",{\"1\":{\"137\":1}}],[\"客户端会把\",{\"1\":{\"122\":1}}],[\"客户端增多\",{\"1\":{\"122\":1}}],[\"客户端再次e连接不一定会命中上次访问过的服务器\",{\"1\":{\"122\":1}}],[\"客户端可以通过这个\",{\"1\":{\"116\":1}}],[\"客户端在发送ack之后进入time\",{\"1\":{\"259\":1}}],[\"客户端在\",{\"1\":{\"181\":1}}],[\"客户端在访问\",{\"1\":{\"107\":1}}],[\"客户端在接收服务器的带有syn和ack\",{\"1\":{\"33\":1,\"301\":1}}],[\"客户端通过\",{\"1\":{\"107\":1}}],[\"客户端发送请求时\",{\"1\":{\"88\":1}}],[\"客户端以自身身份获取访问令牌\",{\"1\":{\"44\":1}}],[\"客户端凭证模式\",{\"1\":{\"44\":1}}],[\"客户端使用访问令牌访问资源服务器上的资源\",{\"1\":{\"43\":1}}],[\"客户端访问资源\",{\"1\":{\"43\":1}}],[\"客户端交换授权代码\",{\"1\":{\"43\":1}}],[\"客户端获取授权代码\",{\"1\":{\"43\":1}}],[\"客户端向服务器发送连接释放请求\",{\"1\":{\"308\":1}}],[\"客户端向服务器索要并验证服务器的公钥\",{\"1\":{\"129\":1}}],[\"客户端向服务端发送fin报文\",{\"1\":{\"256\":1}}],[\"客户端向服务端发送一个\",{\"1\":{\"238\":1}}],[\"客户端向服务端发送一个带有初始化序列号\",{\"1\":{\"238\":1}}],[\"客户端向服务端发送ack报文\",{\"1\":{\"38\":1,\"255\":1}}],[\"客户端向资源所有者请求授权\",{\"1\":{\"43\":1}}],[\"客户端\",{\"0\":{\"193\":1,\"308\":1},\"1\":{\"43\":1,\"137\":1,\"178\":1}}],[\"客户端处于syn\",{\"1\":{\"31\":1,\"32\":1,\"299\":1,\"300\":1}}],[\"放入syn报文段中\",{\"1\":{\"31\":1,\"299\":1}}],[\"95\",{\"1\":{\"82\":1}}],[\"9\",{\"0\":{\"29\":1},\"1\":{\"82\":3}}],[\"也称二层网络设备\",{\"1\":{\"306\":1}}],[\"也会造成某一个stream的窗口无法滑动\",{\"1\":{\"278\":1}}],[\"也会进入close状态\",{\"1\":{\"258\":1}}],[\"也有一个最大重传次数\",{\"1\":{\"244\":1}}],[\"也有此相同的数据\",{\"1\":{\"56\":1}}],[\"也同样在传输层组装\",{\"1\":{\"174\":1}}],[\"也同时返回了\",{\"1\":{\"143\":1}}],[\"也不会丢弃\",{\"1\":{\"212\":1}}],[\"也不会重发第二次握手的信息\",{\"1\":{\"185\":1}}],[\"也不会影响\",{\"1\":{\"174\":1}}],[\"也不知道\",{\"1\":{\"137\":1}}],[\"也叫点对点\",{\"1\":{\"150\":1}}],[\"也是就终于找到\",{\"1\":{\"307\":1}}],[\"也是需要三次握手来建立连接的\",{\"1\":{\"275\":1}}],[\"也是一个绝对指针\",{\"1\":{\"224\":1}}],[\"也是能被接受的\",{\"1\":{\"212\":1}}],[\"也是有解决办法的\",{\"1\":{\"193\":1}}],[\"也是顺着网卡发出\",{\"1\":{\"146\":1}}],[\"也是\",{\"1\":{\"145\":1}}],[\"也是通过建立\",{\"1\":{\"133\":1}}],[\"也是后面用于生产\",{\"1\":{\"129\":1}}],[\"也能减少客户端的运算量\",{\"1\":{\"121\":1}}],[\"也可以实现可靠传输\",{\"1\":{\"287\":1}}],[\"也可以两个客户端同时向对方发出请求建立连接\",{\"1\":{\"181\":1}}],[\"也可以接收对端主机发回来的回送应答消息\",{\"1\":{\"142\":1}}],[\"也可以是正数\",{\"1\":{\"82\":1}}],[\"也可能是负数\",{\"1\":{\"82\":1}}],[\"也可能多个小的数据包会被合并成一个大数据包发送\",{\"1\":{\"26\":1}}],[\"也正因为成本太高\",{\"1\":{\"78\":1}}],[\"也正好变量\",{\"1\":{\"56\":1}}],[\"也用状态机机制降低了总线带宽压力\",{\"1\":{\"68\":1}}],[\"也很简单\",{\"1\":{\"65\":1}}],[\"也因此不会产生伪共享的问题\",{\"1\":{\"57\":1}}],[\"也就进入了\",{\"1\":{\"217\":1}}],[\"也就不同\",{\"1\":{\"158\":1}}],[\"也就说\",{\"1\":{\"177\":1}}],[\"也就说软中断\",{\"1\":{\"72\":1}}],[\"也就说中断有可能会丢失\",{\"1\":{\"71\":1}}],[\"也就是对网线中的信号执行发送和接收操作\",{\"1\":{\"297\":1}}],[\"也就是传输层\",{\"1\":{\"285\":1}}],[\"也就是建立连接之前\",{\"1\":{\"239\":1}}],[\"也就是小于\",{\"1\":{\"230\":1}}],[\"也就是小数部分\",{\"1\":{\"82\":1}}],[\"也就是窗口大小\",{\"1\":{\"222\":1}}],[\"也就是设置为原来的一半\",{\"1\":{\"218\":1}}],[\"也就是一个完整的用户消息被拆分成多个\",{\"1\":{\"208\":1}}],[\"也就是一对多是无法做到的\",{\"1\":{\"203\":1}}],[\"也就是服务端单机最大\",{\"1\":{\"205\":1}}],[\"也就是没有listen\",{\"1\":{\"181\":1}}],[\"也就是最长匹配\",{\"1\":{\"157\":1}}],[\"也就是将\",{\"1\":{\"151\":1}}],[\"也就是网络层\",{\"1\":{\"150\":1}}],[\"也就是互联网控制报文协议\",{\"1\":{\"139\":1}}],[\"也就是hypertext\",{\"1\":{\"86\":1}}],[\"也就是我们编程语言中的\",{\"1\":{\"82\":1}}],[\"也就是指令本身\",{\"1\":{\"75\":1}}],[\"也就是硬中断\",{\"1\":{\"72\":1}}],[\"也就是中断的下半部\",{\"1\":{\"72\":1}}],[\"也就是中断处理程序\",{\"1\":{\"71\":1}}],[\"也就是说就算\",{\"1\":{\"275\":1}}],[\"也就是说\",{\"1\":{\"69\":1,\"138\":1,\"197\":1}}],[\"也就是说先从\",{\"1\":{\"61\":1}}],[\"也就是保障每个任务的运行的时间是差不多的\",{\"1\":{\"62\":1}}],[\"也就是完全公平调度\",{\"1\":{\"60\":1}}],[\"也就是优先级高的可以\",{\"1\":{\"59\":1}}],[\"也就是要尽可能快的执行实时任务\",{\"1\":{\"58\":1}}],[\"也就是\",{\"1\":{\"52\":1,\"57\":1,\"82\":1,\"139\":2,\"224\":2,\"225\":1,\"261\":2,\"277\":1}}],[\"也就跑的越快\",{\"1\":{\"50\":1}}],[\"也即再次进入拥塞避免状态\",{\"1\":{\"28\":1,\"219\":1}}],[\"可用窗口大小\",{\"1\":{\"224\":1}}],[\"可用窗口的大小就为\",{\"1\":{\"223\":1}}],[\"可用范围非常大\",{\"1\":{\"138\":1}}],[\"可靠性\",{\"1\":{\"174\":1}}],[\"可靠的\",{\"1\":{\"21\":1,\"203\":2}}],[\"可自动配置\",{\"1\":{\"159\":1}}],[\"可承载的\",{\"1\":{\"158\":1}}],[\"可能会导致连接建立失败\",{\"1\":{\"170\":1}}],[\"可能还需要依赖\",{\"1\":{\"107\":1}}],[\"可能还会\",{\"1\":{\"71\":1}}],[\"可能导致数据错乱或者连接错误\",{\"1\":{\"39\":1}}],[\"可以通过arp协议获取对方mac地址\",{\"1\":{\"291\":1}}],[\"可以通过指定域名属性来确保\",{\"1\":{\"46\":1}}],[\"可以针对不同的应用设置不同的拥塞控制算法\",{\"1\":{\"279\":1}}],[\"可以随浏览器更新\",{\"1\":{\"279\":1}}],[\"可以认为就是一条\",{\"1\":{\"278\":1}}],[\"可以认定之前的数据全部被接收\",{\"1\":{\"201\":1}}],[\"可以支持乱序确认\",{\"1\":{\"275\":1}}],[\"可以标识发送出去的数据包中\",{\"1\":{\"239\":1}}],[\"可以携带数据\",{\"1\":{\"238\":1}}],[\"可以知道网络中是不是把\",{\"1\":{\"236\":1}}],[\"可以知道是不是\",{\"1\":{\"236\":1}}],[\"可以让\",{\"1\":{\"236\":1}}],[\"可以将已收到的数据的信息发送给\",{\"1\":{\"235\":1}}],[\"可以\",{\"1\":{\"187\":1}}],[\"可以向对端主机发送回送请求的消息\",{\"1\":{\"142\":1}}],[\"可以采用体积更小的\",{\"1\":{\"133\":1}}],[\"可以采用上面的宏定义使得变量在\",{\"1\":{\"57\":1}}],[\"可以不用等最后一次握手结束就可以传输消息\",{\"1\":{\"129\":1}}],[\"可以保证地球上的每粒沙子都能被分配到一个\",{\"1\":{\"159\":1}}],[\"可以保证内容不被篡改\",{\"1\":{\"128\":1}}],[\"可以保存\",{\"1\":{\"105\":1}}],[\"可以有两个方向\",{\"1\":{\"121\":1}}],[\"可以由多个\",{\"1\":{\"106\":1}}],[\"可以鉴赏http请求次数\",{\"1\":{\"98\":1}}],[\"可以使用全局单播地址\",{\"1\":{\"159\":1}}],[\"可以使用唯一本地地址\",{\"1\":{\"159\":1}}],[\"可以使用链路本地单播地址\",{\"1\":{\"159\":1}}],[\"可以使用客户端的缓存\",{\"1\":{\"97\":1}}],[\"可以使用管道\",{\"1\":{\"95\":1}}],[\"可以使用分布式数据库\",{\"1\":{\"47\":1}}],[\"可以看到\",{\"1\":{\"82\":1}}],[\"可以表示成\",{\"1\":{\"82\":1}}],[\"可以计算的数值就越大\",{\"1\":{\"75\":1}}],[\"可以用于存放\",{\"1\":{\"181\":1}}],[\"可以用来确认网络包是否有丢失\",{\"1\":{\"142\":1}}],[\"可以用更少的计算量计算出公钥\",{\"1\":{\"129\":1}}],[\"可以用\",{\"1\":{\"72\":1,\"95\":1}}],[\"可以提高系统的并发处理能力\",{\"1\":{\"71\":1}}],[\"可以发现当\",{\"1\":{\"69\":1}}],[\"可以发现\",{\"1\":{\"68\":1,\"81\":1,\"137\":1}}],[\"可以发现如果\",{\"1\":{\"56\":1}}],[\"可以指定\",{\"1\":{\"62\":1,\"261\":1}}],[\"可以调整任务的\",{\"1\":{\"62\":1}}],[\"可以适当降低它的优先级\",{\"1\":{\"59\":1}}],[\"可以抢占低优先级的任务\",{\"1\":{\"59\":1}}],[\"可以创建多个线程分别去处理\",{\"1\":{\"58\":1}}],[\"可以减少访问\",{\"1\":{\"53\":1}}],[\"可以直接从\",{\"1\":{\"52\":1}}],[\"可以考虑使用负载均衡器如\",{\"1\":{\"47\":1}}],[\"可以考虑在服务器端设置代理\",{\"1\":{\"46\":1}}],[\"可以选择允许或拒绝\",{\"1\":{\"45\":1}}],[\"可以回到恢复之前的状态了\",{\"1\":{\"28\":1,\"219\":1}}],[\"该值是接收方基于当前已经提交的偏移量\",{\"1\":{\"278\":1}}],[\"该探测报文包含的数据非常少\",{\"1\":{\"268\":1}}],[\"该计数器的数值每\",{\"1\":{\"246\":1}}],[\"该位为\",{\"1\":{\"201\":4}}],[\"该报文信息携带服务器提供可租约的\",{\"1\":{\"137\":1}}],[\"该报文仍然使用\",{\"1\":{\"137\":1}}],[\"该设备会发送一条\",{\"1\":{\"136\":1}}],[\"该随机数会被服务器公钥加密\",{\"1\":{\"129\":1}}],[\"该方法在小数点左边只有一个数字\",{\"1\":{\"82\":1}}],[\"该任务的\",{\"1\":{\"60\":1}}],[\"该宏定义是空的\",{\"1\":{\"57\":1}}],[\"该宏定义是\",{\"1\":{\"57\":1}}],[\"该令牌用于代表用户访问其个人信息\",{\"1\":{\"45\":1}}],[\"该恢复过程已经结束\",{\"1\":{\"28\":1,\"219\":1}}],[\"该进程就成为僵尸进程\",{\"1\":{\"20\":1}}],[\"确定是tcp还是udp然后交给对应的模块\",{\"1\":{\"187\":1}}],[\"确定\",{\"1\":{\"136\":1}}],[\"确定了源\",{\"1\":{\"136\":1}}],[\"确定的\",{\"1\":{\"111\":1}}],[\"确保设备可以接收\",{\"1\":{\"306\":1}}],[\"确保网络的稳定性和低延迟\",{\"1\":{\"170\":1}}],[\"确保允许了tcp连接建立所需要的端口和协议\",{\"1\":{\"169\":1}}],[\"确保路径参数设置为\",{\"1\":{\"46\":1}}],[\"确保连接的稳定和可靠\",{\"1\":{\"22\":1}}],[\"确认报文以后\",{\"1\":{\"248\":1}}],[\"确认收到了序号为1至98的数据\",{\"1\":{\"221\":1}}],[\"确认收到了1至100的数据\",{\"1\":{\"221\":1}}],[\"确认应答报文\",{\"1\":{\"233\":1}}],[\"确认应答后\",{\"1\":{\"223\":1}}],[\"确认应答\",{\"1\":{\"201\":1}}],[\"确认应答号为服务端isn加1的\",{\"1\":{\"238\":1}}],[\"确认应答号是客户端的isn+1\",{\"1\":{\"238\":1}}],[\"确认应答号\",{\"1\":{\"201\":1}}],[\"确认服务器的数字证书的真实性\",{\"1\":{\"129\":2}}],[\"确认的密码套件列表\",{\"1\":{\"129\":2}}],[\"确认\",{\"1\":{\"129\":2,\"139\":1,\"170\":2}}],[\"确认号\",{\"1\":{\"32\":1,\"33\":1,\"248\":2,\"250\":1,\"300\":1,\"301\":1}}],[\"确认了新的数据\",{\"1\":{\"28\":1,\"219\":1}}],[\"原因是该\",{\"1\":{\"28\":1,\"219\":1}}],[\"的对应关系\",{\"0\":{\"295\":1}}],[\"的拥塞控制算法就可以有较快的迭代速度\",{\"1\":{\"279\":1}}],[\"的全部接收缓冲\",{\"1\":{\"278\":1}}],[\"的滑动窗口滑动的条件跟\",{\"1\":{\"278\":1}}],[\"的情况呢\",{\"1\":{\"270\":1}}],[\"的情况下\",{\"1\":{\"153\":1}}],[\"的序列号\",{\"1\":{\"250\":1}}],[\"的工具\",{\"0\":{\"250\":1,\"251\":1}}],[\"的工作流程主要涉及以下角色\",{\"1\":{\"43\":1}}],[\"的实际接收能力控制发送的数据量\",{\"1\":{\"227\":1}}],[\"的第一个字节了\",{\"1\":{\"224\":1,\"225\":1}}],[\"的第一个字节是个相对指针\",{\"1\":{\"224\":1,\"225\":1}}],[\"的第一个字节\",{\"1\":{\"224\":2,\"225\":1}}],[\"的第一个作用就是故意设置特殊的\",{\"1\":{\"143\":1}}],[\"的最大连接数是多少\",{\"1\":{\"205\":1}}],[\"的服务端监听了一个端口\",{\"1\":{\"205\":1}}],[\"的字段进行序列号初始值的设定\",{\"1\":{\"201\":1}}],[\"的字段变为有效\",{\"1\":{\"201\":1}}],[\"的新状态\",{\"1\":{\"197\":1}}],[\"的连接\",{\"1\":{\"197\":1}}],[\"的连接管理\",{\"1\":{\"112\":1}}],[\"的报错信息\",{\"0\":{\"190\":1}}],[\"的错误\",{\"1\":{\"189\":1}}],[\"的意义\",{\"0\":{\"177\":1}}],[\"的意思是确认有\",{\"1\":{\"28\":1,\"219\":1}}],[\"的文件描述符\",{\"1\":{\"176\":1}}],[\"的发送速率\",{\"1\":{\"174\":1}}],[\"的首部成为固定长度的\",{\"1\":{\"160\":1}}],[\"的校验\",{\"1\":{\"160\":1}}],[\"的公有\",{\"1\":{\"159\":1}}],[\"的私有\",{\"1\":{\"159\":1}}],[\"的主机名\",{\"1\":{\"157\":1}}],[\"的主机都能收到这个包\",{\"1\":{\"153\":1}}],[\"的主机向\",{\"1\":{\"153\":1}}],[\"的目标地址发送\",{\"1\":{\"153\":1}}],[\"的两个网络之间进行通信传输\",{\"1\":{\"150\":1}}],[\"的两个设备之间通信\",{\"1\":{\"150\":1}}],[\"的作用则是实现\",{\"1\":{\"150\":1}}],[\"的是本机的\",{\"1\":{\"148\":1}}],[\"的sendto接口的过程中进程会从用户态进入到内核态\",{\"1\":{\"146\":1}}],[\"的特殊地址\",{\"1\":{\"145\":1}}],[\"的不可达消息将数据链路上\",{\"1\":{\"143\":1}}],[\"的不同变量时\",{\"1\":{\"56\":1}}],[\"的应答包\",{\"1\":{\"142\":1}}],[\"的组播数据包\",{\"1\":{\"139\":1}}],[\"的成员\",{\"1\":{\"139\":1}}],[\"的信息给这个设备\",{\"1\":{\"136\":1}}],[\"的设备\",{\"1\":{\"136\":1}}],[\"的请求信息\",{\"1\":{\"136\":1}}],[\"的时间\",{\"1\":{\"162\":1}}],[\"的时间消耗\",{\"1\":{\"123\":1}}],[\"的时候用的是\",{\"1\":{\"146\":1}}],[\"的时候发出的多个数据包\",{\"1\":{\"142\":1}}],[\"的时候\",{\"1\":{\"72\":1,\"218\":1}}],[\"的通信则可以绕过三次握手发送数据\",{\"1\":{\"123\":1}}],[\"的效果\",{\"1\":{\"114\":1,\"280\":1}}],[\"的握手时延迟\",{\"1\":{\"108\":1}}],[\"的帧是可以乱序发送的\",{\"1\":{\"106\":1}}],[\"的编码表示\",{\"1\":{\"103\":1}}],[\"的头部\",{\"1\":{\"100\":1}}],[\"的安全问题\",{\"1\":{\"95\":1}}],[\"的优先级更高\",{\"1\":{\"94\":1}}],[\"的优先级高于\",{\"1\":{\"93\":1}}],[\"的语义是根据请求负荷\",{\"1\":{\"91\":1}}],[\"的语义是请求获取指定的资源\",{\"1\":{\"91\":1}}],[\"的边界\",{\"1\":{\"88\":2}}],[\"的指数偏移量是\",{\"1\":{\"82\":1}}],[\"的指数位是\",{\"1\":{\"82\":1}}],[\"的指数部分是\",{\"1\":{\"82\":2}}],[\"的有效数字是\",{\"1\":{\"82\":2}}],[\"的尾数部分是\",{\"1\":{\"82\":2}}],[\"的数字称为规格化\",{\"1\":{\"82\":1}}],[\"的数据也是要保证顺序的\",{\"1\":{\"278\":1}}],[\"的数据包丢失了\",{\"1\":{\"278\":1}}],[\"的数据包给复制了\",{\"1\":{\"236\":1}}],[\"的数据包被网络延迟了\",{\"1\":{\"236\":1}}],[\"的数据填满整个网络\",{\"1\":{\"215\":1}}],[\"的数据大小如果大于\",{\"1\":{\"174\":2}}],[\"的数据报文\",{\"1\":{\"158\":1}}],[\"的数据转换成十进制\",{\"1\":{\"82\":1}}],[\"的数据量\",{\"1\":{\"75\":1}}],[\"的数据和内存是不一致的\",{\"1\":{\"66\":1}}],[\"的数据写入\",{\"0\":{\"64\":1}}],[\"的数据都会被加载到\",{\"1\":{\"56\":1}}],[\"的数据归属于同一个\",{\"1\":{\"56\":1}}],[\"的数据是从内存中读取过来的\",{\"1\":{\"49\":1}}],[\"的运算过程\",{\"1\":{\"80\":1}}],[\"的运行情况\",{\"1\":{\"72\":2}}],[\"的二进制来表示\",{\"1\":{\"83\":1}}],[\"的二进制浮点数转换成十进制时\",{\"1\":{\"82\":1}}],[\"的二进制小数为\",{\"1\":{\"82\":1}}],[\"的二进制数\",{\"1\":{\"81\":1}}],[\"的二进制数表示如下\",{\"1\":{\"80\":1}}],[\"的二进制表示是无限循环的\",{\"1\":{\"81\":1}}],[\"的二进制取反后再加\",{\"1\":{\"80\":1}}],[\"的二进制是把数字\",{\"1\":{\"80\":1}}],[\"的位宽\",{\"1\":{\"75\":1}}],[\"的状态可以用一个有限状态机来表示它的状态流转\",{\"1\":{\"69\":1}}],[\"的状态就会变成\",{\"1\":{\"69\":1}}],[\"的状态是共享状态\",{\"1\":{\"69\":1}}],[\"的状态是\",{\"1\":{\"56\":1}}],[\"的差别在于\",{\"1\":{\"69\":1}}],[\"的概念\",{\"1\":{\"67\":1,\"215\":1}}],[\"的执行结果写入到\",{\"1\":{\"67\":1}}],[\"的问题了\",{\"1\":{\"80\":1}}],[\"的问题\",{\"1\":{\"67\":1,\"88\":1}}],[\"的话偏移量是\",{\"1\":{\"82\":1}}],[\"的话\",{\"1\":{\"66\":1,\"180\":1,\"229\":1}}],[\"的范围是\",{\"1\":{\"62\":1,\"155\":1}}],[\"的关系是这样的\",{\"1\":{\"62\":1}}],[\"的调度算法\",{\"1\":{\"60\":1}}],[\"的任务会被优先调度\",{\"1\":{\"59\":1}}],[\"的可能\",{\"1\":{\"57\":1}}],[\"的\",{\"1\":{\"57\":1,\"66\":1,\"72\":2,\"136\":1,\"137\":1,\"147\":1,\"164\":2,\"191\":1,\"201\":1,\"203\":1,\"205\":3,\"210\":1,\"238\":1,\"252\":2,\"265\":2,\"266\":2,\"275\":1}}],[\"的方式去解析待会你输入的网络地址\",{\"1\":{\"146\":1}}],[\"的方式解决\",{\"1\":{\"95\":1}}],[\"的方式运行\",{\"1\":{\"72\":1}}],[\"的方式\",{\"1\":{\"57\":1,\"128\":1}}],[\"的大小就会加\",{\"1\":{\"216\":1}}],[\"的大小通常很大\",{\"1\":{\"100\":1}}],[\"的大小\",{\"1\":{\"57\":1,\"143\":1,\"177\":1,\"248\":1}}],[\"的大小是\",{\"1\":{\"56\":1,\"57\":1}}],[\"的单位是\",{\"1\":{\"56\":1}}],[\"的单位\",{\"1\":{\"56\":1}}],[\"的开头位置\",{\"1\":{\"56\":1}}],[\"的变量\",{\"1\":{\"56\":1}}],[\"的缓存命中率可以得到有效提高\",{\"1\":{\"53\":1}}],[\"的缓存命中率\",{\"0\":{\"53\":1}}],[\"的次数会比较多\",{\"1\":{\"52\":1}}],[\"的地址是\",{\"1\":{\"159\":1}}],[\"的地址设置为\",{\"1\":{\"57\":1}}],[\"的地址\",{\"1\":{\"49\":2,\"75\":1}}],[\"的路径\",{\"1\":{\"46\":1}}],[\"的域名属性为\",{\"1\":{\"46\":1}}],[\"的域名属性\",{\"1\":{\"46\":1}}],[\"的基本授权流程如下\",{\"1\":{\"43\":1}}],[\"的一方\",{\"1\":{\"39\":1,\"163\":1}}],[\"的值会发生变化\",{\"1\":{\"218\":1}}],[\"的值一般是\",{\"1\":{\"162\":1}}],[\"的值一起给发送主机\",{\"1\":{\"143\":1}}],[\"的值能设置的范围是\",{\"1\":{\"62\":1}}],[\"的值是\",{\"1\":{\"49\":1}}],[\"的值\",{\"1\":{\"28\":1,\"62\":1,\"69\":2,\"219\":1}}],[\"把传输工作给操作系统中的协议栈\",{\"0\":{\"297\":1}}],[\"把私有\",{\"1\":{\"138\":1}}],[\"把之前所有内容的发生的数据做个摘要\",{\"1\":{\"129\":2}}],[\"把响应报文划分成了两类帧\",{\"1\":{\"105\":1}}],[\"把url作为key\",{\"1\":{\"97\":1}}],[\"把移动的位数再加上\",{\"1\":{\"82\":1}}],[\"把数据输出给输出设备\",{\"1\":{\"77\":1}}],[\"把数据同时写入内存和\",{\"1\":{\"65\":1}}],[\"把一些处理比较耗时且复杂的事情\",{\"1\":{\"72\":1}}],[\"把当前要写入的数据先从内存读入到\",{\"1\":{\"66\":1}}],[\"把这些指令放在指令缓存中\",{\"1\":{\"52\":1}}],[\"把\",{\"1\":{\"28\":1,\"120\":1,\"138\":1,\"219\":1}}],[\"后发送\",{\"1\":{\"162\":1}}],[\"后面是主机号\",{\"1\":{\"155\":1}}],[\"后面用于生成\",{\"1\":{\"129\":2}}],[\"后变成\",{\"1\":{\"67\":1}}],[\"后台任务的调度策略\",{\"1\":{\"59\":1}}],[\"后置填充\",{\"1\":{\"57\":1}}],[\"后续再在收到\",{\"1\":{\"169\":1}}],[\"后续网络中一旦该组播地址的数据到达路由器\",{\"1\":{\"139\":1}}],[\"后续用此密钥来保护应用程序数据\",{\"1\":{\"130\":1}}],[\"后续客户端与服务端\",{\"1\":{\"123\":1}}],[\"后续就可以使用这个字典来编码了\",{\"1\":{\"116\":1}}],[\"后续的收到请求\",{\"1\":{\"104\":1}}],[\"后续\",{\"1\":{\"52\":1}}],[\"后\",{\"1\":{\"28\":1,\"100\":1,\"137\":1,\"219\":1}}],[\"后端技术\",{\"0\":{\"6\":1}}],[\"个路由器的时间不会超过\",{\"1\":{\"162\":1}}],[\"个小数据报进行传输\",{\"1\":{\"158\":1}}],[\"个并发\",{\"1\":{\"106\":1}}],[\"个标志位\",{\"1\":{\"105\":1}}],[\"个二进制有效位\",{\"1\":{\"82\":2}}],[\"个状态单词的开头字母缩写\",{\"1\":{\"69\":1}}],[\"个核心都操作共同的变量\",{\"1\":{\"67\":1}}],[\"个核心的\",{\"1\":{\"67\":1}}],[\"个不会被读写的\",{\"1\":{\"57\":1}}],[\"个字节的\",{\"1\":{\"262\":1}}],[\"个字节的数据了\",{\"1\":{\"223\":1}}],[\"个字节的数据被应答确认\",{\"1\":{\"223\":1}}],[\"个字节是流标识符\",{\"1\":{\"105\":1}}],[\"个字节\",{\"1\":{\"57\":2,\"75\":3,\"145\":1,\"174\":2,\"223\":1}}],[\"个内存块\",{\"1\":{\"49\":1}}],[\"个\",{\"1\":{\"49\":2,\"57\":5,\"100\":1,\"106\":1,\"114\":1,\"123\":1,\"139\":2,\"280\":1}}],[\"个时钟周期\",{\"1\":{\"49\":3}}],[\"个数据包被收到了\",{\"1\":{\"28\":1,\"219\":1}}],[\"个人格言\",{\"0\":{\"15\":1}}],[\"个人信息\",{\"0\":{\"1\":1}}],[\"+127\",{\"1\":{\"82\":1}}],[\"+3\",{\"1\":{\"82\":1}}],[\"+\",{\"1\":{\"28\":1,\"49\":4,\"57\":1,\"62\":1,\"80\":2,\"81\":1,\"82\":1,\"83\":1,\"114\":1,\"123\":1,\"129\":8,\"138\":1,\"181\":1,\"188\":1,\"192\":1,\"210\":1,\"219\":1,\"230\":1,\"241\":1,\"248\":4,\"280\":1}}],[\"=\",{\"1\":{\"28\":1,\"46\":2,\"52\":1,\"62\":1,\"82\":1,\"177\":1,\"215\":1,\"218\":2,\"219\":1,\"224\":1,\"241\":1,\"248\":2}}],[\"快速恢复\",{\"0\":{\"219\":1},\"1\":{\"28\":1}}],[\"快速重传解决了超时重传重传周期太长的问题\",{\"1\":{\"24\":1}}],[\"快速重传\",{\"0\":{\"234\":1},\"1\":{\"24\":1,\"218\":1}}],[\"进入fin\",{\"1\":{\"257\":1}}],[\"进入快速恢复算法如下\",{\"1\":{\"219\":1}}],[\"进入快速恢复算法\",{\"1\":{\"218\":1}}],[\"进入快恢复算法\",{\"1\":{\"28\":1}}],[\"进入\",{\"1\":{\"179\":1}}],[\"进入到网络层后加上icmp和ip头后\",{\"1\":{\"146\":1}}],[\"进入网卡的发送队列\",{\"1\":{\"146\":1}}],[\"进行监听\",{\"1\":{\"176\":1}}],[\"进行子网划分\",{\"1\":{\"155\":1}}],[\"进行通信\",{\"1\":{\"138\":1}}],[\"进行加密通信\",{\"1\":{\"129\":1}}],[\"进行交互的\",{\"1\":{\"77\":1}}],[\"进行调度的\",{\"1\":{\"59\":1}}],[\"进程崩溃\",{\"1\":{\"270\":1}}],[\"进程级\",{\"1\":{\"205\":1}}],[\"进程和线程都是用\",{\"1\":{\"58\":1}}],[\"进程会成为孤儿进程的新父进程\",{\"1\":{\"20\":1}}],[\"进程\",{\"1\":{\"20\":1}}],[\"直连\",{\"1\":{\"150\":1}}],[\"直到服务端重启进程\",{\"1\":{\"270\":1}}],[\"直到引用计数变为\",{\"1\":{\"261\":1}}],[\"直到窗口变为非\",{\"1\":{\"229\":1}}],[\"直到为0\",{\"1\":{\"162\":1}}],[\"直到到达目的主机\",{\"1\":{\"143\":1}}],[\"直到\",{\"1\":{\"113\":1}}],[\"直到不存在小数为止\",{\"1\":{\"81\":1}}],[\"直到其父进程请求并处理了它的终止状态为止\",{\"1\":{\"20\":1}}],[\"直接跳到syn\",{\"1\":{\"265\":1}}],[\"直接使得该\",{\"1\":{\"261\":1}}],[\"直接进入close状态\",{\"1\":{\"259\":1}}],[\"直接进行tls握手\",{\"1\":{\"123\":1}}],[\"直接导致发送方迟迟接收不到ack\",{\"1\":{\"242\":1}}],[\"直接重发就好了\",{\"1\":{\"213\":1}}],[\"直接取消了\",{\"1\":{\"160\":1}}],[\"直接更新数据即可\",{\"1\":{\"69\":1}}],[\"直接映射\",{\"1\":{\"49\":1}}],[\"直接获取访问令牌\",{\"1\":{\"44\":1}}],[\"直接将拥塞窗口降为1\",{\"1\":{\"28\":1}}],[\"发包个数呈指数增长\",{\"1\":{\"216\":1}}],[\"发现确认号\",{\"1\":{\"249\":1}}],[\"发现序号为99的数据段丢失了\",{\"1\":{\"221\":1}}],[\"发现报文时\",{\"1\":{\"137\":1}}],[\"发现报文\",{\"1\":{\"137\":1}}],[\"发现\",{\"1\":{\"69\":1}}],[\"发现数据对应的\",{\"1\":{\"69\":1}}],[\"发现此\",{\"1\":{\"56\":1}}],[\"发起的跨域请求\",{\"1\":{\"46\":1}}],[\"发生在三次握手的哪一步\",{\"0\":{\"178\":1}}],[\"发生快速重传的拥塞发生算法\",{\"1\":{\"28\":1}}],[\"发生超时重传的拥塞发生算法\",{\"1\":{\"28\":1}}],[\"发送一个探测报文\",{\"1\":{\"268\":1}}],[\"发送一堆数据包之后\",{\"1\":{\"24\":1}}],[\"发送给服务端\",{\"1\":{\"250\":1}}],[\"发送的\",{\"1\":{\"248\":1}}],[\"发送窗口和接收窗口中所存放的字节数\",{\"1\":{\"228\":1}}],[\"发送窗口的值是swnd\",{\"1\":{\"215\":1}}],[\"发送缓冲区不能超过\",{\"1\":{\"209\":1}}],[\"发送端收到接收方发来的\",{\"1\":{\"248\":1}}],[\"发送端接收到确认答应之后\",{\"1\":{\"201\":1}}],[\"发送端就可以跟据接收端和本端窗口大小\",{\"1\":{\"27\":1}}],[\"发送超过网络处理能力的报文时\",{\"1\":{\"198\":1}}],[\"发送主机端每次收到\",{\"1\":{\"143\":1}}],[\"发送方开启\",{\"1\":{\"230\":1}}],[\"发送方的滑动窗口\",{\"0\":{\"223\":1}}],[\"发送方收到这个确认后\",{\"1\":{\"221\":1}}],[\"发送方\",{\"1\":{\"215\":2,\"227\":1,\"235\":1,\"236\":4}}],[\"发送方也就无限地提升发送速度\",{\"1\":{\"198\":1}}],[\"发送方如何知道发出的\",{\"1\":{\"143\":1}}],[\"发送方根据接收方的窗口变化\",{\"1\":{\"27\":1}}],[\"发送方根据这一字段就可以精准定位这个丢失包\",{\"1\":{\"24\":1}}],[\"发送\",{\"1\":{\"139\":2,\"269\":1}}],[\"发送查询请求\",{\"1\":{\"121\":1}}],[\"发送字典\",{\"1\":{\"116\":1}}],[\"发送fin报文\",{\"1\":{\"37\":1,\"255\":1}}],[\"时候也会出错\",{\"1\":{\"188\":1}}],[\"时候就会出错\",{\"1\":{\"188\":1,\"192\":1}}],[\"时候参数\",{\"0\":{\"177\":1}}],[\"时还可以将这些\",{\"1\":{\"159\":1}}],[\"时才需要写到内存中\",{\"1\":{\"66\":1}}],[\"时间戳\",{\"1\":{\"184\":1,\"210\":1,\"265\":1,\"266\":1}}],[\"时间是一样\",{\"1\":{\"60\":1}}],[\"时间片用完了\",{\"1\":{\"53\":1}}],[\"时钟周期之间\",{\"1\":{\"49\":1}}],[\"时的数据都已收到\",{\"1\":{\"28\":1,\"219\":1}}],[\"时\",{\"1\":{\"28\":1,\"46\":1,\"106\":1,\"107\":1,\"158\":1,\"201\":4,\"216\":2,\"217\":1,\"229\":1}}],[\"每隔一个时间间隔\",{\"1\":{\"268\":1}}],[\"每4微秒加一\",{\"1\":{\"241\":1}}],[\"每当遇到一次超时重传的时候\",{\"1\":{\"233\":1}}],[\"每当收到一个\",{\"1\":{\"28\":1,\"217\":1}}],[\"每次超时的时间是上一次的\",{\"1\":{\"243\":1}}],[\"每次大约\",{\"1\":{\"229\":1}}],[\"每次写操作都会写回到内存\",{\"1\":{\"65\":1}}],[\"每收到一个新数据包都会读取数据包中的时间戳值跟\",{\"1\":{\"210\":1,\"246\":1}}],[\"每收到1次ack\",{\"1\":{\"28\":1}}],[\"每发送一次数据\",{\"1\":{\"201\":1,\"248\":1}}],[\"每发送一次新的回送请求就会加\",{\"1\":{\"142\":1}}],[\"每经过一个路由就会减一\",{\"1\":{\"162\":1}}],[\"每组用冒号\",{\"1\":{\"159\":1}}],[\"每组以\",{\"1\":{\"151\":1}}],[\"每种数据链路的\",{\"1\":{\"158\":1}}],[\"每种数据链路的最大传输单元\",{\"1\":{\"158\":1}}],[\"每种寄存器的功能又不尽相同\",{\"1\":{\"75\":1}}],[\"每一个应用都有对应的端口号\",{\"1\":{\"287\":1}}],[\"每一个分块我们称为tcp段\",{\"1\":{\"287\":1}}],[\"每一个请求都得携带\",{\"1\":{\"100\":1}}],[\"每一个字节都对应一个内存地址\",{\"1\":{\"74\":1}}],[\"每个设备都需要配置正确的\",{\"1\":{\"151\":1}}],[\"每个存储器只和相邻的一层存储器设备打交道\",{\"1\":{\"78\":1}}],[\"每个\",{\"1\":{\"61\":1,\"106\":1,\"205\":2,\"207\":1,\"278\":1}}],[\"每个任务都有一定的时间片\",{\"1\":{\"59\":1}}],[\"每段数据都会被标记上一个序列号\",{\"1\":{\"25\":1}}],[\"它需要\",{\"1\":{\"224\":1,\"225\":1}}],[\"它需要获得授权才能访问资源服务器上的受保护资源\",{\"1\":{\"43\":1}}],[\"它指向期望从发送方发送来的下一个数据字节的序列号\",{\"1\":{\"225\":1}}],[\"它指向未发送但可发送范围的第一个字节的序列号\",{\"1\":{\"224\":1}}],[\"它指向的是已发送但未收到确认的第一个字节的序列号\",{\"1\":{\"224\":1}}],[\"它会通告给发送方\",{\"1\":{\"225\":1}}],[\"它会根据网络的拥塞程度动态变化的\",{\"1\":{\"215\":1}}],[\"它会把数据包转发出去\",{\"1\":{\"139\":1}}],[\"它能确保接收端接收的网络包是无损坏\",{\"1\":{\"202\":1}}],[\"它能够让网络应用程序主动发现自己位于\",{\"1\":{\"138\":1}}],[\"它替代了\",{\"1\":{\"197\":1}}],[\"它里面放的都是已经建立完成的连接\",{\"1\":{\"183\":1}}],[\"它考虑了底层网络链路的mtu\",{\"1\":{\"158\":1}}],[\"它在收到软中断后就会立马去链表里把消息取出\",{\"1\":{\"147\":1}}],[\"它在自己的帧会携带\",{\"1\":{\"114\":1,\"280\":1}}],[\"它都会增加一个\",{\"1\":{\"143\":1}}],[\"它已经明确地知道\",{\"1\":{\"138\":1}}],[\"它本身并不是一个具体的协议\",{\"1\":{\"132\":1}}],[\"它的下一层就是\",{\"1\":{\"295\":1}}],[\"它的网络效率也是很低的\",{\"1\":{\"262\":1}}],[\"它的\",{\"1\":{\"158\":1,\"205\":1}}],[\"它的功能比较简单\",{\"1\":{\"145\":1}}],[\"它的工作原理如下\",{\"1\":{\"143\":1}}],[\"它的工作方式是向\",{\"1\":{\"121\":1}}],[\"它的原理就是利用\",{\"1\":{\"143\":1}}],[\"它的作用是用来标识该\",{\"1\":{\"105\":1}}],[\"它具有类似\",{\"1\":{\"112\":1}}],[\"它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范\",{\"1\":{\"86\":1}}],[\"它并没有存储到\",{\"1\":{\"82\":1}}],[\"它就可以包含了这个二进制小数的所有信息\",{\"1\":{\"82\":1}}],[\"它采用的是乘\",{\"1\":{\"81\":1}}],[\"它与优先级\",{\"1\":{\"62\":1}}],[\"它被称为是主线程\",{\"1\":{\"58\":1}}],[\"它是严格递增的\",{\"1\":{\"275\":1}}],[\"它是通过通信双方的ip地址端口\",{\"1\":{\"184\":1}}],[\"它是已知\",{\"1\":{\"136\":1}}],[\"它是用来标记对应的\",{\"1\":{\"49\":1}}],[\"它是以一小块一小块读取数据的\",{\"1\":{\"49\":1}}],[\"它表示\",{\"1\":{\"49\":1}}],[\"它们都用来表示资源在客户端缓存的有效期\",{\"1\":{\"93\":1}}],[\"它们的结构如下\",{\"1\":{\"82\":1}}],[\"它们的作用如下\",{\"1\":{\"59\":1}}],[\"它们对应到内核里都是\",{\"1\":{\"58\":1}}],[\"它们虽然看起来毫无作用\",{\"1\":{\"57\":1}}],[\"它们同时从内存中读取两个不同的数据\",{\"1\":{\"56\":1}}],[\"它们之间的层级关系\",{\"1\":{\"49\":1}}],[\"它们通常不与用户直接交互\",{\"1\":{\"20\":1}}],[\"它通常用于提供第三方访问http服务\",{\"1\":{\"43\":1}}],[\"它允许第三方应用程序在资源所有者的许可下访问资源所有者的资源\",{\"1\":{\"43\":1}}],[\"它基于\",{\"1\":{\"41\":1}}],[\"它发送数据的能力会呈指数形式增长\",{\"1\":{\"28\":1}}],[\"慢启动以及\",{\"1\":{\"106\":1}}],[\"慢启动过程给流量带来的影响\",{\"1\":{\"100\":1}}],[\"慢启动门限等于当前拥塞窗口\",{\"1\":{\"28\":1}}],[\"慢启动门限变成拥塞窗口\",{\"1\":{\"28\":1}}],[\"慢启动\",{\"0\":{\"216\":1},\"1\":{\"28\":1}}],[\"8888\",{\"1\":{\"188\":2}}],[\"8\",{\"0\":{\"28\":1,\"308\":1},\"1\":{\"49\":2,\"57\":2,\"74\":2,\"75\":2,\"81\":1,\"82\":5,\"83\":1,\"105\":1,\"142\":3,\"145\":1,\"151\":1,\"174\":1,\"243\":1}}],[\"接受窗口的左侧边界取决于最大偏移数\",{\"1\":{\"278\":1}}],[\"接触不良\",{\"1\":{\"213\":1}}],[\"接收窗口大小之和\",{\"1\":{\"278\":1}}],[\"接收窗口和发送窗口的大小是相等的吗\",{\"0\":{\"226\":1}}],[\"接收方可以根据数据包的序列号按序接收\",{\"1\":{\"239\":1}}],[\"接收方可以去除重复的数据\",{\"1\":{\"239\":1}}],[\"接收方可以通告一个小的窗口\",{\"1\":{\"230\":1}}],[\"接收方得满足\",{\"1\":{\"230\":1}}],[\"接收方处理完数据会发送一个窗口大小非0的ack报文\",{\"1\":{\"229\":1}}],[\"接收方\",{\"1\":{\"227\":1}}],[\"接收方的滑动窗口\",{\"0\":{\"225\":1}}],[\"接收方没有空间\",{\"1\":{\"223\":1}}],[\"接收方还有空间\",{\"1\":{\"223\":1}}],[\"接收方会发送一个确认报文\",{\"1\":{\"221\":1}}],[\"接收缓冲区丢包\",{\"1\":{\"213\":1}}],[\"接收到一个\",{\"1\":{\"177\":1}}],[\"接收放在接收完数据之后将其放到缓冲区\",{\"1\":{\"27\":1}}],[\"接下来需要通过\",{\"1\":{\"307\":1}}],[\"接下来将\",{\"1\":{\"143\":1}}],[\"接下来我们就把这个数据结构统称为任务\",{\"1\":{\"58\":1}}],[\"接下来\",{\"1\":{\"57\":1,\"223\":1,\"306\":1}}],[\"接着再传给传输层\",{\"1\":{\"174\":1}}],[\"接着返回\",{\"1\":{\"143\":1}}],[\"接着会通过硬件中断通知内核有新的数据到了\",{\"1\":{\"72\":1}}],[\"接着将数据写入到这个\",{\"1\":{\"66\":1}}],[\"接着\",{\"1\":{\"56\":1,\"72\":1,\"136\":1,\"179\":1,\"249\":1}}],[\"接管\",{\"1\":{\"20\":1}}],[\"滑动窗口是无法往前移动的\",{\"1\":{\"277\":1}}],[\"滑动窗口是如何影像传输速度的\",{\"1\":{\"198\":1}}],[\"滑动窗口才能往前滑动\",{\"1\":{\"277\":1}}],[\"滑动窗口\",{\"0\":{\"27\":1,\"221\":1},\"1\":{\"277\":1}}],[\"7~8\",{\"1\":{\"82\":1}}],[\"7\",{\"0\":{\"27\":1,\"193\":1,\"307\":1},\"1\":{\"49\":2,\"57\":4,\"82\":1,\"174\":1}}],[\"我这里假定\",{\"1\":{\"218\":1}}],[\"我方调用\",{\"1\":{\"167\":1}}],[\"我小区家也可以叫\",{\"1\":{\"156\":1}}],[\"我的ip地址应该是什么\",{\"1\":{\"136\":1}}],[\"我的\",{\"1\":{\"136\":1}}],[\"我还是以前面的\",{\"1\":{\"68\":1}}],[\"我们需要根据路由表的网关列判断对方的地址\",{\"1\":{\"307\":1}}],[\"我们电脑或手机使用的应用软件都是在应用层实现\",{\"1\":{\"285\":1}}],[\"我们尽量不要发送一个大于\",{\"1\":{\"158\":1}}],[\"我们最常见数据链路是以太网\",{\"1\":{\"158\":1}}],[\"我们启动服务器的时候\",{\"1\":{\"148\":1}}],[\"我们在\",{\"1\":{\"83\":1}}],[\"我们把下图这个\",{\"1\":{\"82\":1}}],[\"我们计算出\",{\"1\":{\"82\":1}}],[\"我们就以\",{\"1\":{\"82\":1}}],[\"我们就可以回答前面提到的\",{\"1\":{\"80\":1}}],[\"我们就要把这个\",{\"1\":{\"66\":1}}],[\"我们以\",{\"1\":{\"80\":1}}],[\"我们的程序和数据都是存储在内存\",{\"1\":{\"74\":1}}],[\"我们举个具体的例子来看看这四个状态的转换\",{\"1\":{\"69\":1}}],[\"我们要保证\",{\"1\":{\"67\":1}}],[\"我们\",{\"1\":{\"66\":1}}],[\"我们平日里遇到的基本都是普通任务\",{\"1\":{\"60\":1}}],[\"我们都知道\",{\"1\":{\"57\":1}}],[\"我们再来看一个应用层面的规避方案\",{\"1\":{\"57\":1}}],[\"我们可以伪造一个四元组相同的\",{\"1\":{\"250\":1}}],[\"我们可以减少重传的上限\",{\"1\":{\"169\":1}}],[\"我们可以调大这个队列的最大值\",{\"1\":{\"169\":1}}],[\"我们可以通过查看\",{\"1\":{\"72\":1}}],[\"我们可以在启动任务的时候\",{\"1\":{\"62\":1}}],[\"我们可以使用上面介绍的宏定义\",{\"1\":{\"57\":1}}],[\"我们可以看到\",{\"1\":{\"57\":1}}],[\"我们可以用这个组标记来区分不同的内存块\",{\"1\":{\"49\":1}}],[\"我们可以自定义一个消息结构\",{\"1\":{\"26\":1}}],[\"我是flipped\",{\"1\":{\"2\":1}}],[\"将信号发送到对应端口\",{\"1\":{\"306\":1}}],[\"将其复制到网卡的缓存区\",{\"1\":{\"305\":1}}],[\"将子网掩码取反之后\",{\"1\":{\"289\":1}}],[\"将子网掩码和\",{\"1\":{\"155\":1}}],[\"将ip地址与子网掩码进行按位与可以得到网络号\",{\"1\":{\"289\":1}}],[\"将ip地址分成两部分\",{\"1\":{\"289\":1}}],[\"将传输层传来的数据再加上ip包头组转成ip报文\",{\"1\":{\"288\":1}}],[\"将tcp的拥塞控制算法搬过来\",{\"1\":{\"279\":1}}],[\"将窗口向右移动当前已读取的数据字节数\",{\"1\":{\"278\":1}}],[\"将会延迟一段时间\",{\"1\":{\"262\":1}}],[\"将会受到影响\",{\"1\":{\"261\":1}}],[\"将被立即发送出去\",{\"1\":{\"197\":1}}],[\"将接受的syn报文\",{\"1\":{\"169\":1}}],[\"将接收到数据的信息放到ack包的这个字段\",{\"1\":{\"24\":1}}],[\"将已连接的\",{\"1\":{\"167\":1}}],[\"将服务端的半连接队列占满\",{\"1\":{\"169\":1}}],[\"将服务端\",{\"1\":{\"167\":1}}],[\"将数据转发给\",{\"1\":{\"153\":1}}],[\"将不会再向这个网段转发该组播地址的数据包\",{\"1\":{\"139\":1}}],[\"将重定向的工作交给代理服务器\",{\"1\":{\"98\":1}}],[\"将十进制中的小数部分乘以\",{\"1\":{\"81\":1}}],[\"将要操作的内存地址\",{\"1\":{\"76\":1}}],[\"将中断过程分成了两个阶段\",{\"1\":{\"72\":1}}],[\"将\",{\"1\":{\"57\":1,\"143\":2,\"162\":1,\"176\":1}}],[\"将可以有效的利用\",{\"1\":{\"51\":1}}],[\"将请求分发给多个工作节点并行处理\",{\"1\":{\"47\":1}}],[\"将经常访问的用户信息存储在缓存中\",{\"1\":{\"47\":1}}],[\"将用户数据和登录状态分布在多个服务器上\",{\"1\":{\"47\":1}}],[\"将路径设置为根路径\",{\"1\":{\"46\":1}}],[\"将向第三方应用程序颁发一个访问令牌\",{\"1\":{\"45\":1}}],[\"将拥塞窗口减半\",{\"1\":{\"28\":1}}],[\"将每个包的长度固定\",{\"1\":{\"26\":1}}],[\"所有的\",{\"1\":{\"138\":1}}],[\"所谓的单向流只有一端可以发送消息\",{\"1\":{\"116\":1}}],[\"所谓的补码就是把正数的二进制全部取反再加\",{\"1\":{\"80\":1}}],[\"所谓字节流就是一串没有边界的二进制数据\",{\"1\":{\"26\":1}}],[\"所需的材料成本必然也是更高\",{\"1\":{\"78\":1}}],[\"所需要的一个数据片段\",{\"1\":{\"49\":1}}],[\"所在的内存地址\",{\"1\":{\"75\":1}}],[\"所在的路径\",{\"1\":{\"46\":1}}],[\"所要操作的数据在\",{\"1\":{\"50\":1}}],[\"所以域名的层级关系类似一个树状结构\",{\"1\":{\"295\":1}}],[\"所以每个\",{\"1\":{\"278\":1}}],[\"所以就衍生出了\",{\"1\":{\"262\":1}}],[\"所以客户端的内核会回\",{\"1\":{\"261\":1}}],[\"所以fin\",{\"1\":{\"257\":1}}],[\"所以接收窗口和发送窗口是约等于的关系\",{\"1\":{\"226\":1}}],[\"所以接收端可以通过\",{\"1\":{\"106\":1}}],[\"所以也不存在上面提到的丢包情况\",{\"1\":{\"213\":1}}],[\"所以连接会进入一种叫做\",{\"1\":{\"197\":1}}],[\"所以在服务端开启这个参数是没有效果的\",{\"1\":{\"193\":1}}],[\"所以在计算虚拟运行时间\",{\"1\":{\"60\":1}}],[\"所以如果客户端已使用端口\",{\"1\":{\"191\":1}}],[\"所以如果传输过程中数据包丢了\",{\"1\":{\"185\":1}}],[\"所以直接从队列头取就行了\",{\"1\":{\"183\":1}}],[\"所以现在通常认为\",{\"1\":{\"177\":1}}],[\"所以这可能是\",{\"1\":{\"159\":1}}],[\"所以这两个数据会被同时读入到了两个\",{\"1\":{\"56\":1}}],[\"所以不但要我们电脑\",{\"1\":{\"159\":1}}],[\"所以不可用于主机\",{\"1\":{\"154\":1}}],[\"所以不会到达\",{\"1\":{\"153\":1}}],[\"所以不管怎么缩小\",{\"1\":{\"62\":1}}],[\"所以我们常说\",{\"1\":{\"261\":1}}],[\"所以我们要知道\",{\"1\":{\"143\":1}}],[\"所以我们还要知道\",{\"1\":{\"136\":1}}],[\"所以使用的是\",{\"1\":{\"137\":1}}],[\"所以可以通过\",{\"1\":{\"136\":1}}],[\"所以对于有的公网地址\",{\"1\":{\"143\":1}}],[\"所以对\",{\"1\":{\"130\":1}}],[\"所以建议使用\",{\"1\":{\"93\":1}}],[\"所以计算机里只能采用近似数的方式来保存\",{\"1\":{\"83\":1}}],[\"所以为了减少不必要的麻烦\",{\"1\":{\"82\":1}}],[\"所以为了性能考虑\",{\"1\":{\"80\":1}}],[\"所以最终尾数位存储的数字是\",{\"1\":{\"82\":1}}],[\"所以所以它们的精度在十进制中分别是\",{\"1\":{\"82\":1}}],[\"所以通常将\",{\"1\":{\"82\":1}}],[\"所以是没办法用二进制精确的表示\",{\"1\":{\"81\":1}}],[\"所以中断处理程序要短且快\",{\"1\":{\"71\":1}}],[\"所以中断请求的响应程序\",{\"1\":{\"71\":1}}],[\"所以会把数据返回给\",{\"1\":{\"69\":1}}],[\"所以会选择将这个数据包之后的所有数据包全部重传一遍\",{\"1\":{\"24\":1}}],[\"所以当我们要更新\",{\"1\":{\"69\":1}}],[\"所以无论怎么加载\",{\"1\":{\"57\":1}}],[\"所以要先把\",{\"1\":{\"56\":1}}],[\"所以先需要通过总线发送消息给\",{\"1\":{\"56\":1}}],[\"所以\",{\"1\":{\"56\":2,\"57\":3,\"58\":2,\"62\":1,\"67\":1,\"69\":1,\"72\":1,\"75\":1,\"78\":1,\"82\":1,\"121\":1,\"137\":1,\"143\":1,\"156\":1,\"162\":1,\"242\":1}}],[\"所以常用在对数据实时性要求较高\",{\"1\":{\"21\":1}}],[\"所以一般适用于上传下载\",{\"1\":{\"21\":1}}],[\"60\",{\"1\":{\"166\":1,\"229\":1}}],[\"666\",{\"1\":{\"156\":2}}],[\"68\",{\"1\":{\"137\":1}}],[\"67\",{\"1\":{\"137\":1}}],[\"625\",{\"1\":{\"81\":2,\"82\":2}}],[\"64992\",{\"1\":{\"191\":2}}],[\"64\",{\"1\":{\"56\":1,\"57\":2,\"75\":3,\"82\":1,\"162\":2}}],[\"6\",{\"0\":{\"26\":1,\"107\":1,\"306\":1},\"1\":{\"100\":1,\"174\":1}}],[\"以下两个属于广播地址\",{\"1\":{\"306\":1}}],[\"以下是一个可能的设计方案\",{\"1\":{\"47\":1}}],[\"以方便辨识数据包应该传输给哪一个应用\",{\"1\":{\"287\":1}}],[\"以等待是否有响应数据可以一起发送\",{\"1\":{\"262\":1}}],[\"以应对更多的连接请求\",{\"1\":{\"170\":1}}],[\"以应对大规模用户的访问\",{\"1\":{\"47\":1}}],[\"以避免ip层的分片\",{\"1\":{\"158\":1}}],[\"以太网的设计本身就是将包发送到整个网络\",{\"1\":{\"306\":1}}],[\"以太网的\",{\"1\":{\"158\":1}}],[\"以太网的数据链路上的\",{\"1\":{\"143\":1}}],[\"以外的其他链路上\",{\"1\":{\"153\":1}}],[\"以此来定位一个合适的\",{\"1\":{\"143\":1}}],[\"以至于每台设备都可以配置一个公有\",{\"1\":{\"138\":1}}],[\"以便能到达目标主机\",{\"1\":{\"143\":1}}],[\"以便确认该网络是否还有\",{\"1\":{\"139\":1}}],[\"以便下次直接从缓存中找到对应\",{\"1\":{\"136\":1}}],[\"以便其他请求复用\",{\"1\":{\"88\":1}}],[\"以一个大资源的请求替换多个小资源的请求\",{\"1\":{\"98\":1}}],[\"以\",{\"1\":{\"62\":1,\"81\":1,\"139\":2}}],[\"以保证每个任务的公平性\",{\"1\":{\"60\":1}}],[\"以保证相同优先级任务的公平性\",{\"1\":{\"59\":1}}],[\"以保障数据的安全传输\",{\"1\":{\"47\":1}}],[\"以如果\",{\"1\":{\"50\":1}}],[\"以适应不断增长的用户体量和变化的需求\",{\"1\":{\"47\":1}}],[\"以防止对连接的重放攻击和其他形式的网络攻击\",{\"1\":{\"246\":1}}],[\"以防止暴力破解和恶意攻击\",{\"1\":{\"47\":1}}],[\"以防止数据丢失和系统故障导致的服务中断\",{\"1\":{\"47\":1}}],[\"以提高查询性能和扩展性\",{\"1\":{\"47\":1}}],[\"以确保数据能够在不同网络间传输\",{\"1\":{\"283\":1}}],[\"以确保数据的完整性和正确性\",{\"1\":{\"221\":1}}],[\"以确保数据的有序性\",{\"1\":{\"25\":1}}],[\"以确保报文已被自然消亡\",{\"1\":{\"162\":1}}],[\"以确保不会在传输过程中发生ip层的分片\",{\"1\":{\"158\":1}}],[\"以确保服务的高可用性和可扩展性\",{\"1\":{\"47\":1}}],[\"以满足不同的应用场景\",{\"1\":{\"44\":1}}],[\"以及通过网卡传输网络帧等\",{\"1\":{\"283\":1}}],[\"以及相关的各种控制和错误处理方式\",{\"1\":{\"86\":1}}],[\"以及\",{\"1\":{\"72\":1,\"100\":1,\"209\":1,\"283\":1}}],[\"以及ack\",{\"1\":{\"33\":1,\"301\":1}}],[\"以及投票管理\",{\"1\":{\"10\":1}}],[\"55\",{\"1\":{\"246\":1}}],[\"56\",{\"1\":{\"148\":1}}],[\"53\",{\"1\":{\"82\":1}}],[\"52~56\",{\"1\":{\"223\":2}}],[\"52字节以后\",{\"1\":{\"223\":1}}],[\"52\",{\"1\":{\"82\":1}}],[\"500\",{\"1\":{\"75\":1}}],[\"50\",{\"1\":{\"52\":1}}],[\"5\",{\"0\":{\"25\":1,\"106\":1,\"304\":1,\"305\":1},\"1\":{\"83\":1,\"129\":1,\"169\":1,\"174\":1,\"223\":3}}],[\"用了tcp传输数据就一定不会丢包吗\",{\"0\":{\"213\":1}}],[\"用以区分\",{\"1\":{\"152\":1}}],[\"用以区分是哪个应用程序发\",{\"1\":{\"142\":1}}],[\"用当前时刻减去该数据包最初从源主机上发出的时刻\",{\"1\":{\"142\":1}}],[\"用的是广播\",{\"1\":{\"137\":1}}],[\"用来检查包传输过程是否有损坏\",{\"1\":{\"305\":1}}],[\"用来描述程序或进程执行时所处的不同权限级别或特权级别\",{\"1\":{\"286\":1}}],[\"用来标识\",{\"1\":{\"248\":1}}],[\"用来做流量控制\",{\"1\":{\"204\":1}}],[\"用来解决丢包的问题\",{\"1\":{\"248\":1}}],[\"用来解决丢包问题\",{\"1\":{\"201\":1}}],[\"用来解决乱序问题等\",{\"1\":{\"204\":1}}],[\"用来解决网络包乱序问题\",{\"1\":{\"201\":1,\"248\":1}}],[\"用来供客户端校验\",{\"1\":{\"129\":2}}],[\"用来供服务端校验\",{\"1\":{\"129\":2}}],[\"用来指定服务器的域名\",{\"1\":{\"88\":1}}],[\"用来存放当前正在执行的指令\",{\"1\":{\"75\":1}}],[\"用来存放需要进行运算的数据\",{\"1\":{\"75\":1}}],[\"用来存储\",{\"1\":{\"75\":1}}],[\"用\",{\"1\":{\"82\":1,\"101\":1,\"137\":1}}],[\"用补码表示的负数在运算\",{\"1\":{\"80\":1}}],[\"用补码的形式保存负数\",{\"0\":{\"80\":1}}],[\"用于两点之间的传输\",{\"1\":{\"304\":1}}],[\"用于标识客户端到服务器的数据流\",{\"1\":{\"299\":1}}],[\"用于标识数据\",{\"1\":{\"276\":1}}],[\"用于根据\",{\"1\":{\"297\":1}}],[\"用于告知网络包传送过程中产生的错误以及各种控制信息\",{\"1\":{\"297\":1}}],[\"用于区分不同的http信息\",{\"1\":{\"276\":1}}],[\"用于每次建立tcp的链接\",{\"1\":{\"246\":1}}],[\"用于对tcp连接上发送的每一个数据包进行编号0\",{\"1\":{\"246\":1}}],[\"用于保证可靠性和流量控制维护的某些状态信息\",{\"1\":{\"204\":1}}],[\"用于通信最近的节点\",{\"1\":{\"159\":1}}],[\"用于通知发送方哪些数据被重复接收了\",{\"1\":{\"24\":1}}],[\"用于一对多的通信\",{\"1\":{\"159\":1}}],[\"用于一对一的通信\",{\"1\":{\"159\":1}}],[\"用于将包发送给特定组内的所有主机\",{\"1\":{\"154\":1}}],[\"用于将一个字典\",{\"1\":{\"116\":1}}],[\"用于广播\",{\"1\":{\"153\":1}}],[\"用于响应对方\",{\"1\":{\"116\":1}}],[\"用于携带简单的控制信息\",{\"1\":{\"105\":1}}],[\"用于发送和接收信号\",{\"1\":{\"76\":1}}],[\"用于读写内存的数据\",{\"1\":{\"76\":1}}],[\"用于指定\",{\"1\":{\"76\":1}}],[\"用于描述在此\",{\"1\":{\"61\":1}}],[\"用于访问自身资源或服务端间的交互\",{\"1\":{\"44\":1}}],[\"用户态和内核态是操作系统中的两种运行模式\",{\"1\":{\"286\":1}}],[\"用户态和内核态\",{\"0\":{\"286\":1}}],[\"用户态\",{\"1\":{\"252\":1}}],[\"用户级\",{\"1\":{\"205\":1}}],[\"用户消息通过\",{\"1\":{\"203\":1}}],[\"用户点击继续访问或者被恶意导入伪造的根证书\",{\"1\":{\"130\":1}}],[\"用户在第三方应用程序中进行操作\",{\"1\":{\"45\":1}}],[\"用户在微信客户端上看到授权请求\",{\"1\":{\"45\":1}}],[\"用户使用微信扫描该二维码\",{\"1\":{\"45\":1}}],[\"用户扫码是如何实现的\",{\"0\":{\"45\":1}}],[\"用户直接向客户端提供用户名和密码\",{\"1\":{\"44\":1}}],[\"用户登录\",{\"0\":{\"20\":1,\"42\":1}}],[\"这属于\",{\"1\":{\"277\":1}}],[\"这并不合适吧\",{\"1\":{\"213\":1}}],[\"这类丢包问题怎么解决\",{\"1\":{\"213\":1}}],[\"这会使得服务端发出一个\",{\"1\":{\"179\":1}}],[\"这其实是相当于至少允许报文丢失一次\",{\"1\":{\"162\":1}}],[\"这将大大提高了路由器转发的速度\",{\"1\":{\"160\":1}}],[\"这可分配的地址数量是大的惊人\",{\"1\":{\"159\":1}}],[\"这是不能可能的\",{\"1\":{\"198\":1}}],[\"这是一种新情况\",{\"1\":{\"197\":1}}],[\"这是个内核线程\",{\"1\":{\"147\":1}}],[\"这是个\",{\"1\":{\"145\":1}}],[\"这是因为\",{\"1\":{\"82\":1,\"188\":1}}],[\"这是因为此时是要判断数据即将写入到\",{\"1\":{\"66\":1}}],[\"这是因为排序之后\",{\"1\":{\"52\":1}}],[\"这点没啥疑问\",{\"1\":{\"134\":1}}],[\"这一项同时把之前所有内容的发生的数据做个摘要\",{\"1\":{\"129\":2}}],[\"这一项同时\",{\"1\":{\"129\":2}}],[\"这不利于移动设备切换网络的场景\",{\"1\":{\"111\":1}}],[\"这无疑浪费大量了带宽和服务器资源\",{\"1\":{\"100\":1}}],[\"这无疑会加重总线的负载\",{\"1\":{\"68\":1}}],[\"这些信息的组合\",{\"1\":{\"204\":1}}],[\"这些连接正等待被取走\",{\"1\":{\"183\":1}}],[\"这些端口都是通常认为不会被使用\",{\"1\":{\"143\":1}}],[\"这些都是很耗时的\",{\"1\":{\"106\":1}}],[\"这些有效位是包含整数部分和小数部分\",{\"1\":{\"82\":1}}],[\"这些孤儿进程会被\",{\"1\":{\"20\":1}}],[\"这三个重要部分的意义如下\",{\"1\":{\"82\":1}}],[\"这就是糊涂窗口综合症\",{\"1\":{\"230\":1}}],[\"这就是窗口关闭\",{\"1\":{\"229\":1}}],[\"这就是所谓的流量控制\",{\"1\":{\"227\":1}}],[\"这就是常被称为\",{\"1\":{\"197\":1}}],[\"这就意味着服务端需要处理这种异常情况\",{\"1\":{\"179\":1}}],[\"这就使得\",{\"1\":{\"155\":1}}],[\"这就减少了握手带来的\",{\"1\":{\"123\":1}}],[\"这就非常不好了\",{\"1\":{\"80\":1}}],[\"这就我们今天所说的存储器层次结构\",{\"1\":{\"78\":1}}],[\"这里多了两个字段\",{\"1\":{\"142\":1}}],[\"这里的\",{\"1\":{\"75\":1}}],[\"这里两个修改\",{\"1\":{\"67\":1}}],[\"这时就会立刻发送\",{\"1\":{\"262\":1}}],[\"这时就不会经历完成的\",{\"1\":{\"261\":1}}],[\"这时就需要用到控制总线了\",{\"1\":{\"77\":1}}],[\"这时候我们需要针对具体的代码一步一步的进行排查和定位\",{\"1\":{\"167\":1}}],[\"这时服务端在发完\",{\"1\":{\"166\":1}}],[\"这时客户端还要再发起获取\",{\"1\":{\"107\":1}}],[\"这时也需要控制总线\",{\"1\":{\"76\":1}}],[\"这时我们就可以分析是哪种软中断类型导致的\",{\"1\":{\"72\":1}}],[\"这时如果\",{\"1\":{\"67\":1}}],[\"这在一定程度上减少了总线带宽压力\",{\"1\":{\"69\":1}}],[\"这四个状态来标记\",{\"1\":{\"69\":1}}],[\"这意味着多个\",{\"1\":{\"277\":1}}],[\"这意味着无法根据序列号来判断新老数据\",{\"1\":{\"163\":1,\"246\":1}}],[\"这意味着如果\",{\"1\":{\"111\":1}}],[\"这意味着\",{\"1\":{\"61\":1,\"71\":1}}],[\"这几种调度类是有优先级的\",{\"1\":{\"61\":1}}],[\"这整个\",{\"1\":{\"57\":1}}],[\"这\",{\"1\":{\"57\":1,\"67\":1,\"223\":1}}],[\"这种通过构造大量ack包去消耗服务端资源的攻击\",{\"1\":{\"185\":1}}],[\"这种操作只能在源与目标主机\",{\"1\":{\"160\":1}}],[\"这种方式叫\",{\"1\":{\"122\":1}}],[\"这种方法称为写直达\",{\"1\":{\"65\":1}}],[\"这种方法可以绕过浏览器的同源策略限制\",{\"1\":{\"46\":1}}],[\"这种标准形式如下图\",{\"1\":{\"82\":1}}],[\"这种二进制数\",{\"1\":{\"82\":1}}],[\"这种负数的表示方式是不能用常规的加法来计算了\",{\"1\":{\"80\":1}}],[\"这种一般可以认为系统的开销被软中断占据了\",{\"1\":{\"72\":1}}],[\"这种情况是不用把数据写到内存里的\",{\"1\":{\"66\":1}}],[\"这种情况下\",{\"1\":{\"64\":1}}],[\"这种因为多个线程同时读写同一个\",{\"1\":{\"56\":1}}],[\"这两个传输协议会接受应用层的委托执行收发数据的操作下面一半是用\",{\"1\":{\"297\":1}}],[\"这两个情况都有个共同点\",{\"1\":{\"181\":1}}],[\"这两个特殊的单向流是用来同步双方的动态表\",{\"1\":{\"116\":1}}],[\"这两个单向流的用法\",{\"1\":{\"116\":1}}],[\"这两个方式都是为了解决\",{\"1\":{\"88\":1}}],[\"这两个东西\",{\"1\":{\"82\":1}}],[\"这两个调度类的调度策略合起来共有这三种\",{\"1\":{\"59\":1}}],[\"这两个调度类\",{\"1\":{\"59\":1}}],[\"这两个步骤\",{\"1\":{\"56\":2}}],[\"这两个\",{\"1\":{\"56\":1}}],[\"这对\",{\"1\":{\"53\":1}}],[\"这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据\",{\"1\":{\"222\":1}}],[\"这个方向\",{\"1\":{\"197\":2}}],[\"这个内核参数\",{\"1\":{\"193\":1}}],[\"这个问题也可以由\",{\"1\":{\"188\":1}}],[\"这个过程操作系统是可以感知的到的\",{\"1\":{\"270\":1}}],[\"这个过程算法复杂度为o\",{\"1\":{\"183\":1}}],[\"这个过程中\",{\"1\":{\"129\":1}}],[\"这个全局\",{\"1\":{\"181\":1}}],[\"这个链表\",{\"1\":{\"147\":1}}],[\"这个包中包含了想要知道的\",{\"1\":{\"136\":1}}],[\"这个目的是为了保证消息不会被冒充\",{\"1\":{\"128\":1}}],[\"这个数的小数点右侧的数字就是\",{\"1\":{\"82\":1}}],[\"这个后面会说\",{\"1\":{\"82\":1}}],[\"这个二进制数\",{\"1\":{\"82\":1}}],[\"这个事件的处理也是会分成上半部和下半部\",{\"1\":{\"72\":1}}],[\"这个协议就做到了\",{\"1\":{\"68\":1}}],[\"这个协议就是\",{\"1\":{\"68\":1}}],[\"这个称为事务的串行化\",{\"1\":{\"67\":1}}],[\"这个称为写传播\",{\"1\":{\"67\":1}}],[\"这个就是所谓的缓存一致性问题\",{\"1\":{\"67\":1}}],[\"这个时候\",{\"1\":{\"69\":2,\"218\":1}}],[\"这个时候数据其实没有被同步到内存中的\",{\"1\":{\"67\":1}}],[\"这个时候在tcp报文段中\",{\"1\":{\"25\":1}}],[\"这个脏的标记代表这个时候\",{\"1\":{\"66\":1}}],[\"这个范围是提供给普通任务用的\",{\"1\":{\"62\":1}}],[\"这个算法的理念是想让分配给每个任务的\",{\"1\":{\"60\":1}}],[\"这个\",{\"1\":{\"56\":1,\"179\":1,\"250\":1}}],[\"这个两个数据的地址在物理内存上是连续的\",{\"1\":{\"56\":1}}],[\"这个组标记会记录当前\",{\"1\":{\"49\":1}}],[\"这样做是没什么问题的\",{\"1\":{\"306\":1}}],[\"这样做的好处\",{\"1\":{\"275\":1}}],[\"这样做的好处是可以减少ip层分片带来的性能损耗和数据报文丢失的风险\",{\"1\":{\"158\":1}}],[\"这样做的目的是为了路径mtu发现\",{\"1\":{\"143\":1}}],[\"这样在传输时如果丢了一小段\",{\"1\":{\"287\":1}}],[\"这样使得一个连接上的多个\",{\"1\":{\"277\":1}}],[\"这样发送方就可以知道哪些数据收到了\",{\"1\":{\"235\":1}}],[\"这样看来\",{\"1\":{\"198\":1}}],[\"这样全世界的人才能访问\",{\"1\":{\"156\":1}}],[\"这样才可以跳过三次握手\",{\"1\":{\"123\":1}}],[\"这样可以减少网络中多余的\",{\"1\":{\"139\":1}}],[\"这样可以减少对正常进程运行调度地影响\",{\"1\":{\"71\":1}}],[\"这样可以节约带宽\",{\"1\":{\"121\":1}}],[\"这样就出现了三次挥手\",{\"1\":{\"262\":1}}],[\"这样就不会造成资源浪费\",{\"1\":{\"239\":1}}],[\"这样就不像以前由\",{\"1\":{\"138\":1}}],[\"这样就可以避免了丢包情况\",{\"1\":{\"228\":1}}],[\"这样就可以节约\",{\"1\":{\"82\":1}}],[\"这样就会导致新连接无法建立\",{\"1\":{\"198\":1}}],[\"这样就无法一次完成计算\",{\"1\":{\"75\":1}}],[\"这样指数就不会出现负数了\",{\"1\":{\"82\":1}}],[\"这样的底层网络上发送原始数据包\",{\"1\":{\"291\":1}}],[\"这样的话接收窗口可以很快的就空缺出来\",{\"1\":{\"226\":1}}],[\"这样的过程\",{\"1\":{\"143\":1}}],[\"这样的过程就是事务的串行化\",{\"1\":{\"67\":1}}],[\"这样的好处是\",{\"1\":{\"66\":1}}],[\"这样的数据统称为一个字\",{\"1\":{\"49\":1}}],[\"这样便可以提高系统的性能\",{\"1\":{\"66\":1}}],[\"这样写操作将会花费大量的时间\",{\"1\":{\"65\":1}}],[\"这样性能可以得到非常可观的提升\",{\"1\":{\"53\":1}}],[\"这样命中率就会很高\",{\"1\":{\"52\":1}}],[\"这样我们代码的性能就会得到很大的提升\",{\"1\":{\"51\":1}}],[\"这样将会带来很大的性能提升\",{\"1\":{\"50\":1}}],[\"这样一小块一小块的数据\",{\"1\":{\"49\":1}}],[\"这样\",{\"1\":{\"46\":1,\"52\":1,\"57\":1}}],[\"这样如果出现数据丢失\",{\"1\":{\"24\":1}}],[\"这边以微信登陆为例\",{\"1\":{\"45\":1}}],[\"snd\",{\"1\":{\"224\":8}}],[\"snooping\",{\"1\":{\"68\":1}}],[\"slow\",{\"1\":{\"216\":1}}],[\"shutdown\",{\"1\":{\"261\":3}}],[\"shutdown函数是优雅的可以控制只关闭一个方向的连接\",{\"1\":{\"197\":1}}],[\"shut\",{\"1\":{\"197\":5}}],[\"shared\",{\"1\":{\"69\":1,\"122\":1}}],[\"sharing\",{\"1\":{\"56\":1}}],[\"syn=1\",{\"1\":{\"299\":2}}],[\"syn=1的sntcp报文\",{\"1\":{\"238\":1}}],[\"syn非法\",{\"0\":{\"266\":1}}],[\"syn合法\",{\"0\":{\"265\":1}}],[\"syn报文在什么情况下会被丢弃\",{\"0\":{\"210\":1}}],[\"syn攻击\",{\"1\":{\"209\":1}}],[\"syn超时可能会由于网络延迟\",{\"1\":{\"170\":1}}],[\"syn超时\",{\"1\":{\"170\":1}}],[\"syn+ack\",{\"1\":{\"169\":2,\"209\":1}}],[\"syncookies\",{\"1\":{\"169\":1,\"209\":2}}],[\"syn\",{\"1\":{\"169\":2,\"170\":1,\"177\":3,\"185\":1,\"196\":2,\"201\":2,\"209\":1,\"243\":1,\"244\":1,\"248\":4,\"250\":2,\"265\":2,\"266\":3,\"299\":2,\"300\":1}}],[\"syn队列\",{\"1\":{\"169\":1}}],[\"syn延时和泛洪攻击\",{\"0\":{\"168\":1}}],[\"so\",{\"1\":{\"188\":1,\"190\":2}}],[\"somaxconn\",{\"1\":{\"169\":1,\"177\":2,\"209\":1}}],[\"sock\",{\"1\":{\"146\":6,\"181\":1}}],[\"socket\",{\"1\":{\"146\":5,\"167\":4,\"176\":8,\"204\":2,\"261\":11,\"297\":1}}],[\"softirqs\",{\"1\":{\"72\":1}}],[\"spec\",{\"1\":{\"129\":4}}],[\"ssl\",{\"1\":{\"129\":1}}],[\"ssthresh\",{\"1\":{\"28\":2,\"216\":3,\"218\":4,\"219\":2}}],[\"sar\",{\"1\":{\"72\":1}}],[\"sack方法\",{\"0\":{\"235\":1}}],[\"sack\",{\"0\":{\"236\":1},\"1\":{\"24\":3,\"235\":1,\"236\":1}}],[\"scheduling\",{\"1\":{\"60\":1}}],[\"sched\",{\"1\":{\"59\":5}}],[\"start\",{\"1\":{\"216\":1}}],[\"starvation\",{\"1\":{\"20\":1}}],[\"static\",{\"1\":{\"129\":1}}],[\"status\",{\"1\":{\"121\":1}}],[\"stream类型的fream\",{\"1\":{\"276\":1}}],[\"stream\",{\"1\":{\"105\":2,\"106\":8,\"113\":1,\"116\":3,\"146\":2,\"276\":2,\"277\":4,\"278\":9}}],[\"struct\",{\"1\":{\"58\":6}}],[\"smp\",{\"1\":{\"57\":1}}],[\"seq\",{\"1\":{\"246\":1}}],[\"selective\",{\"1\":{\"235\":1}}],[\"sent优化\",{\"1\":{\"196\":1}}],[\"sent状态\",{\"1\":{\"31\":1,\"32\":1,\"238\":1,\"299\":1,\"300\":1}}],[\"send\",{\"1\":{\"224\":1}}],[\"sendto\",{\"1\":{\"148\":2}}],[\"sendmsg\",{\"1\":{\"146\":2}}],[\"severhello\",{\"1\":{\"129\":2}}],[\"session\",{\"1\":{\"122\":5}}],[\"serialization\",{\"1\":{\"67\":1}}],[\"server\",{\"1\":{\"43\":2,\"129\":8,\"295\":3}}],[\"几个\",{\"1\":{\"24\":1}}],[\"几个数据包丢失时\",{\"1\":{\"24\":1}}],[\"无缝\",{\"1\":{\"281\":1}}],[\"无间隔\",{\"1\":{\"202\":1}}],[\"无分类地址cidr\",{\"0\":{\"155\":1}}],[\"无队头阻塞\",{\"0\":{\"113\":1}}],[\"无损压缩\",{\"1\":{\"99\":1}}],[\"无法在发送数据\",{\"1\":{\"257\":1}}],[\"无法再接收和发送数据\",{\"1\":{\"257\":1}}],[\"无法关闭非活跃的tcp连接\",{\"1\":{\"251\":1}}],[\"无法验证通信方身份信息容易被假的网站冒充\",{\"1\":{\"95\":1}}],[\"无法精准定位是哪一个\",{\"1\":{\"24\":1}}],[\"无状态\",{\"1\":{\"95\":1}}],[\"无效\",{\"1\":{\"69\":2}}],[\"无疑性能会受到很大的影响\",{\"1\":{\"65\":1}}],[\"无论重启之后主机上是否还有这个进程的目标端口号\",{\"1\":{\"271\":1}}],[\"无论的网络链路中出现了怎样的链路变化\",{\"1\":{\"203\":1}}],[\"无论数据在不在\",{\"1\":{\"65\":1}}],[\"无论\",{\"1\":{\"49\":1}}],[\"无连接\",{\"1\":{\"21\":1}}],[\"重发很慢\",{\"1\":{\"233\":1}}],[\"重置为\",{\"1\":{\"218\":1}}],[\"重启后跟服务器稍微通信一下就知道少了哪条数据\",{\"1\":{\"213\":1}}],[\"重启\",{\"0\":{\"190\":1}}],[\"重启tcp服务\",{\"1\":{\"189\":1}}],[\"重新组装相关字段\",{\"1\":{\"160\":1}}],[\"重新握手\",{\"1\":{\"111\":1}}],[\"重新加载数据\",{\"1\":{\"49\":1}}],[\"重复\",{\"1\":{\"203\":1}}],[\"重复传输完全相同的\",{\"1\":{\"104\":1}}],[\"重复三次收到相同的ack包\",{\"1\":{\"24\":1}}],[\"重传的\",{\"1\":{\"275\":1}}],[\"重传次数\",{\"1\":{\"169\":1,\"209\":1}}],[\"重传丢失的报文\",{\"1\":{\"113\":1,\"234\":1}}],[\"重传丢失的数据包\",{\"1\":{\"28\":1,\"219\":1}}],[\"重传数据包\",{\"1\":{\"24\":1}}],[\"重传这个数据包\",{\"1\":{\"24\":1}}],[\"重传机制有哪些\",{\"0\":{\"24\":1}}],[\"46~51字节\",{\"1\":{\"223\":1}}],[\"48\",{\"1\":{\"205\":1}}],[\"40\",{\"1\":{\"159\":1,\"160\":1,\"262\":1}}],[\"4000\",{\"1\":{\"158\":1}}],[\"4352\",{\"1\":{\"158\":1}}],[\"4g\",{\"1\":{\"111\":1,\"246\":1}}],[\"4294967295\",{\"1\":{\"75\":1}}],[\"4\",{\"0\":{\"24\":1,\"38\":1,\"47\":1,\"105\":1,\"130\":1,\"190\":1,\"236\":1,\"298\":1,\"303\":1},\"1\":{\"24\":1,\"26\":1,\"28\":1,\"67\":2,\"69\":1,\"75\":1,\"83\":1,\"105\":1,\"129\":3,\"145\":1,\"151\":1,\"169\":1,\"174\":1,\"223\":1,\"224\":2,\"225\":2,\"243\":1,\"246\":2}}],[\"通信时\",{\"1\":{\"251\":1}}],[\"通信双方的主机之间就可以相互交换\",{\"1\":{\"201\":1}}],[\"通信\",{\"1\":{\"150\":1}}],[\"通信中如果某个\",{\"1\":{\"139\":1}}],[\"通信过程中\",{\"1\":{\"138\":1}}],[\"通信过程中使用对称加密\",{\"1\":{\"128\":1}}],[\"通信加密\",{\"1\":{\"127\":1}}],[\"通用寄存器\",{\"1\":{\"75\":1}}],[\"通知\",{\"1\":{\"56\":1}}],[\"通常包括物理链路和数据链路两个子层\",{\"1\":{\"283\":1}}],[\"通常都是代码的问题\",{\"1\":{\"167\":1}}],[\"通常都是耗时比较长的事情\",{\"1\":{\"72\":1}}],[\"通常是\",{\"1\":{\"139\":1,\"143\":1}}],[\"通常这需要架设一台\",{\"1\":{\"136\":1}}],[\"通常称为三次握手\",{\"1\":{\"298\":1}}],[\"通常称为\",{\"1\":{\"75\":1}}],[\"通常会分为\",{\"1\":{\"49\":1}}],[\"通常\",{\"1\":{\"46\":1,\"243\":1}}],[\"通常通过用户界面引导用户进行授权\",{\"1\":{\"43\":1}}],[\"通常在系统启动时启动\",{\"1\":{\"20\":1}}],[\"通过核对收到的包的接收方的mac地址判断是不是发送给自己的\",{\"1\":{\"306\":1}}],[\"通过网线发送出去\",{\"1\":{\"305\":1}}],[\"通过0806以太类型字段值发送arp请求来获取目标设备mac地址与0800以太类型字段值发送arp请求的方法类似\",{\"1\":{\"304\":1}}],[\"通过广播的形式从局域网中找到响应者的mac地址然后保存到apr缓存中\",{\"1\":{\"304\":1}}],[\"通过调用\",{\"1\":{\"297\":1}}],[\"通过dns获取到ip后\",{\"0\":{\"297\":1}}],[\"通过子网掩码\",{\"1\":{\"289\":1}}],[\"通过一个\",{\"1\":{\"143\":1}}],[\"通过协商的加密算法\",{\"1\":{\"129\":2}}],[\"通过连接\",{\"1\":{\"115\":1,\"281\":1}}],[\"通过缓存技术\",{\"1\":{\"97\":1}}],[\"通过服务端告知用户端是否可以使用缓e存的方式是协商缓存\",{\"1\":{\"94\":1}}],[\"通过\",{\"1\":{\"72\":1,\"88\":1,\"187\":2,\"239\":1,\"248\":1}}],[\"通过总线把这个事件广播通知给其他所有的核心\",{\"1\":{\"68\":1}}],[\"通过window字段告知对方本端的缓冲区大小\",{\"1\":{\"27\":1}}],[\"通过自定义协议\",{\"1\":{\"26\":1}}],[\"通过确认应答机制以及重传机制来保证数据传输的可靠\",{\"1\":{\"23\":1}}],[\"30\",{\"1\":{\"162\":2,\"229\":1}}],[\"304\",{\"1\":{\"97\":1}}],[\"33434\",{\"1\":{\"143\":1}}],[\"3同时开启的情况下\",{\"1\":{\"123\":1}}],[\"31\",{\"1\":{\"80\":1}}],[\"3154147351\",{\"1\":{\"1\":1}}],[\"32~36\",{\"1\":{\"223\":1}}],[\"32~45\",{\"1\":{\"223\":1}}],[\"32\",{\"1\":{\"49\":1,\"75\":4,\"80\":1,\"82\":1,\"145\":1,\"151\":2,\"155\":2,\"205\":1,\"246\":2}}],[\"3\",{\"0\":{\"23\":1,\"33\":1,\"37\":1,\"46\":1,\"99\":1,\"102\":1,\"111\":1,\"115\":1,\"116\":1,\"129\":1,\"235\":1,\"297\":1,\"301\":1},\"1\":{\"24\":1,\"26\":1,\"28\":4,\"62\":1,\"76\":1,\"80\":1,\"82\":6,\"98\":1,\"113\":2,\"114\":1,\"120\":1,\"122\":1,\"129\":5,\"133\":1,\"139\":2,\"158\":1,\"169\":1,\"170\":1,\"174\":1,\"219\":3,\"223\":1,\"224\":1,\"225\":1,\"229\":2,\"280\":1,\"291\":1}}],[\"在网络包传输的过程中\",{\"1\":{\"307\":1}}],[\"在网际层中\",{\"1\":{\"187\":1}}],[\"在完成接收之后\",{\"1\":{\"307\":1}}],[\"在末尾加上用于检测错误的帧校验序列\",{\"1\":{\"305\":1}}],[\"在其开头加上报头和起始帧分界符\",{\"1\":{\"305\":1}}],[\"在mac头里面要包含发送方mac地址和接收方mac地址\",{\"1\":{\"304\":1}}],[\"在生成ip包头之后\",{\"1\":{\"304\":1}}],[\"在客户端有多个网卡的时候\",{\"1\":{\"303\":1}}],[\"在ip包头的协议号要填写16进制的\",{\"1\":{\"303\":1}}],[\"在互联网上传数据时\",{\"1\":{\"297\":1}}],[\"在互联网通信\",{\"1\":{\"159\":1}}],[\"在委托操作系统发送消息时必须提供\",{\"0\":{\"294\":1}}],[\"在应用层把tcp的特性全部实现\",{\"1\":{\"287\":1}}],[\"在应用层下功夫\",{\"1\":{\"274\":1}}],[\"在加上服务端没有开启\",{\"1\":{\"270\":1}}],[\"在没有开启\",{\"1\":{\"270\":1}}],[\"在time\",{\"0\":{\"264\":1}}],[\"在tcp连接的建立阶段\",{\"1\":{\"170\":1}}],[\"在tcp连接建立完成之后\",{\"1\":{\"28\":1}}],[\"在tcp建立连接的时候\",{\"1\":{\"27\":1}}],[\"在tcp头部加一个sack字段在每次接收完数据之后\",{\"1\":{\"24\":1}}],[\"在建立连接时由内核生成的随机数作为其初始值\",{\"1\":{\"248\":1}}],[\"在建立连接时由计算机生成的随机数作为其初始值\",{\"1\":{\"201\":1}}],[\"在两次握手的情况下\",{\"1\":{\"239\":1}}],[\"在nat网络下使用不安全\",{\"1\":{\"210\":1}}],[\"在开启\",{\"1\":{\"210\":1}}],[\"在这种情况下根本不知道数据已经被丢弃了\",{\"1\":{\"197\":1}}],[\"在这个时间段内\",{\"1\":{\"268\":1}}],[\"在这个时候\",{\"1\":{\"69\":1}}],[\"在这个时候是不一致\",{\"1\":{\"67\":1}}],[\"在这个服务器上注册设备的\",{\"1\":{\"136\":1}}],[\"在调用\",{\"1\":{\"193\":1}}],[\"在数据链路层中\",{\"1\":{\"187\":1}}],[\"在内网里单播通信\",{\"1\":{\"159\":1}}],[\"在同一链路单播通信\",{\"1\":{\"159\":1}}],[\"在分片传输中\",{\"1\":{\"158\":1}}],[\"在主机和路由器上都会有各自的路由器控制表\",{\"1\":{\"157\":1}}],[\"在不同网络之间的广播叫做直接广播\",{\"1\":{\"153\":1}}],[\"在不同子域名之间共享\",{\"1\":{\"46\":1}}],[\"在本网络内广播的叫做本地广播\",{\"1\":{\"153\":1}}],[\"在进入内核态后最后也是调用的\",{\"1\":{\"146\":1}}],[\"在规定的时候间内\",{\"1\":{\"142\":1}}],[\"在选项数据中\",{\"1\":{\"142\":1}}],[\"在传输一个\",{\"1\":{\"136\":1}}],[\"在传输层有两种传输协议\",{\"1\":{\"287\":1}}],[\"在传输层中\",{\"1\":{\"187\":1}}],[\"在传输层\",{\"1\":{\"26\":1}}],[\"在实现上分为握手协议和记录协议两层\",{\"1\":{\"130\":1}}],[\"在实际存储指数的时候\",{\"1\":{\"82\":1}}],[\"在通信建立之前使用非对称加密\",{\"1\":{\"128\":1}}],[\"在特定的\",{\"1\":{\"123\":1}}],[\"在二进制中都无法精准表示时\",{\"1\":{\"83\":1}}],[\"在算指数的时候\",{\"1\":{\"82\":1}}],[\"在计算机数据存储中\",{\"1\":{\"74\":1}}],[\"在计算机中\",{\"1\":{\"71\":1}}],[\"在软中断上的使用率比较高\",{\"1\":{\"72\":1}}],[\"在写回机制中\",{\"1\":{\"66\":1}}],[\"在前面我们提到了\",{\"1\":{\"62\":1}}],[\"在物理内存地址上是连续的\",{\"1\":{\"57\":1}}],[\"在单核\",{\"1\":{\"53\":1}}],[\"在从\",{\"1\":{\"49\":1}}],[\"在对应的\",{\"1\":{\"49\":1}}],[\"在一般的tcp\",{\"1\":{\"304\":1}}],[\"在一个\",{\"1\":{\"49\":1}}],[\"在一端\",{\"1\":{\"24\":1}}],[\"在\",{\"0\":{\"267\":1},\"1\":{\"49\":2,\"56\":1,\"57\":1,\"58\":2,\"60\":2,\"69\":1,\"72\":1,\"93\":1,\"107\":1,\"129\":1,\"138\":1,\"139\":1,\"146\":1,\"150\":1,\"151\":1,\"166\":1,\"174\":1,\"181\":1,\"298\":1}}],[\"在整个网站的所有页面中可用\",{\"1\":{\"46\":1}}],[\"在example\",{\"1\":{\"46\":1}}],[\"在线文件存储等\",{\"1\":{\"43\":1}}],[\"在连接建立之后\",{\"1\":{\"27\":1}}],[\"在头部保存当前整个消息的长度\",{\"1\":{\"26\":1}}],[\"在发送之前\",{\"0\":{\"294\":1}}],[\"在发送数据时\",{\"1\":{\"233\":1}}],[\"在发送数据的同时\",{\"1\":{\"26\":1}}],[\"在发送\",{\"1\":{\"143\":1,\"157\":1}}],[\"在发送方接受到这些数据包的时候\",{\"1\":{\"25\":1}}],[\"在发送方\",{\"1\":{\"25\":1}}],[\"在当使用tcp协议时\",{\"1\":{\"26\":1}}],[\"在断开时使用四次握手\",{\"1\":{\"22\":1}}],[\"在大多数unix系统中是pid为1的特殊进程\",{\"1\":{\"20\":1}}],[\"254\",{\"1\":{\"153\":1}}],[\"255\",{\"1\":{\"137\":8,\"153\":2,\"306\":4}}],[\"224\",{\"1\":{\"139\":9}}],[\"229\",{\"1\":{\"138\":1}}],[\"22\",{\"1\":{\"82\":1}}],[\"24\",{\"1\":{\"82\":1,\"153\":5}}],[\"231\",{\"1\":{\"138\":1}}],[\"232\",{\"1\":{\"138\":1}}],[\"23\",{\"1\":{\"82\":3}}],[\"2^24\",{\"1\":{\"82\":1}}],[\"2^53\",{\"1\":{\"82\":1}}],[\"2^\",{\"1\":{\"82\":1}}],[\"2^3\",{\"1\":{\"82\":2}}],[\"200\",{\"1\":{\"67\":4}}],[\"200~300\",{\"1\":{\"49\":1}}],[\"20\",{\"1\":{\"62\":1,\"174\":1}}],[\"20～19\",{\"1\":{\"62\":1}}],[\"20~60\",{\"1\":{\"49\":1}}],[\"2024年5月29日\",{\"1\":{\"15\":1}}],[\"2025\",{\"1\":{\"12\":1}}],[\"2021\",{\"1\":{\"12\":1}}],[\"2~4\",{\"1\":{\"49\":1}}],[\"2msl足以让两个方向上的数据包都被丢弃\",{\"1\":{\"163\":2}}],[\"2msl时长\",{\"1\":{\"162\":1}}],[\"2msl\",{\"0\":{\"162\":1},\"1\":{\"38\":1,\"255\":1}}],[\"2状态变成time\",{\"1\":{\"263\":1}}],[\"2状态不能持续太久\",{\"1\":{\"257\":1}}],[\"2状态\",{\"1\":{\"36\":1,\"255\":1,\"257\":1}}],[\"2\",{\"0\":{\"22\":1,\"32\":1,\"36\":1,\"44\":1,\"45\":1,\"98\":1,\"101\":1,\"110\":1,\"112\":1,\"114\":1,\"127\":1,\"134\":1,\"188\":1,\"234\":1,\"294\":1,\"300\":1},\"1\":{\"24\":1,\"26\":1,\"28\":2,\"43\":4,\"44\":1,\"56\":10,\"67\":1,\"80\":2,\"81\":4,\"82\":2,\"83\":4,\"98\":1,\"101\":1,\"103\":3,\"105\":1,\"106\":1,\"107\":1,\"109\":1,\"121\":1,\"128\":1,\"129\":10,\"133\":1,\"139\":4,\"143\":2,\"169\":1,\"170\":1,\"174\":1,\"197\":1,\"205\":3,\"218\":2,\"223\":1,\"224\":1,\"230\":2,\"239\":1,\"243\":2,\"277\":1,\"289\":1,\"291\":1}}],[\"面向报文的\",{\"1\":{\"21\":1}}],[\"面向连接\",{\"1\":{\"21\":1,\"203\":1}}],[\"不核对收到的包的接收方的mac地址\",{\"1\":{\"306\":1}}],[\"不容易\",{\"1\":{\"287\":1}}],[\"不保证数据包是否能够抵达对方\",{\"1\":{\"287\":1}}],[\"不保证可靠交付数据\",{\"1\":{\"174\":1}}],[\"不然无法实现可靠传输\",{\"1\":{\"278\":1}}],[\"不再有发送数据的能力\",{\"1\":{\"261\":1}}],[\"不再有发送和接收数据的能力\",{\"1\":{\"261\":1}}],[\"不管是不是正常退出\",{\"1\":{\"260\":1}}],[\"不管哪一方禁用了\",{\"1\":{\"166\":1}}],[\"不一定\",{\"1\":{\"260\":1}}],[\"不宜频繁反复发送\",{\"1\":{\"233\":1}}],[\"不通告小窗口给发送方\",{\"1\":{\"230\":1}}],[\"不需要强制用户更新软件\",{\"1\":{\"213\":1}}],[\"不会因为把掉网线造成tcp断开\",{\"1\":{\"211\":1}}],[\"不重复\",{\"1\":{\"174\":1}}],[\"不丢失\",{\"1\":{\"174\":1}}],[\"不允许在中间路由器进行分片与重组\",{\"1\":{\"160\":1}}],[\"不经过路由器\",{\"1\":{\"159\":1}}],[\"不能像\",{\"1\":{\"203\":1}}],[\"不能相互兼容\",{\"1\":{\"159\":1}}],[\"不能两个小区都叫中山路\",{\"1\":{\"156\":1}}],[\"不能直接修改\",{\"1\":{\"69\":1}}],[\"不够安全\",{\"1\":{\"130\":1}}],[\"不具有前向安全性\",{\"1\":{\"129\":1}}],[\"不支持向前保密\",{\"1\":{\"129\":1}}],[\"不支持服务器推送消息\",{\"1\":{\"100\":1}}],[\"不仅可以减少时间\",{\"1\":{\"120\":1}}],[\"不同的实现可能会不一样\",{\"1\":{\"229\":1}}],[\"不同\",{\"1\":{\"106\":1}}],[\"不在静态编码表的范围内时\",{\"1\":{\"104\":1}}],[\"不幂等\",{\"1\":{\"91\":1}}],[\"不安全表现在\",{\"1\":{\"95\":1}}],[\"不安全\",{\"1\":{\"91\":1,\"95\":1}}],[\"不过\",{\"1\":{\"72\":1,\"136\":1,\"143\":1}}],[\"不可用\",{\"1\":{\"261\":2}}],[\"不可达消息的类型为\",{\"1\":{\"143\":1}}],[\"不可缓存\",{\"1\":{\"91\":1}}],[\"不可以读取该状态的数据\",{\"1\":{\"69\":1}}],[\"不可靠的\",{\"1\":{\"21\":1}}],[\"不和终端进行交互\",{\"1\":{\"59\":1}}],[\"不是有利的\",{\"1\":{\"53\":1}}],[\"不断改进系统架构和代码实现\",{\"1\":{\"47\":1}}],[\"不返回ack包\",{\"1\":{\"24\":1}}],[\"不给\",{\"1\":{\"1\":1}}],[\"邮件发送等场景\",{\"1\":{\"21\":1}}],[\"邮箱\",{\"1\":{\"1\":1}}],[\"网线质量差\",{\"1\":{\"213\":1}}],[\"网卡和交换机的区别\",{\"1\":{\"306\":1}}],[\"网卡驱动程序获取网络包\",{\"1\":{\"305\":1}}],[\"网卡\",{\"0\":{\"305\":1}}],[\"网卡性能不足\",{\"1\":{\"213\":1}}],[\"网卡丢包\",{\"1\":{\"213\":1}}],[\"网卡收到网络包后\",{\"1\":{\"72\":1}}],[\"网段中没有该组播组\",{\"1\":{\"139\":1}}],[\"网段中仍有该组播组\",{\"1\":{\"139\":1}}],[\"网络包经过交换机之后\",{\"1\":{\"307\":1}}],[\"网络包中的二进制数据\",{\"1\":{\"305\":1}}],[\"网络号\",{\"1\":{\"289\":1}}],[\"网络接口层\",{\"0\":{\"291\":1},\"1\":{\"283\":1}}],[\"网络模型\",{\"0\":{\"283\":1},\"1\":{\"284\":1}}],[\"网络地址＋\",{\"1\":{\"155\":1}}],[\"网络地址＋主机地址\",{\"1\":{\"155\":1}}],[\"网络地址与端口转换\",{\"1\":{\"138\":1}}],[\"网络通信时\",{\"1\":{\"151\":1}}],[\"网络\",{\"1\":{\"150\":1}}],[\"网络层负责在不同网络之间进行数据包的路由和转发\",{\"1\":{\"283\":1}}],[\"网络层\",{\"0\":{\"288\":1},\"1\":{\"283\":3}}],[\"网络层和数据链路层有什么关系\",{\"1\":{\"150\":1}}],[\"网络层的主要作用是\",{\"1\":{\"150\":1}}],[\"网络层的下一层是数据链路层\",{\"1\":{\"136\":1}}],[\"网络层等层层往上传递最后给到应用程序\",{\"1\":{\"147\":1}}],[\"网络层带上ip头\",{\"1\":{\"146\":1}}],[\"网络环境切换成\",{\"1\":{\"111\":1}}],[\"网络迁移需要重新连接\",{\"0\":{\"111\":1},\"1\":{\"108\":1}}],[\"网络服务等\",{\"1\":{\"20\":1}}],[\"网页请求\",{\"1\":{\"21\":1}}],[\"其接收窗口大小就是各个\",{\"1\":{\"278\":1}}],[\"其次就是\",{\"1\":{\"148\":1}}],[\"其实是所有网卡共享的\",{\"1\":{\"147\":1}}],[\"其实也就是判断目标机器网络是否能连通\",{\"1\":{\"145\":1}}],[\"其实就是服务发现\",{\"1\":{\"133\":1}}],[\"其使用的广播目的地址是\",{\"1\":{\"137\":1}}],[\"其默认在建立底层\",{\"1\":{\"133\":1}}],[\"其他则会忽略这个包\",{\"1\":{\"306\":1}}],[\"其他进程还是可以正常读写该\",{\"1\":{\"261\":1}}],[\"其他流不受影响\",{\"1\":{\"113\":1}}],[\"其他数据\",{\"1\":{\"66\":2}}],[\"其结果就是\",{\"1\":{\"81\":1}}],[\"其结果是正确的\",{\"1\":{\"80\":1}}],[\"其主要是需要从内存中找到网络数据\",{\"1\":{\"72\":1}}],[\"其队列包含三个运行队列\",{\"1\":{\"61\":1}}],[\"其运行的越久\",{\"1\":{\"60\":1}}],[\"其中对于\",{\"1\":{\"153\":1}}],[\"其中127\",{\"1\":{\"145\":1}}],[\"其中最高位是作为\",{\"1\":{\"80\":1}}],[\"其中前面的\",{\"1\":{\"62\":1}}],[\"其中优先级的数值越小\",{\"1\":{\"58\":1}}],[\"其中某一个\",{\"1\":{\"24\":1}}],[\"其中一方在发出数据包之后\",{\"1\":{\"24\":1}}],[\"其中一方在发出数据包之后超一定时间\",{\"1\":{\"24\":1}}],[\"其中\",{\"1\":{\"21\":1,\"61\":1,\"75\":1,\"82\":1,\"146\":1,\"155\":1,\"158\":1}}],[\"其子进程可能会成为孤儿进程\",{\"1\":{\"20\":1}}],[\"trip\",{\"1\":{\"233\":1}}],[\"traceroute\",{\"0\":{\"143\":1},\"1\":{\"143\":6}}],[\"transfer\",{\"1\":{\"86\":1}}],[\"transaction\",{\"1\":{\"67\":1}}],[\"threshold\",{\"1\":{\"216\":1}}],[\"through\",{\"1\":{\"64\":1,\"65\":1}}],[\"tsval\",{\"1\":{\"210\":2,\"246\":2}}],[\"tw\",{\"1\":{\"193\":2,\"210\":2}}],[\"ttl\",{\"1\":{\"139\":1,\"143\":3,\"162\":2}}],[\"ticket\",{\"1\":{\"122\":3}}],[\"timestamps\",{\"1\":{\"210\":2}}],[\"timestamps=1\",{\"1\":{\"210\":1}}],[\"timeout\",{\"1\":{\"170\":1}}],[\"time\",{\"0\":{\"39\":1,\"162\":1,\"163\":1,\"164\":1,\"165\":1,\"166\":1,\"193\":1,\"267\":1},\"1\":{\"38\":1,\"39\":1,\"164\":2,\"165\":2,\"166\":1,\"189\":2,\"193\":3,\"210\":1,\"233\":1,\"255\":1}}],[\"tls四次握手\",{\"1\":{\"129\":2}}],[\"tls的握手过程之后可以进行加密传输\",{\"1\":{\"126\":1}}],[\"tls协议\",{\"1\":{\"126\":1}}],[\"tlsv1\",{\"1\":{\"123\":1}}],[\"tls1\",{\"1\":{\"122\":1,\"280\":1}}],[\"tls升级\",{\"1\":{\"120\":1}}],[\"tls\",{\"1\":{\"100\":1,\"106\":1,\"108\":1,\"111\":1,\"114\":4,\"118\":1,\"120\":2,\"122\":1,\"129\":9,\"130\":4,\"280\":3,\"281\":1}}],[\"type\",{\"1\":{\"88\":2}}],[\"task\",{\"1\":{\"58\":6}}],[\"tag\",{\"1\":{\"49\":2}}],[\"too\",{\"1\":{\"205\":1}}],[\"to\",{\"1\":{\"148\":2,\"150\":1}}],[\"top\",{\"1\":{\"72\":1}}],[\"token\",{\"1\":{\"45\":1,\"47\":1}}],[\"toc\",{\"1\":{\"20\":1}}],[\"tcp模块在执行链接\",{\"1\":{\"303\":1}}],[\"tcp四次挥手可以变成三次吗\",{\"0\":{\"260\":1}}],[\"tcp四次挥手性能的提升\",{\"0\":{\"197\":1}}],[\"tcp断开连接\",{\"0\":{\"254\":1}}],[\"tcpkill\",{\"0\":{\"251\":1},\"1\":{\"251\":1}}],[\"tcp时间戳\",{\"1\":{\"246\":1}}],[\"tcp时一个面向字节流的协议\",{\"1\":{\"26\":1}}],[\"tcp报文发送给服务端\",{\"1\":{\"238\":1}}],[\"tcp报文发出去之后不会从内存中立马删除\",{\"1\":{\"198\":1}}],[\"tcp在刚建立的时候\",{\"1\":{\"216\":1}}],[\"tcp在连接时使用三次握手\",{\"1\":{\"22\":1}}],[\"tcp只保证传输层的消息可靠性\",{\"1\":{\"213\":1}}],[\"tcp丢包\",{\"1\":{\"213\":1}}],[\"tcp连接\",{\"0\":{\"270\":1}}],[\"tcp连接的断开\",{\"0\":{\"253\":1}}],[\"tcp连接的建立\",{\"0\":{\"237\":1,\"238\":1}}],[\"tcp连接存在于内核中\",{\"1\":{\"211\":1}}],[\"tcp连接会消失吗\",{\"0\":{\"211\":1}}],[\"tcp半连接队列和全连接队列\",{\"0\":{\"209\":1}}],[\"tcp工作在那一层\",{\"0\":{\"202\":1}}],[\"tcp基本认识\",{\"0\":{\"200\":1}}],[\"tcp传输数据的性能提升\",{\"0\":{\"198\":1}}],[\"tcp三次握手的性能提升\",{\"0\":{\"196\":1}}],[\"tcp三次握手tls四次握手\",{\"1\":{\"110\":1}}],[\"tcp同时打开\",{\"1\":{\"181\":1}}],[\"tcp自连接\",{\"1\":{\"181\":1}}],[\"tcp面向连接的传输层协议\",{\"1\":{\"174\":1}}],[\"tcp确实通过tcp选项中的最大报文段长度\",{\"1\":{\"158\":1}}],[\"tcp和ping数据的区别\",{\"0\":{\"146\":1}}],[\"tcp和udp在内核中是两个完全独立的软件模块\",{\"1\":{\"187\":1}}],[\"tcp和udp可以同时绑定相同的端口吗\",{\"0\":{\"186\":1,\"187\":1}}],[\"tcp和udp是传输层常见的两种传输协议\",{\"1\":{\"21\":1}}],[\"tcp和udp的区别\",{\"0\":{\"21\":1,\"171\":1,\"173\":1}}],[\"tcp与tls的握手延迟\",{\"0\":{\"110\":1}}],[\"tcp\",{\"0\":{\"132\":1,\"190\":1,\"193\":1,\"208\":1,\"247\":1,\"277\":1},\"1\":{\"88\":1,\"100\":2,\"106\":6,\"108\":1,\"109\":4,\"111\":2,\"112\":1,\"123\":2,\"133\":2,\"134\":2,\"138\":1,\"146\":2,\"150\":1,\"151\":1,\"164\":1,\"166\":1,\"167\":1,\"169\":5,\"174\":7,\"177\":1,\"179\":1,\"181\":2,\"188\":2,\"189\":1,\"191\":2,\"193\":2,\"196\":1,\"198\":2,\"201\":3,\"202\":1,\"203\":8,\"205\":5,\"208\":2,\"209\":2,\"210\":6,\"218\":1,\"222\":1,\"226\":1,\"227\":1,\"228\":1,\"229\":2,\"239\":1,\"242\":1,\"243\":1,\"244\":1,\"248\":2,\"251\":2,\"252\":3,\"261\":2,\"262\":6,\"267\":1,\"268\":2,\"270\":5,\"277\":5,\"278\":1,\"283\":3,\"284\":1,\"287\":2,\"297\":1,\"298\":2,\"299\":1}}],[\"tcpdump\",{\"1\":{\"72\":1}}],[\"tcp的保活机制\",{\"1\":{\"268\":1}}],[\"tcp的四次挥手\",{\"0\":{\"255\":1}}],[\"tcp的三次握手\",{\"1\":{\"238\":1}}],[\"tcp的三次握手和四次挥手\",{\"0\":{\"29\":1}}],[\"tcp的重传机制\",{\"0\":{\"231\":1,\"232\":1}}],[\"tcp的流量控制\",{\"0\":{\"220\":1}}],[\"tcp的拥塞控制\",{\"0\":{\"214\":1}}],[\"tcp的头格式\",{\"0\":{\"201\":1}}],[\"tcp的基本认识\",{\"0\":{\"199\":1}}],[\"tcp的优化\",{\"0\":{\"194\":1}}],[\"tcp的socket编程\",{\"0\":{\"175\":1}}],[\"tcp的mss是指tcp报文段中数据字段的最大长度\",{\"1\":{\"158\":1}}],[\"tcp的特点是\",{\"1\":{\"21\":1}}],[\"tcp是如何解决窗口关闭的时候\",{\"1\":{\"229\":1}}],[\"tcp是如何保证有序的\",{\"0\":{\"25\":1}}],[\"tcp是如何保证可靠的\",{\"0\":{\"23\":1}}],[\"tcp是如何做链接管理的\",{\"0\":{\"22\":1}}],[\"1~31\",{\"1\":{\"223\":1}}],[\"1~192\",{\"1\":{\"153\":1}}],[\"16\",{\"1\":{\"159\":1,\"205\":1,\"243\":1}}],[\"168\",{\"1\":{\"138\":2,\"153\":8}}],[\"1是一个回环地址\",{\"1\":{\"148\":1}}],[\"1和localhost和0\",{\"0\":{\"148\":1}}],[\"1吗\",{\"0\":{\"144\":1}}],[\"175\",{\"1\":{\"138\":1}}],[\"172\",{\"1\":{\"138\":1}}],[\"183\",{\"1\":{\"138\":1}}],[\"1的头部存在问题\",{\"1\":{\"102\":1}}],[\"1的出现高延迟\",{\"1\":{\"100\":1}}],[\"135\",{\"1\":{\"82\":2}}],[\"130\",{\"1\":{\"82\":1}}],[\"128\",{\"1\":{\"159\":2}}],[\"121\",{\"1\":{\"138\":1}}],[\"120\",{\"1\":{\"138\":1}}],[\"126\",{\"1\":{\"82\":1}}],[\"127\",{\"0\":{\"148\":1},\"1\":{\"82\":3,\"148\":1,\"157\":1}}],[\"192\",{\"1\":{\"138\":2,\"153\":7}}],[\"19\",{\"1\":{\"62\":1}}],[\"14\",{\"1\":{\"57\":1}}],[\"1500\",{\"1\":{\"143\":1,\"158\":2}}],[\"15~16\",{\"1\":{\"82\":1}}],[\"15\",{\"1\":{\"49\":3,\"82\":1}}],[\"11\",{\"0\":{\"40\":1},\"1\":{\"82\":1,\"138\":1}}],[\"1025\",{\"1\":{\"138\":1}}],[\"10^\",{\"1\":{\"82\":3}}],[\"1010\",{\"1\":{\"81\":1,\"82\":2}}],[\"101\",{\"1\":{\"81\":2,\"82\":4,\"156\":2}}],[\"1000\",{\"1\":{\"81\":1,\"82\":2}}],[\"10000010\",{\"1\":{\"82\":1}}],[\"10000\",{\"1\":{\"75\":1}}],[\"100\",{\"1\":{\"67\":4,\"106\":2}}],[\"100~139\",{\"1\":{\"58\":1,\"62\":1}}],[\"10~20\",{\"1\":{\"49\":1}}],[\"10\",{\"0\":{\"39\":1},\"1\":{\"82\":3,\"83\":1,\"138\":1}}],[\"1状态\",{\"1\":{\"35\":1,\"255\":1,\"256\":1}}],[\"1\",{\"0\":{\"21\":1,\"31\":1,\"35\":1,\"43\":1,\"97\":1,\"100\":1,\"101\":1,\"108\":1,\"109\":1,\"113\":1,\"118\":1,\"126\":1,\"133\":1,\"145\":1,\"147\":1,\"187\":1,\"233\":1,\"293\":1,\"299\":1},\"1\":{\"24\":1,\"26\":1,\"28\":3,\"43\":1,\"47\":1,\"56\":8,\"67\":1,\"74\":2,\"75\":1,\"80\":9,\"81\":4,\"82\":17,\"83\":7,\"98\":1,\"101\":2,\"106\":2,\"107\":2,\"114\":2,\"120\":2,\"123\":1,\"128\":1,\"129\":10,\"133\":1,\"138\":2,\"139\":27,\"142\":1,\"143\":4,\"148\":1,\"153\":6,\"156\":2,\"157\":1,\"169\":1,\"170\":1,\"179\":1,\"183\":2,\"193\":1,\"197\":1,\"201\":6,\"210\":1,\"216\":1,\"217\":1,\"218\":1,\"219\":1,\"223\":1,\"230\":1,\"239\":1,\"243\":1,\"246\":1,\"248\":2,\"261\":1,\"280\":1,\"284\":1,\"289\":1,\"291\":1}}],[\"计时器\",{\"1\":{\"241\":1}}],[\"计时器超时后主机就会发送\",{\"1\":{\"139\":1}}],[\"计时器的时间是随机的\",{\"1\":{\"139\":1}}],[\"计算性能不佳\",{\"1\":{\"129\":1}}],[\"计算出一个cookie\",{\"1\":{\"169\":1}}],[\"计算出一个唯一的哈希值\",{\"1\":{\"128\":1}}],[\"计算出本次通信的\",{\"1\":{\"129\":2}}],[\"计算出来的\",{\"1\":{\"62\":1}}],[\"计算机的网卡本身具有mac地址\",{\"1\":{\"306\":1}}],[\"计算机使用一个特殊的\",{\"1\":{\"157\":1}}],[\"计算机存储小数的采用的是浮点数\",{\"1\":{\"82\":1}}],[\"计算机是怎么存小数的\",{\"0\":{\"82\":1}}],[\"计算机保存数据的形式\",{\"0\":{\"79\":1}}],[\"计算机经过计算后\",{\"1\":{\"77\":1}}],[\"计算机基础\",{\"2\":{\"17\":1,\"19\":1}}],[\"计网部分\",{\"1\":{\"20\":1}}],[\"饥饿可能是由于不公平的资源分配策略或竞争条件引起的\",{\"1\":{\"20\":1}}],[\"饥饿进程是指因为资源分配问题而无法获得所需资源\",{\"1\":{\"20\":1}}],[\"饥饿进程\",{\"1\":{\"20\":1}}],[\"而交换机是基于以太网设计的\",{\"1\":{\"307\":1}}],[\"而最下面的网卡则负责完成实际的收发操作\",{\"1\":{\"297\":1}}],[\"而将网络包发送给对方的操作就是由\",{\"1\":{\"297\":1}}],[\"而路由则是跟据下一个目的地选择路径\",{\"1\":{\"290\":1}}],[\"而数据链路层则负责通过物理介质传输数据\",{\"1\":{\"283\":1}}],[\"而客户端使用cklose函数超过60s没有接收fin报文\",{\"1\":{\"258\":1}}],[\"而客户端则会time\",{\"1\":{\"38\":1,\"255\":1}}],[\"而要实现这个功能\",{\"1\":{\"239\":1}}],[\"而发送方可以发送小数据\",{\"1\":{\"230\":1}}],[\"而发送方会义无反顾地发送这几个字节\",{\"1\":{\"230\":1}}],[\"而操作系统的缓冲区\",{\"1\":{\"228\":1}}],[\"而可以继续发送数据的最大值\",{\"1\":{\"221\":1}}],[\"而非对\",{\"1\":{\"210\":1}}],[\"而半连接队列被设计为哈希表\",{\"1\":{\"183\":1}}],[\"而半连接队列却不太一样\",{\"1\":{\"183\":1}}],[\"而服务端取走连接的过程中\",{\"1\":{\"183\":1}}],[\"而没有调用\",{\"1\":{\"180\":1}}],[\"而没有被运行的任务\",{\"1\":{\"60\":1}}],[\"而人类为了方便记忆采用了点分十进制的标记方式\",{\"1\":{\"151\":1}}],[\"而rpc有专门的\",{\"1\":{\"133\":1}}],[\"而https在三次握手之后还需要进行一次ssl\",{\"1\":{\"126\":1}}],[\"而同一\",{\"1\":{\"106\":1}}],[\"而我们二进制只能精准表达\",{\"1\":{\"83\":1}}],[\"而当我们需要计算实际的十进制数的时候\",{\"1\":{\"82\":1}}],[\"而当数组元素都是是顺序的\",{\"1\":{\"52\":1}}],[\"而有符号整数的计算是比无符号整数麻烦的\",{\"1\":{\"82\":1}}],[\"而用\",{\"1\":{\"82\":1}}],[\"而用了补码的表示方式\",{\"1\":{\"80\":1}}],[\"而只是把最高位的符号标志位变为\",{\"1\":{\"80\":1}}],[\"而负数就比较特殊了点\",{\"1\":{\"80\":1}}],[\"而寄存器可以分为多种类\",{\"1\":{\"75\":1}}],[\"而且每一个连接都要经过\",{\"1\":{\"100\":1}}],[\"而且尾数的长度决定了这个数的精度\",{\"1\":{\"82\":1}}],[\"而且必须为\",{\"1\":{\"82\":1}}],[\"而且把这种整数部分没有前导\",{\"1\":{\"82\":1}}],[\"而且\",{\"1\":{\"72\":1,\"139\":1}}],[\"而软中断\",{\"1\":{\"72\":1}}],[\"而降低内核的工作效率\",{\"1\":{\"72\":1}}],[\"而不会导致接收端处理不过来\",{\"1\":{\"222\":1}}],[\"而不是\",{\"1\":{\"121\":1}}],[\"而不是i\",{\"1\":{\"119\":1}}],[\"而不是按照单个数组元素来读取数据的\",{\"1\":{\"49\":1}}],[\"而不需要通知其他\",{\"1\":{\"69\":1}}],[\"而其他\",{\"1\":{\"69\":1}}],[\"而如果将半连接队列设计成哈希表\",{\"1\":{\"183\":1}}],[\"而如果\",{\"1\":{\"67\":1,\"188\":1}}],[\"而如果在单核系统里\",{\"1\":{\"57\":1}}],[\"而此时同一时间\",{\"1\":{\"67\":1}}],[\"而导致连接冲突的问题\",{\"1\":{\"191\":1}}],[\"而导致\",{\"1\":{\"56\":1}}],[\"而现代\",{\"1\":{\"53\":1}}],[\"而对于\",{\"1\":{\"49\":1,\"129\":1,\"278\":1}}],[\"而是直接接受所有包并存在缓冲区\",{\"1\":{\"306\":1}}],[\"而是一个比\",{\"1\":{\"275\":1}}],[\"而是一种调用方式\",{\"1\":{\"132\":1}}],[\"而是把它放到乱序队列\",{\"1\":{\"263\":1}}],[\"而是把缓存交给客户端\",{\"1\":{\"122\":1}}],[\"而是采用先收缩窗口\",{\"1\":{\"228\":1}}],[\"而是可能出现在\",{\"1\":{\"160\":1}}],[\"而是在本机打了一个转又回去了\",{\"1\":{\"147\":1}}],[\"而是将包丢弃\",{\"1\":{\"143\":1}}],[\"而是选择ecdhe密钥交换算法\",{\"1\":{\"120\":1}}],[\"而是要先向所有的其他\",{\"1\":{\"69\":1}}],[\"而是表示优先级的修正数值\",{\"1\":{\"62\":1}}],[\"而是读取\",{\"1\":{\"49\":1}}],[\"而是执行系统级别的任务\",{\"1\":{\"20\":1}}],[\"而访问内存速度大概在\",{\"1\":{\"49\":1}}],[\"而\",{\"1\":{\"49\":2,\"57\":1,\"59\":1,\"62\":1,\"69\":1,\"82\":2,\"100\":1,\"106\":1,\"107\":1,\"137\":1,\"150\":1,\"154\":1}}],[\"而无需暴露资源所有者的凭据\",{\"1\":{\"43\":1}}],[\"而无法继续执行的进程\",{\"1\":{\"20\":1}}],[\"如进程崩溃\",{\"1\":{\"260\":1}}],[\"如此往复\",{\"1\":{\"143\":1}}],[\"如rsa\",{\"1\":{\"129\":2}}],[\"如何理解tcp是基于字节流的协议\",{\"0\":{\"206\":1}}],[\"如何确定一个tcp连接\",{\"0\":{\"205\":1}}],[\"如何确定最大传输速度\",{\"1\":{\"198\":1}}],[\"如何绕过三次握手\",{\"1\":{\"196\":1}}],[\"如何解决粘包\",{\"1\":{\"208\":1}}],[\"如何解决syn超时\",{\"0\":{\"170\":1}}],[\"如何解决的\",{\"0\":{\"128\":1}}],[\"如何避免\",{\"0\":{\"190\":1}}],[\"如何避免syn攻击\",{\"0\":{\"169\":1}}],[\"如何避免发送http请求\",{\"0\":{\"97\":1}}],[\"如何优化tcp\",{\"0\":{\"195\":1}}],[\"如何优化\",{\"0\":{\"165\":1}}],[\"如何减少http响应的数据大小\",{\"0\":{\"99\":1}}],[\"如何减少http请求次数\",{\"0\":{\"98\":1}}],[\"如何写出让\",{\"0\":{\"50\":1}}],[\"如何设计一个登录验签服务\",{\"0\":{\"47\":1}}],[\"如下\",{\"1\":{\"57\":1}}],[\"如下表格\",{\"1\":{\"49\":1}}],[\"如下图过程\",{\"1\":{\"80\":1}}],[\"如下图\",{\"1\":{\"49\":1,\"57\":2,\"59\":1,\"80\":2,\"81\":1}}],[\"如限制登录失败次数\",{\"1\":{\"47\":1}}],[\"如索引\",{\"1\":{\"47\":1}}],[\"如消息队列\",{\"1\":{\"47\":1}}],[\"如\",{\"1\":{\"47\":1,\"129\":4,\"158\":1}}],[\"如mongodb\",{\"1\":{\"47\":1}}],[\"如mysql\",{\"1\":{\"47\":1}}],[\"如用户名和密码\",{\"1\":{\"43\":1}}],[\"如果网关为空\",{\"1\":{\"307\":1}}],[\"如果网关是一个\",{\"1\":{\"307\":1}}],[\"如果网络地址相同\",{\"1\":{\"155\":1}}],[\"如果接受方mac地址是一个广播地址\",{\"1\":{\"306\":1}}],[\"如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口\",{\"1\":{\"230\":1}}],[\"如果接收方在接收到序号为1至98和序号为100的数据段后\",{\"1\":{\"221\":1}}],[\"如果接收方已经收到了序号为1至100的数据段\",{\"1\":{\"221\":1}}],[\"如果接收方的聊天软件崩溃了\",{\"1\":{\"213\":1}}],[\"如果接收方的程序如果不知道\",{\"1\":{\"203\":1}}],[\"如果接收缓冲区有已接收的数据\",{\"1\":{\"197\":1}}],[\"如果接收到了\",{\"1\":{\"142\":1}}],[\"如果没问题则放到缓存区\",{\"1\":{\"306\":1}}],[\"如果没有任何连接相关的活动\",{\"1\":{\"268\":1}}],[\"如果没有\",{\"1\":{\"93\":1}}],[\"如果没有time\",{\"1\":{\"39\":1}}],[\"如果其它条目都无法匹配自动匹配默认网关\",{\"1\":{\"303\":1}}],[\"如果其中一个数据丢失\",{\"1\":{\"277\":1}}],[\"如果其中一个ip包丢失\",{\"1\":{\"242\":1}}],[\"如果其中一方的进程发生了崩溃\",{\"1\":{\"270\":1}}],[\"如果连续几个探测报文都没有得到响应\",{\"1\":{\"268\":1}}],[\"如果连接的内存配置过大\",{\"1\":{\"198\":1}}],[\"如果连接的内存配置过小\",{\"1\":{\"198\":1}}],[\"如果已经建立了链接\",{\"0\":{\"268\":1,\"269\":1}}],[\"如果能找到这个数据包序列号保持顺序的报文\",{\"1\":{\"263\":1}}],[\"如果fin报文比数据包提前到达客户端\",{\"1\":{\"263\":1}}],[\"如果进程退出了\",{\"1\":{\"260\":1}}],[\"如果中途再次接收到fin报文\",{\"1\":{\"259\":1}}],[\"如果中途丢失了一个分片\",{\"1\":{\"174\":1}}],[\"如果关闭方使用的是shutdown函数\",{\"1\":{\"257\":1}}],[\"如果关闭方使用的是close函数\",{\"1\":{\"257\":1}}],[\"如果处于\",{\"1\":{\"250\":1}}],[\"如果收到了服务端发送的数据\",{\"1\":{\"261\":1}}],[\"如果收到了syn报文\",{\"1\":{\"249\":1}}],[\"如果收到的是\",{\"1\":{\"248\":1}}],[\"如果收到新数据的\",{\"1\":{\"28\":1,\"219\":1}}],[\"如果上一次发送的报文是\",{\"1\":{\"248\":1}}],[\"如果超过会在等一段时间\",{\"1\":{\"243\":1}}],[\"如果超过了\",{\"1\":{\"162\":1}}],[\"如果直接交给ip层\",{\"1\":{\"242\":1}}],[\"如果窗口大小为\",{\"1\":{\"229\":1}}],[\"如果对方别有用心\",{\"1\":{\"213\":1}}],[\"如果还是两端通信\",{\"1\":{\"213\":2}}],[\"如果第四次挥手的\",{\"1\":{\"212\":1}}],[\"如果发送窗口的大小没有变化\",{\"1\":{\"223\":1}}],[\"如果发送缓冲区\",{\"1\":{\"209\":2}}],[\"如果发送缓冲区还有未发送的数据\",{\"1\":{\"197\":1}}],[\"如果发现收到的数据包中时间戳不是递增的\",{\"1\":{\"210\":1,\"246\":1}}],[\"如果开启该选项的话\",{\"1\":{\"210\":1}}],[\"如果持续不断地有连接因为\",{\"1\":{\"209\":1}}],[\"如果内存资源被占满后\",{\"1\":{\"205\":1}}],[\"如果文件描述符被占满了\",{\"1\":{\"205\":1}}],[\"如果双方同时关闭连接会出现什么\",{\"1\":{\"197\":1}}],[\"如果该连接处于\",{\"1\":{\"193\":1}}],[\"如果选择到的端口\",{\"1\":{\"193\":1}}],[\"如果都是相同的\",{\"1\":{\"192\":1}}],[\"如果半连接队列还是个链表\",{\"1\":{\"183\":1}}],[\"如果使用了\",{\"1\":{\"174\":1}}],[\"如果合法就创建一个全连接队列\",{\"1\":{\"169\":1}}],[\"如果服务端要避免过多的\",{\"1\":{\"165\":1}}],[\"如果服务端\",{\"1\":{\"164\":1}}],[\"如果客户端的\",{\"1\":{\"270\":1}}],[\"如果客户端是用\",{\"1\":{\"261\":1}}],[\"如果客户端在完后一个\",{\"1\":{\"166\":1}}],[\"如果客户端\",{\"1\":{\"164\":1}}],[\"如果客户端和服务端同时支持\",{\"1\":{\"123\":1}}],[\"如果出现连续的\",{\"1\":{\"159\":1}}],[\"如果路由控制表中存在多条相同网络地址的记录\",{\"1\":{\"157\":1}}],[\"如果此时攻击者构造大量的第三次握手包\",{\"1\":{\"185\":1}}],[\"如果此时\",{\"1\":{\"148\":1}}],[\"如果此时是普通的\",{\"1\":{\"134\":1}}],[\"如果租约的\",{\"1\":{\"137\":1}}],[\"如果浏览器不支持\",{\"1\":{\"129\":2}}],[\"如果首次出现的请求发生了丢包\",{\"1\":{\"104\":1}}],[\"如果头部字段属于静态表范围\",{\"1\":{\"103\":1}}],[\"如果一直没有接收到fin报文就会一直死等\",{\"1\":{\"257\":1}}],[\"如果一样说明资源未改变\",{\"1\":{\"97\":1}}],[\"如果一个tcp分片丢失\",{\"1\":{\"242\":1}}],[\"如果一个任务在运行\",{\"1\":{\"60\":1}}],[\"如果一个线程在不同核心来回切换\",{\"1\":{\"53\":1}}],[\"如果二进制要用到科学记数法\",{\"1\":{\"82\":1}}],[\"如果为负数\",{\"1\":{\"80\":1}}],[\"如果负数不是使用补码的方式表示\",{\"1\":{\"80\":1}}],[\"如果采用这种方式来表示负数的二进制的话\",{\"1\":{\"80\":1}}],[\"如果输入设备是键盘\",{\"1\":{\"77\":1}}],[\"如果在延迟等待发送\",{\"1\":{\"262\":1}}],[\"如果在读出来这一刻\",{\"1\":{\"213\":1}}],[\"如果在某个阶段出现超时\",{\"1\":{\"170\":1}}],[\"如果在定时器超时之前\",{\"1\":{\"139\":1}}],[\"如果在\",{\"1\":{\"72\":1}}],[\"如果在多核之间竞争比较严重\",{\"1\":{\"57\":1}}],[\"如果在多核\",{\"1\":{\"57\":1}}],[\"如果当前启动进程绑定的\",{\"1\":{\"190\":1}}],[\"如果当前中断处理程序没有执行完之前\",{\"1\":{\"71\":1}}],[\"如果当发生写操作时\",{\"1\":{\"66\":2}}],[\"如果有fin字段就会进入time\",{\"1\":{\"263\":1}}],[\"如果有别的进程企图使用该\",{\"1\":{\"261\":1}}],[\"如果有一个进程调用了\",{\"1\":{\"261\":1}}],[\"如果有多进程\",{\"1\":{\"261\":2}}],[\"如果有其他核心从内存读取了相同的数据到各自的\",{\"1\":{\"69\":1}}],[\"如果有效位是\",{\"1\":{\"49\":1}}],[\"如果要向独占的\",{\"1\":{\"69\":1}}],[\"如果要实现不同域名下的cookie正常使用\",{\"0\":{\"46\":1}}],[\"如果两个\",{\"1\":{\"67\":1,\"188\":1}}],[\"如果这时候是想建立\",{\"1\":{\"134\":1}}],[\"如果这时旁边的\",{\"1\":{\"67\":1}}],[\"如果这个ack报文丢失就会造成双方均处于等待的死锁环境\",{\"1\":{\"229\":1}}],[\"如果这个\",{\"1\":{\"66\":1}}],[\"如果不是就丢弃\",{\"1\":{\"306\":1}}],[\"如果不是\",{\"1\":{\"72\":1}}],[\"如果不是脏的话\",{\"1\":{\"66\":1}}],[\"如果不能保证缓存一致性的问题\",{\"1\":{\"67\":1}}],[\"如果我们还想保证应用层的消息可靠性\",{\"1\":{\"213\":1}}],[\"如果我们用相同的方式\",{\"1\":{\"81\":1}}],[\"如果我们大量的操作都能够命中缓存\",{\"1\":{\"66\":1}}],[\"如果我们启动任务的时候\",{\"1\":{\"62\":1}}],[\"如果是就放到接收缓冲区中\",{\"1\":{\"307\":1}}],[\"如果是就需要考虑防火墙增加规则\",{\"1\":{\"72\":1}}],[\"如果是两端通信\",{\"1\":{\"213\":1}}],[\"如果是负数就要把加法操作变成减法操作才可以得到正确对结果\",{\"1\":{\"80\":1}}],[\"如果是\",{\"1\":{\"75\":1}}],[\"如果是的话\",{\"1\":{\"72\":1}}],[\"如果是脏的话\",{\"1\":{\"66\":1}}],[\"如果是通过\",{\"1\":{\"46\":1}}],[\"如果某些任务要求实时性比较高\",{\"1\":{\"62\":1}}],[\"如果想修改已经运行中的任务的优先级\",{\"1\":{\"62\":1}}],[\"如果想让进程处理更多的事情\",{\"1\":{\"58\":1}}],[\"如果你想让某个普通任务有更多的执行时间\",{\"1\":{\"62\":1}}],[\"如果你希望\",{\"1\":{\"46\":1}}],[\"如果分支预测可以预测到接下来要执行\",{\"1\":{\"52\":1}}],[\"如果\",{\"1\":{\"49\":1,\"56\":1,\"68\":1,\"69\":2,\"136\":1,\"138\":1,\"229\":1}}],[\"如果跨域请求不能通过上述方法解决\",{\"1\":{\"46\":1}}],[\"如果用户同意授权\",{\"1\":{\"45\":1}}],[\"如果再收到重复的\",{\"1\":{\"28\":1,\"219\":1}}],[\"如cpu时间\",{\"1\":{\"20\":1}}],[\"如日志记录\",{\"1\":{\"20\":1}}],[\"如需更多信息或讨论技术问题\",{\"1\":{\"15\":1}}],[\"并不会导致\",{\"1\":{\"261\":1}}],[\"并不会因为客户端的端口号相同\",{\"1\":{\"191\":1}}],[\"并不保证应用层的消息可靠性\",{\"1\":{\"213\":1}}],[\"并不关心具体是哪个连接\",{\"1\":{\"183\":1}}],[\"并不是自己期望收到的\",{\"1\":{\"249\":1}}],[\"并不是\",{\"1\":{\"130\":1}}],[\"并不是所有小数都可以用二进制表示\",{\"1\":{\"81\":1}}],[\"并不是读取\",{\"1\":{\"49\":1}}],[\"并用两个冒号\",{\"1\":{\"159\":1}}],[\"并用唯一的\",{\"1\":{\"122\":1}}],[\"并在此被转发到下一个路由器或目标设备\",{\"1\":{\"307\":1}}],[\"并在其\",{\"1\":{\"201\":1}}],[\"并在发送数据时将数据分成适当大小的段\",{\"1\":{\"158\":1}}],[\"并在tcp连接建立之后开辟出一片缓冲区\",{\"1\":{\"27\":1}}],[\"并为自己建立端口映射条目\",{\"1\":{\"138\":1}}],[\"并由\",{\"1\":{\"137\":1}}],[\"并向选中的服务器发送\",{\"1\":{\"137\":1}}],[\"并发送一个\",{\"1\":{\"197\":1}}],[\"并发传输\",{\"0\":{\"106\":1}}],[\"并发连接有限\",{\"1\":{\"100\":1}}],[\"并发框架\",{\"1\":{\"57\":1}}],[\"并检查是否有相同的数据在自己的\",{\"1\":{\"68\":1}}],[\"并没有起到缓存的效果\",{\"1\":{\"56\":1}}],[\"并将查询的结果作为接收方\",{\"1\":{\"307\":1}}],[\"并将其发送给对方\",{\"1\":{\"251\":1}}],[\"并将其展示给用户\",{\"1\":{\"45\":1}}],[\"并将状态标记为\",{\"1\":{\"56\":1}}],[\"并将此\",{\"1\":{\"56\":1}}],[\"并建立容灾备份系统\",{\"1\":{\"47\":1}}],[\"并及时进行预警和处理\",{\"1\":{\"47\":1}}],[\"并设置为允许访问的域名\",{\"1\":{\"46\":1}}],[\"并请求用户授权该第三方应用程序访问其个人信息\",{\"1\":{\"45\":1}}],[\"并通过授权服务器生成授权代码\",{\"1\":{\"43\":1}}],[\"并通过授权服务器授予客户端访问这些资源的权限\",{\"1\":{\"43\":1}}],[\"并使用访问令牌来验证和处理客户端的请求\",{\"1\":{\"43\":1}}],[\"并颁发访问令牌\",{\"1\":{\"43\":1}}],[\"并且它们用于确定数据包的顺序以及检测数据包的丢失或乱序到达\",{\"1\":{\"246\":1}}],[\"并且重传的syn报文序列号是一样的\",{\"1\":{\"243\":1}}],[\"并且重发这个包\",{\"1\":{\"24\":1}}],[\"并且syn和ack都等于1的tcp报文\",{\"1\":{\"238\":1}}],[\"并且请求发送方重传序号为99的数据段\",{\"1\":{\"221\":1}}],[\"并且接收缓冲区配置得足够大\",{\"1\":{\"198\":1}}],[\"并且后续再收到新的数据\",{\"1\":{\"197\":1}}],[\"并且是固定不变的\",{\"1\":{\"174\":1}}],[\"并且是第二次进行通信\",{\"1\":{\"123\":1}}],[\"并且公有\",{\"1\":{\"156\":1}}],[\"并且会主动获得\",{\"1\":{\"138\":1}}],[\"并且这两个客户端的本地端口都是\",{\"1\":{\"138\":1}}],[\"并且这个报文字段包含客户端收到的服务端的isn\",{\"1\":{\"33\":1,\"301\":1}}],[\"并且客户端能够在租用期内使用\",{\"1\":{\"137\":1}}],[\"并且使用\",{\"1\":{\"137\":1}}],[\"并且\",{\"1\":{\"103\":1,\"203\":1,\"230\":1,\"262\":1,\"265\":1}}],[\"并且还只能是\",{\"1\":{\"82\":1}}],[\"并且存储设备为了追求更快的速度\",{\"1\":{\"78\":1}}],[\"并且每一个\",{\"1\":{\"72\":1}}],[\"并且其\",{\"1\":{\"69\":1}}],[\"并且修改变量\",{\"1\":{\"56\":1}}],[\"并且变量\",{\"1\":{\"56\":1}}],[\"并且在等最后的确认报文\",{\"1\":{\"39\":1}}],[\"并且在其中客户端还会选择一个isn\",{\"1\":{\"31\":1,\"299\":1}}],[\"并跟据本端剩余缓冲区大小通告对方当前能接受数据的缓冲区大小\",{\"1\":{\"27\":1}}],[\"并根据序列号进行排序和重新组装\",{\"1\":{\"25\":1}}],[\"并一直运行直到系统关闭\",{\"1\":{\"20\":1}}],[\"并负责回收它们的资源\",{\"1\":{\"20\":1}}],[\"dns服务器\",{\"0\":{\"295\":1}}],[\"dns\",{\"1\":{\"137\":1,\"283\":1,\"295\":8,\"303\":1}}],[\"dhcp\",{\"0\":{\"137\":1},\"1\":{\"137\":34,\"159\":1}}],[\"dhe\",{\"1\":{\"129\":1}}],[\"dh\",{\"1\":{\"129\":2}}],[\"decoder\",{\"1\":{\"116\":1}}],[\"deadline\",{\"1\":{\"59\":4,\"61\":2}}],[\"dma\",{\"1\":{\"72\":1}}],[\"d\",{\"1\":{\"67\":4,\"154\":2,\"155\":1}}],[\"discover\",{\"1\":{\"137\":1}}],[\"disruptor\",{\"1\":{\"57\":2}}],[\"dirty\",{\"1\":{\"66\":1}}],[\"dl\",{\"1\":{\"61\":2}}],[\"data\",{\"1\":{\"49\":2,\"105\":1,\"148\":1}}],[\"daemon\",{\"1\":{\"20\":1}}],[\"ddos\",{\"1\":{\"47\":1}}],[\"done\",{\"1\":{\"129\":2}}],[\"double\",{\"1\":{\"82\":6}}],[\"domain=\",{\"1\":{\"46\":2}}],[\"document\",{\"1\":{\"46\":2}}],[\"docker\",{\"1\":{\"8\":1}}],[\"duplicated\",{\"1\":{\"28\":1,\"219\":1}}],[\"duplicate\",{\"0\":{\"236\":1},\"1\":{\"24\":1}}],[\"守护进程是在后台运行的系统服务进程\",{\"1\":{\"20\":1}}],[\"守护进程\",{\"1\":{\"20\":1}}],[\"当转发包时\",{\"1\":{\"307\":1}}],[\"当在表中找不到的时候\",{\"1\":{\"306\":1}}],[\"当以太网数据帧中的以太类型字段的值为0806\",{\"1\":{\"304\":1}}],[\"当以太网数据帧中的以太类型字段的值为0800\",{\"1\":{\"304\":1}}],[\"当报文长度超过mtu时\",{\"1\":{\"288\":1}}],[\"当两个不同设备的应用需要通信的时候\",{\"1\":{\"285\":1}}],[\"当已读取的数据大于最大接受窗口的一半时\",{\"1\":{\"278\":1}}],[\"当没有响应数据要发送时\",{\"1\":{\"262\":1}}],[\"当有响应数据要发送时\",{\"1\":{\"262\":1}}],[\"当被动关闭方在\",{\"1\":{\"262\":1}}],[\"当等待时间超过2msl\",{\"1\":{\"259\":1}}],[\"当第二次挥手丢失之后\",{\"1\":{\"257\":1}}],[\"当第一次握手丢失\",{\"0\":{\"243\":1}}],[\"当重传次数超出上限\",{\"1\":{\"256\":1,\"257\":1}}],[\"当重传超过次数达到上限后\",{\"1\":{\"169\":1}}],[\"当将分片交给tcp层后就不需要ip层进行分片了\",{\"1\":{\"242\":1}}],[\"当超过指定的时间后\",{\"1\":{\"233\":1}}],[\"当超过最大限制时\",{\"1\":{\"166\":1}}],[\"当窗口关闭的时候\",{\"1\":{\"229\":1}}],[\"当接收方的应用进程读取数据的速度非常快的话\",{\"1\":{\"226\":1}}],[\"当收到之前发送的数据\",{\"1\":{\"223\":1}}],[\"当触发了重传机制\",{\"1\":{\"217\":1}}],[\"当缓冲区满了\",{\"1\":{\"213\":1}}],[\"当同时开启了recycle\",{\"1\":{\"210\":1}}],[\"当同个链路中的所有设备收到\",{\"1\":{\"136\":1}}],[\"当前系统可打开的最大数量\",{\"1\":{\"205\":1}}],[\"当通信结束希望断开连接时\",{\"1\":{\"201\":1}}],[\"当主机接收到一个数据包\",{\"1\":{\"187\":1}}],[\"当处理完数据后\",{\"1\":{\"179\":1}}],[\"当服务端接收到ack时\",{\"1\":{\"169\":1}}],[\"当服务端出现大量\",{\"1\":{\"167\":2}}],[\"当半连接队列满了的时候\",{\"1\":{\"169\":1}}],[\"当网卡接收数据包的速度大于内核处理的速度时\",{\"1\":{\"169\":1}}],[\"当发生\",{\"1\":{\"218\":1}}],[\"当发生了\",{\"1\":{\"218\":1}}],[\"当发生写操作时\",{\"1\":{\"66\":1}}],[\"当发送没有携带数据的\",{\"1\":{\"262\":1}}],[\"当发送方把数据\",{\"1\":{\"223\":1}}],[\"当发送方每收到一个\",{\"1\":{\"216\":1}}],[\"当发送方依据发送窗口\",{\"1\":{\"198\":1}}],[\"当发送数据过快\",{\"1\":{\"213\":1}}],[\"当发现目标ip是回环地址时\",{\"1\":{\"147\":1}}],[\"当差错报文类型是端口不可达时\",{\"1\":{\"143\":1}}],[\"当目的主机\",{\"1\":{\"143\":1}}],[\"当然有的路由器根本就不会返回这个\",{\"1\":{\"143\":1}}],[\"当用户端禁用时\",{\"1\":{\"166\":1}}],[\"当用户有需要操作时再获取资源\",{\"1\":{\"98\":1}}],[\"当用完时间片的任务会被放到队列尾部\",{\"1\":{\"59\":1}}],[\"当浏览器第一次请求访问服务器资源时\",{\"1\":{\"93\":1}}],[\"当\",{\"1\":{\"68\":1,\"69\":2,\"76\":1,\"106\":1,\"169\":1,\"189\":1,\"203\":1,\"216\":2,\"230\":1,\"245\":1}}],[\"当某个核心在\",{\"1\":{\"67\":1}}],[\"当数据包大小大于mss时要将数据包分块\",{\"1\":{\"287\":1}}],[\"当数据被读取\",{\"1\":{\"27\":1}}],[\"当数组中的元素是随机的\",{\"1\":{\"52\":1}}],[\"当设置\",{\"1\":{\"46\":1}}],[\"当拥塞窗口超过慢启动门限\",{\"1\":{\"28\":1}}],[\"当传输层使用tcp协议时\",{\"1\":{\"25\":1}}],[\"当父进程提前终止或意外退出时\",{\"1\":{\"20\":1}}],[\"当一个进程完成执行\",{\"1\":{\"20\":1}}],[\"但却没有携带数据报文\",{\"1\":{\"262\":1}}],[\"但却对性能的提升起到了至关重要的作用\",{\"1\":{\"57\":1}}],[\"但对于大部分兼容性问题\",{\"1\":{\"213\":1}}],[\"但引入第三端服务器\",{\"1\":{\"213\":1}}],[\"但如果引入服务端\",{\"1\":{\"213\":1}}],[\"但因为过于细节\",{\"1\":{\"181\":1}}],[\"但内核还有个全局\",{\"1\":{\"181\":1}}],[\"但可能会丢包和乱序\",{\"1\":{\"174\":1}}],[\"但保证顺序和可靠\",{\"1\":{\"174\":1}}],[\"但它并没有消失\",{\"1\":{\"160\":1}}],[\"但一旦出了小区\",{\"1\":{\"156\":1}}],[\"但这个差错报文消息的类型是\",{\"1\":{\"143\":1}}],[\"但不同的地方在于\",{\"1\":{\"133\":1}}],[\"但不管怎么样\",{\"1\":{\"58\":1}}],[\"但事实上\",{\"1\":{\"57\":1}}],[\"但是同一个\",{\"1\":{\"278\":1}}],[\"但是还是具有接收数据的能力\",{\"1\":{\"261\":1}}],[\"但是还没有写到内存里\",{\"1\":{\"69\":1}}],[\"但是可以接受数据\",{\"1\":{\"257\":1}}],[\"但是有一个\",{\"1\":{\"252\":1}}],[\"但是他有一个问题重传的时候\",{\"1\":{\"234\":1}}],[\"但是序号为101的数据段丢失了\",{\"1\":{\"221\":1}}],[\"但是新启动的进程使用了\",{\"1\":{\"190\":1}}],[\"但是也有一些问题\",{\"1\":{\"185\":1}}],[\"但是上限值是内核参数\",{\"1\":{\"177\":1}}],[\"但是因为\",{\"1\":{\"159\":1}}],[\"但是因为同时归属于一个\",{\"1\":{\"56\":1}}],[\"但是非以太网的\",{\"1\":{\"143\":1}}],[\"但是以不同的端口号作为区分\",{\"1\":{\"138\":1}}],[\"但是如果\",{\"1\":{\"188\":1}}],[\"但是如果ip不同端口相同的话就可以绑定\",{\"1\":{\"188\":1}}],[\"但是如果连哈希值和内容一起被篡改\",{\"1\":{\"128\":1}}],[\"但是如果有一个小资源改变就需要重新下载全部\",{\"1\":{\"98\":1}}],[\"但是只有对应的私钥才能解密更安全\",{\"1\":{\"128\":1}}],[\"但是双方需要共享密钥容易造成密钥的丢失\",{\"1\":{\"128\":1}}],[\"但是延迟降到一定幅度后\",{\"1\":{\"100\":1}}],[\"但是对于\",{\"1\":{\"83\":1}}],[\"但是并不能保证事务串行化\",{\"1\":{\"68\":1}}],[\"但是不管别的核心的\",{\"1\":{\"68\":1}}],[\"但是各个\",{\"1\":{\"67\":1}}],[\"但是问题明显\",{\"1\":{\"65\":1}}],[\"但是普通任务之间还是有优先级区分的\",{\"1\":{\"60\":1}}],[\"但是高优先级的任务依然可以抢占低优先级的任务\",{\"1\":{\"59\":1}}],[\"但是优先级更高的任务\",{\"1\":{\"59\":1}}],[\"但是\",{\"1\":{\"53\":1,\"81\":1,\"138\":1,\"159\":2}}],[\"但是操作系统给每个线程分配了一个时间片\",{\"1\":{\"53\":1}}],[\"但是这样会出现多个内存块对应同一个\",{\"1\":{\"49\":1}}],[\"但是超时重传和快速重传都具有一个问题\",{\"1\":{\"24\":1}}],[\"但相对不可靠的数据传输\",{\"1\":{\"21\":1}}],[\"但在系统进程表中仍然存在\",{\"1\":{\"20\":1}}],[\"但其父进程尚未调用wait\",{\"1\":{\"20\":1}}],[\"physical\",{\"1\":{\"283\":1}}],[\"per\",{\"1\":{\"210\":2}}],[\"pkt\",{\"1\":{\"147\":1}}],[\"port\",{\"1\":{\"146\":1,\"164\":1,\"192\":1}}],[\"post\",{\"1\":{\"90\":1,\"91\":2}}],[\"pid\",{\"1\":{\"142\":1}}],[\"ping回环地址和ping本机地址没有什么区别\",{\"1\":{\"147\":1}}],[\"ping\",{\"1\":{\"142\":4,\"145\":1,\"146\":2,\"148\":5}}],[\"ping的工作原理\",{\"0\":{\"140\":1,\"141\":1}}],[\"pre\",{\"1\":{\"122\":1,\"129\":4}}],[\"protobuf\",{\"1\":{\"133\":1}}],[\"protocol\",{\"1\":{\"86\":1,\"121\":1,\"139\":1,\"283\":1}}],[\"procedure\",{\"1\":{\"132\":1}}],[\"process\",{\"1\":{\"20\":4}}],[\"proc\",{\"1\":{\"72\":2}}],[\"propagation\",{\"1\":{\"67\":1}}],[\"priority\",{\"1\":{\"62\":4}}],[\"packet\",{\"0\":{\"275\":1},\"1\":{\"275\":5}}],[\"paws\",{\"1\":{\"210\":5,\"212\":1,\"246\":1}}],[\"path=\",{\"1\":{\"46\":2}}],[\"password\",{\"1\":{\"44\":1}}],[\"python\",{\"1\":{\"4\":1}}],[\"zombie\",{\"1\":{\"20\":1}}],[\"僵尸进程不再执行任何代码\",{\"1\":{\"20\":1}}],[\"僵尸进程\",{\"1\":{\"20\":1}}],[\"学习笔记\",{\"0\":{\"16\":1}}],[\"感谢您的阅读\",{\"1\":{\"15\":1}}],[\"永远不要停止学习\",{\"1\":{\"15\":1}}],[\"旅行\",{\"1\":{\"14\":1}}],[\"阅读\",{\"1\":{\"14\":1}}],[\"兴趣爱好\",{\"0\":{\"14\":1}}],[\"证书传输优化\",{\"1\":{\"121\":2}}],[\"证书优化\",{\"0\":{\"121\":1}}],[\"证书\",{\"0\":{\"13\":1},\"1\":{\"121\":2}}],[\"河南科技学院\",{\"1\":{\"12\":1}}],[\"教育背景\",{\"0\":{\"12\":1}}],[\"评论\",{\"1\":{\"11\":1}}],[\"投票\",{\"1\":{\"10\":1}}],[\"亮点\",{\"1\":{\"10\":1,\"11\":1}}],[\"技术栈\",{\"1\":{\"10\":1,\"11\":1}}],[\"技能\",{\"0\":{\"3\":1}}],[\"职责\",{\"1\":{\"10\":1,\"11\":1}}],[\"职位\",{\"1\":{\"1\":1}}],[\"一直变化的是\",{\"1\":{\"307\":1}}],[\"一直在变化\",{\"1\":{\"150\":1}}],[\"一端断电和进程崩溃有什么区别\",{\"0\":{\"270\":1}}],[\"一来一回\",{\"1\":{\"239\":1}}],[\"一开始双方处于close状态\",{\"1\":{\"238\":1}}],[\"一台机器发的所有\",{\"1\":{\"210\":1}}],[\"一对一\",{\"1\":{\"203\":1}}],[\"一对多\",{\"1\":{\"174\":1}}],[\"一定是\",{\"1\":{\"203\":1}}],[\"一定时间后\",{\"1\":{\"139\":1}}],[\"一旦某个分片丢失\",{\"1\":{\"158\":1}}],[\"一旦客户端收到\",{\"1\":{\"137\":1}}],[\"一类是用于诊断的查询消息\",{\"1\":{\"139\":1}}],[\"一方的私钥是静态的\",{\"1\":{\"129\":1}}],[\"一起发送\",{\"1\":{\"114\":1,\"280\":1}}],[\"一起计算\",{\"1\":{\"75\":1}}],[\"一种是基于一个唯一标识符\",{\"1\":{\"94\":1}}],[\"一种是基于时间\",{\"1\":{\"94\":1}}],[\"一次该\",{\"1\":{\"248\":1}}],[\"一次可以计算\",{\"1\":{\"75\":3}}],[\"一次性能加载数据的大小\",{\"1\":{\"49\":1}}],[\"一些内核自定义事件也属于软中断\",{\"1\":{\"72\":1}}],[\"一些实时游戏\",{\"1\":{\"21\":1}}],[\"一致性最简单的方式是\",{\"1\":{\"65\":1}}],[\"一下会加载\",{\"1\":{\"57\":1}}],[\"一般在60s内不能接收到fin报文\",{\"1\":{\"257\":1}}],[\"一般有一个最大重传次数\",{\"1\":{\"243\":1}}],[\"一般而言\",{\"1\":{\"192\":1}}],[\"一般会\",{\"1\":{\"148\":1}}],[\"一般会暂时关闭中断请求\",{\"1\":{\"72\":1}}],[\"一般采用的是\",{\"1\":{\"82\":1}}],[\"一般需要通过下面这三个总线\",{\"1\":{\"76\":1}}],[\"一般以\",{\"1\":{\"72\":1}}],[\"一般来说都是因为网络接收软中断导致的\",{\"1\":{\"72\":1}}],[\"一般来说\",{\"1\":{\"58\":1}}],[\"一般\",{\"1\":{\"57\":1}}],[\"一个完整的网络包\",{\"1\":{\"303\":1}}],[\"一个完整的数据包可能会被拆分成多个小的数据包\",{\"1\":{\"26\":1}}],[\"一个普通的\",{\"1\":{\"167\":1}}],[\"一个字节有\",{\"1\":{\"145\":1}}],[\"一个随机数\",{\"1\":{\"129\":2}}],[\"一个叫作已完成连接\",{\"1\":{\"176\":1}}],[\"一个叫作监听\",{\"1\":{\"176\":1}}],[\"一个叫\",{\"1\":{\"116\":2}}],[\"一个系统通常都会运行着很多任务\",{\"1\":{\"61\":1}}],[\"一个\",{\"1\":{\"57\":1,\"106\":1,\"111\":1,\"148\":1,\"159\":1}}],[\"一个内存的访问地址\",{\"1\":{\"49\":1}}],[\"一个是设备的\",{\"1\":{\"306\":1}}],[\"一个是便于精确计算\",{\"1\":{\"246\":1}}],[\"一个是证书验证\",{\"1\":{\"121\":1}}],[\"一个是证书传输\",{\"1\":{\"121\":1}}],[\"一个是\",{\"1\":{\"49\":1}}],[\"一个基于vue的博客系统\",{\"1\":{\"11\":1}}],[\"一个基于go语言开发的投票系统\",{\"1\":{\"10\":1}}],[\"一名在校大学生\",{\"1\":{\"2\":1}}],[\"描述\",{\"1\":{\"10\":1,\"11\":1}}],[\"项目名称2\",{\"0\":{\"11\":1}}],[\"项目名称1\",{\"0\":{\"10\":1}}],[\"项目经验\",{\"0\":{\"9\":1}}],[\"m\",{\"1\":{\"241\":2}}],[\"min\",{\"1\":{\"177\":1,\"215\":1,\"230\":1}}],[\"msl\",{\"1\":{\"162\":2}}],[\"msl时报文的最大生存时间\",{\"1\":{\"162\":1}}],[\"mss等信息进行实时计算的\",{\"1\":{\"184\":1}}],[\"mss\",{\"1\":{\"158\":1,\"174\":1,\"230\":5,\"242\":1}}],[\"mtu\",{\"1\":{\"143\":7,\"158\":8,\"174\":1}}],[\"many\",{\"1\":{\"205\":1}}],[\"max\",{\"1\":{\"169\":2}}],[\"mac地址表\",{\"1\":{\"306\":1}}],[\"mac地址为\",{\"1\":{\"136\":1}}],[\"mac报文\",{\"1\":{\"304\":1}}],[\"mac协议只有两种\",{\"1\":{\"304\":1}}],[\"mac头部是以太网使用的头部\",{\"1\":{\"291\":1,\"304\":1}}],[\"mac头等一系列操作后\",{\"1\":{\"146\":1}}],[\"mac\",{\"0\":{\"304\":1},\"1\":{\"136\":13,\"150\":3,\"187\":1,\"283\":2,\"291\":1,\"297\":1,\"304\":1,\"306\":2,\"307\":8}}],[\"master\",{\"1\":{\"129\":4}}],[\"message验证\",{\"1\":{\"129\":1}}],[\"message\",{\"1\":{\"129\":2,\"139\":1,\"142\":2}}],[\"mesi\",{\"0\":{\"69\":1},\"1\":{\"68\":1,\"69\":4}}],[\"modified\",{\"1\":{\"69\":1,\"97\":1}}],[\"mongodb\",{\"1\":{\"7\":1}}],[\"mp\",{\"1\":{\"57\":1}}],[\"mysqld\",{\"1\":{\"62\":1}}],[\"mysql\",{\"1\":{\"7\":1}}],[\"g\",{\"1\":{\"129\":2}}],[\"get和post的方法都是安全和幂等的吗\",{\"0\":{\"91\":1}}],[\"get请求的参数都是在url\",{\"1\":{\"90\":1}}],[\"get\",{\"1\":{\"90\":1,\"91\":2}}],[\"get与post的区别\",{\"0\":{\"90\":1}}],[\"get与post请求\",{\"0\":{\"89\":1}}],[\"grant\",{\"1\":{\"44\":4}}],[\"git\",{\"1\":{\"8\":1}}],[\"github\",{\"1\":{\"1\":2}}],[\"goland里执行\",{\"1\":{\"83\":1}}],[\"go\",{\"1\":{\"6\":1,\"10\":1}}],[\"jvm\",{\"1\":{\"57\":1}}],[\"java\",{\"1\":{\"57\":1}}],[\"javascript\",{\"1\":{\"4\":1,\"10\":1}}],[\"jwt\",{\"1\":{\"47\":1}}],[\"json\",{\"1\":{\"47\":1,\"133\":1}}],[\"js\",{\"1\":{\"5\":1}}],[\"🎵\",{\"1\":{\"14\":1}}],[\"🌍\",{\"1\":{\"14\":1}}],[\"🎨\",{\"0\":{\"14\":1}}],[\"🎖️\",{\"0\":{\"13\":1}}],[\"🎓\",{\"0\":{\"12\":1}}],[\"🌐\",{\"0\":{\"5\":1}}],[\"🌟\",{\"0\":{\"0\":2}}],[\"challenge\",{\"1\":{\"249\":2,\"250\":1}}],[\"change\",{\"1\":{\"129\":4}}],[\"cp\",{\"1\":{\"191\":1}}],[\"cpu如何执行任务的\",{\"0\":{\"55\":1}}],[\"cpu中\",{\"1\":{\"53\":1}}],[\"cpu\",{\"0\":{\"48\":1,\"50\":1,\"53\":1,\"58\":1,\"61\":1,\"64\":1},\"1\":{\"49\":33,\"50\":4,\"51\":1,\"52\":2,\"53\":6,\"56\":8,\"57\":5,\"60\":1,\"61\":3,\"66\":5,\"67\":7,\"68\":8,\"69\":19,\"72\":6,\"75\":15,\"76\":4,\"77\":1,\"78\":1,\"119\":1,\"164\":1}}],[\"c类\",{\"0\":{\"153\":1}}],[\"cipher\",{\"1\":{\"129\":4}}],[\"certificate\",{\"1\":{\"121\":1,\"129\":2}}],[\"css\",{\"1\":{\"107\":3}}],[\"c\",{\"1\":{\"67\":4,\"153\":1,\"155\":1}}],[\"cfs\",{\"1\":{\"59\":1,\"60\":2,\"61\":4,\"62\":3}}],[\"cup的缓存一致性\",{\"0\":{\"63\":1}}],[\"cup是如何执行任务的\",{\"0\":{\"54\":1}}],[\"cup\",{\"0\":{\"49\":1}}],[\"call\",{\"1\":{\"132\":1}}],[\"ca\",{\"1\":{\"121\":2}}],[\"cahce\",{\"1\":{\"56\":2}}],[\"cacheline\",{\"1\":{\"57\":2}}],[\"cache\",{\"0\":{\"48\":1,\"49\":1,\"56\":1,\"64\":1},\"1\":{\"49\":37,\"50\":2,\"51\":1,\"52\":3,\"53\":4,\"56\":31,\"57\":18,\"64\":4,\"65\":3,\"66\":18,\"67\":13,\"68\":7,\"69\":33,\"78\":1,\"93\":8,\"94\":1}}],[\"cassandra等\",{\"1\":{\"47\":1}}],[\"closing\",{\"1\":{\"197\":1}}],[\"close函数是直接完全断开连接\",{\"1\":{\"197\":1}}],[\"close函数和shutdown函数的区别\",{\"1\":{\"197\":1}}],[\"close\",{\"0\":{\"161\":1,\"167\":1,\"179\":1},\"1\":{\"167\":5,\"176\":2,\"179\":3,\"197\":1,\"261\":5}}],[\"cluster\",{\"1\":{\"47\":1}}],[\"client\",{\"1\":{\"43\":1,\"44\":1,\"129\":5}}],[\"credentials\",{\"1\":{\"44\":2}}],[\"core\",{\"1\":{\"169\":1}}],[\"cors\",{\"1\":{\"46\":2}}],[\"connect\",{\"1\":{\"176\":1,\"178\":1,\"181\":1,\"192\":1,\"193\":2}}],[\"connection\",{\"1\":{\"88\":2,\"278\":3}}],[\"content\",{\"1\":{\"88\":7}}],[\"control\",{\"1\":{\"46\":2,\"93\":8,\"94\":1,\"139\":1}}],[\"coherence\",{\"1\":{\"67\":1}}],[\"cookies方案虽然能防\",{\"1\":{\"185\":1}}],[\"cookies方案为什么不直接取代半连接队列\",{\"0\":{\"185\":1}}],[\"cookie\",{\"1\":{\"46\":11,\"100\":2}}],[\"code\",{\"1\":{\"43\":1,\"44\":1}}],[\"completely\",{\"1\":{\"60\":1}}],[\"com为结尾的子域名下共享\",{\"1\":{\"46\":1}}],[\"com之间共享\",{\"1\":{\"46\":1}}],[\"com和subdomain\",{\"1\":{\"46\":1}}],[\"com\",{\"1\":{\"1\":2,\"46\":4,\"295\":5}}],[\"cwnd是发送方维护的一个的状态变量\",{\"1\":{\"215\":1}}],[\"cwnd\",{\"1\":{\"28\":5,\"215\":1,\"216\":3,\"217\":2,\"218\":9,\"219\":3}}],[\"c++\",{\"1\":{\"4\":1}}],[\"热衷于学习新技术并将其应用于实际项目中\",{\"1\":{\"2\":1}}],[\"手机就越省电\",{\"1\":{\"213\":1}}],[\"手机由于内存不足或其他各种原因\",{\"1\":{\"213\":1}}],[\"手机之类的设备支持\",{\"1\":{\"159\":1}}],[\"手机\",{\"1\":{\"1\":1}}],[\"💬\",{\"0\":{\"15\":1}}],[\"📦\",{\"0\":{\"10\":1}}],[\"📚\",{\"0\":{\"9\":1},\"1\":{\"14\":1}}],[\"🔧\",{\"0\":{\"8\":1}}],[\"🗄️\",{\"0\":{\"7\":1}}],[\"🛠️\",{\"0\":{\"6\":1}}],[\"🖥️\",{\"0\":{\"4\":1},\"1\":{\"14\":1}}],[\"🚀\",{\"0\":{\"3\":1}}],[\"📝\",{\"0\":{\"2\":1,\"11\":1}}],[\"🐱\",{\"1\":{\"1\":1}}],[\"📱\",{\"1\":{\"1\":1}}],[\"📧\",{\"1\":{\"1\":1}}],[\"📋\",{\"0\":{\"1\":1}}],[\"联系方式\",{\"1\":{\"1\":1}}],[\"牛马大学生\",{\"1\":{\"1\":1}}],[\"姓名\",{\"1\":{\"1\":1}}]],\"serializationVersion\":2}";